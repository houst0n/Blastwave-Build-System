diff -NPur jack-audio-connection-kit-0.103.0.orig/Makefile.am jack/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/Makefile.am	2006-05-26 09:45:28.000000000 +0700
+++ jack/Makefile.am	2007-08-25 15:30:47.000000000 +0700
@@ -13,7 +13,7 @@
 	@false
 endif
 
-SUBDIRS =      jack libjack jackd drivers example-clients $(DOC_DIR)
+SUBDIRS =      jack libjack jackd drivers example-clients config $(DOC_DIR)
 DIST_SUBDIRS = config jack libjack jackd drivers example-clients doc
 
 pkgconfigdir = $(libdir)/pkgconfig
diff -NPur jack-audio-connection-kit-0.103.0.orig/QUICK-INSTALL jack/QUICK-INSTALL
--- jack-audio-connection-kit-0.103.0.orig/QUICK-INSTALL	1970-01-01 07:00:00.000000000 +0700
+++ jack/QUICK-INSTALL	2007-08-25 15:30:47.000000000 +0700
@@ -0,0 +1,37 @@
+
+ Quick Install Guide
+---------------------
+
+1) in /usr/src/linux/include/linux/capability.h find these lines
+
+#define CAP_INIT_EFF_SET    to_cap_t(~0 & ~CAP_TO_MASK(CAP_SETPCAP))
+#define CAP_INIT_INH_SET    to_cap_t(0)
+
+   and change them to
+
+#define CAP_INIT_EFF_SET    to_cap_t(~0)
+#define CAP_INIT_INH_SET    to_cap_t(~0)
+
+   then recompile your kernel and boot it.  (Note that the above lines
+   are from linux 2.4.19; it may be different if you're using a
+   different version)
+
+   NB: This may expose your system to local denial of service attacks.
+   If it is a shared system or server, you should assess the impact of
+   enabling capabilities in the context of your overall system security
+   requirements.
+
+2) install libcap from
+   ftp://ftp.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.4/
+
+3) if you're using a journalling filesystem, mount some directory with
+   -t tmpfs and tell configure about it with --with-default-tmpdir
+
+4) configure with --enable-optimize --enable-capabilities and
+   --with-default-tmpdir=/where/ever
+
+5) make
+
+6) as root, do 
+
+       make install
diff -NPur jack-audio-connection-kit-0.103.0.orig/README.developers jack/README.developers
--- jack-audio-connection-kit-0.103.0.orig/README.developers	1970-01-01 07:00:00.000000000 +0700
+++ jack/README.developers	2007-08-25 15:30:47.000000000 +0700
@@ -0,0 +1,153 @@
+=======================================================================
+*** README.developers - JACK development practices                  ***
+=======================================================================
+
+:Version: $Id: README.developers 925 2005-09-11 12:34:41Z kaiv $
+:Formatting: restructured text, http://docutils.sourceforge.net/rst.html
+
+What is this? 
+-----------------------------------------------------------------------
+
+This file is a collection of practices and rules for JACK
+development. If you have questions, or would like to make 
+changes, raise the issue on jackit-devel (see 
+http://lists.sourceforge.net/lists/listinfo/jackit-devel ).
+
+
+Contents
+-----------------------------------------------------------------------
+
+- What is this?
+- Version numbers
+- Important files for developers
+- Sending patches
+- CVS Access
+- Decision Process
+
+
+Important files for developers
+-----------------------------------------------------------------------
+
+AUTHORS
+	List of contributors. If you have contributed code, mail Paul 
+	Davis to get your name added to the list, or if you have 
+	CVS-access, help yourself. :) Also remember to update the
+	per source file copyright statements when committing changes.
+
+README.developers 
+	This file.
+
+TODO
+	A one file mini-bugzilla for JACK developers. Note: this file
+	is no longer actively updated - please use the Mantis
+	bugtracker instead, see http://jackit.sourceforge.net/dev/ .
+
+libjack/ChangeLog
+	A list of _all_ changes to the public interface!
+
+
+Version numbers 
+-----------------------------------------------------------------------
+
+JACK's package version
+~~~~~~~~~~~~~~~~~~~~~~
+
+JACK's package version is set in configure.in, and consists of 
+major, minor and revision numbers. This version should be 
+updated whenever a non-trivial set of changes is committed 
+to CVS:
+ 
+major version
+   ask on jackit-devel :)
+
+minor version
+   incremented when any of the public or internal
+   interfaces are changed
+
+revision
+   incremented when implementation-only
+   changes are made
+
+Client API versioning
+~~~~~~~~~~~~~~~~~~~~~
+
+JACK clients are affected by two interfaces, the JACK Client API (libjack)
+and the JACK Client Protocol API (interface between jackd and 
+libjack). The former one is versioned using libtool interface 
+versioniong (set in configure.in). This version should be updated 
+whenever a set of changes affecting the interface is committed 
+to CVS:
+
+current
+    incremented whenever the public libjack API is changed 
+   
+revision
+    incremented when the libjack implementation is changed
+    
+age
+    current libjack is both source and binary compatible with
+    libjack interfaces current,current-1,...,current-age
+
+Note! It was decided in January 2003 that current interface number
+      will remain as zero until the first stable JACK version
+      is released.
+
+JACK Client Protocol is versioned... <TBD>.
+
+Note! All changes that affect the libjack API must be documented 
+in jack/libjack/ChangeLog using the standard ChangeLog style
+(see GNU developer docs).
+
+
+Sending patches
+---------------------------------------------------------------------
+
+People without CVS-access
+~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Send your patches to jackit-devel. Normally patches are accepted
+by Paul Davis and/or Jack O'Quin. Either the patch is applied right 
+away, or you get an "ok to me" message, after which other developers 
+with CVS-access can commit the patch.
+
+People with CVS-access
+~~~~~~~~~~~~~~~~~~~~~~
+
+Trivial changes can be committed without review. For non-trivial 
+changes, you should first send a proposal to jackit-devel and
+wait for comments. There are no strict approval rules so use of
+common sense is recommended. ;)
+
+Tips for making patches
+~~~~~~~~~~~~~~~~~~~~~~~
+
+- test your patch on a clean CVS-checkout
+- remember to run cvs update before making commits
+
+
+CVS Access
+-----------------------------------------------------------------------
+
+Contact Paul Davis.
+
+
+Uses of external libraries and other packages
+-----------------------------------------------------------------------
+
+The main JACK components, jackd and libjack, should only use 
+standard POSIX and ANSI-C services. If use of other interfaces is
+absolutely needed, it should be made optional in the build process (via
+a configure switch for example). 
+
+Other components like example clients and drivers, may rely on other 
+packages, but these dependencies should not affect the main build 
+process.
+
+
+Decision Process
+-----------------------------------------------------------------------
+
+All non-trivial changes should be discussed on the jackit-devel 
+mailing list. It has been agreed that Paul Davis will make 
+the final decisions based on these discussions.
+
diff -NPur jack-audio-connection-kit-0.103.0.orig/autogen.sh jack/autogen.sh
--- jack-audio-connection-kit-0.103.0.orig/autogen.sh	1970-01-01 07:00:00.000000000 +0700
+++ jack/autogen.sh	2007-08-25 15:30:47.000000000 +0700
@@ -0,0 +1,45 @@
+#!/bin/sh
+
+if which libtoolize >/dev/null
+then
+    LIBTOOLIZE=libtoolize
+else
+    if which glibtoolize >/dev/null
+    then
+	# on the Mac it's called glibtoolize for some reason
+	LIBTOOLIZE=glibtoolize
+    else
+	echo "libtoolize not found"
+	exit 1
+    fi
+fi
+
+$LIBTOOLIZE --force 2>&1 | sed '/^You should/d' || {
+    echo "libtool failed, exiting..."
+    exit 1
+}
+
+aclocal $ACLOCAL_FLAGS || {
+    echo "aclocal \$ACLOCAL_FLAGS where \$ACLOCAL_FLAGS= failed, exiting..."
+    exit 1
+}
+
+autoheader || {
+    echo "autoheader failed, exiting..."
+    exit 1
+}
+
+automake --add-missing --foreign || {
+    echo "automake --add-missing --foreign failed, exiting..."
+    exit 1
+}
+
+autoconf || {
+    echo "autoconf failed, exiting..."
+    exit 1
+}
+
+if test x$1 != x--no-conf; then
+  echo "Running ./configure --enable-maintainer-mode $@..."
+  ./configure --enable-maintainer-mode $@
+fi
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/Makefile.am jack/config/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/config/Makefile.am	2006-08-01 10:26:36.000000000 +0700
+++ jack/config/Makefile.am	2007-08-25 15:30:38.000000000 +0700
@@ -2,6 +2,7 @@
 # subdirectories.
 
 DIST_SUBDIRS = cpu os sysdeps
+
 EXTRA_DIST = depcomp
 MAINTAINERCLEANFILES = Makefile.in config.guess config.sub \
                        install-sh ltmain.sh missing mkinstalldirs 
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/cpu/alpha/cycles.h jack/config/cpu/alpha/cycles.h
--- jack-audio-connection-kit-0.103.0.orig/config/cpu/alpha/cycles.h	2006-05-26 09:45:16.000000000 +0700
+++ jack/config/cpu/alpha/cycles.h	2007-08-25 15:30:38.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: cycles.h 673 2004-03-25 19:31:51Z joq $
 */
 
 #ifndef __jack_cycles_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/cpu/generic/cycles.h jack/config/cpu/generic/cycles.h
--- jack-audio-connection-kit-0.103.0.orig/config/cpu/generic/cycles.h	2006-05-26 09:45:17.000000000 +0700
+++ jack/config/cpu/generic/cycles.h	2007-08-25 15:30:38.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: cycles.h 948 2006-05-15 17:12:44Z pbd $
 */
 
 #ifndef __jack_cycles_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/cpu/i386/cycles.h jack/config/cpu/i386/cycles.h
--- jack-audio-connection-kit-0.103.0.orig/config/cpu/i386/cycles.h	2006-05-26 09:45:17.000000000 +0700
+++ jack/config/cpu/i386/cycles.h	2007-08-25 15:30:38.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: cycles.h 948 2006-05-15 17:12:44Z pbd $
 */
 
 #ifndef __jack_cycles_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/cpu/ia64/cycles.h jack/config/cpu/ia64/cycles.h
--- jack-audio-connection-kit-0.103.0.orig/config/cpu/ia64/cycles.h	2006-05-26 09:45:16.000000000 +0700
+++ jack/config/cpu/ia64/cycles.h	2007-08-25 15:30:38.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: cycles.h 673 2004-03-25 19:31:51Z joq $
 */
 
 #ifndef __jack_cycles_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/cpu/powerpc/cycles.h jack/config/cpu/powerpc/cycles.h
--- jack-audio-connection-kit-0.103.0.orig/config/cpu/powerpc/cycles.h	2006-05-26 09:45:16.000000000 +0700
+++ jack/config/cpu/powerpc/cycles.h	2007-08-25 15:30:37.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: cycles.h 776 2004-10-23 01:46:14Z joq $
 */
 
 #ifndef __jack_cycles_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/generic/ipc.h jack/config/os/generic/ipc.h
--- jack-audio-connection-kit-0.103.0.orig/config/os/generic/ipc.h	2006-05-26 09:45:16.000000000 +0700
+++ jack/config/os/generic/ipc.h	2007-08-25 15:30:36.000000000 +0700
@@ -17,7 +17,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: ipc.h 673 2004-03-25 19:31:51Z joq $
 */
 
 #ifndef _jack_sys_ipc
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/generic/poll.h jack/config/os/generic/poll.h
--- jack-audio-connection-kit-0.103.0.orig/config/os/generic/poll.h	2006-05-26 09:45:16.000000000 +0700
+++ jack/config/os/generic/poll.h	2007-08-25 15:30:36.000000000 +0700
@@ -17,7 +17,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: poll.h 673 2004-03-25 19:31:51Z joq $
 */
 
 #ifndef _jack_sys_poll
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/generic/time.c jack/config/os/generic/time.c
--- jack-audio-connection-kit-0.103.0.orig/config/os/generic/time.c	2006-05-26 09:45:16.000000000 +0700
+++ jack/config/os/generic/time.c	2007-08-25 15:30:36.000000000 +0700
@@ -17,7 +17,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: time.c 950 2006-05-15 20:32:23Z pbd $
 */
 
 void jack_init_time ()
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/generic/time.h jack/config/os/generic/time.h
--- jack-audio-connection-kit-0.103.0.orig/config/os/generic/time.h	2006-05-26 09:45:16.000000000 +0700
+++ jack/config/os/generic/time.h	2007-08-25 15:30:36.000000000 +0700
@@ -17,14 +17,15 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: time.h 948 2006-05-15 17:12:44Z pbd $
 */
 #ifndef __jack_time_h__
 #define __jack_time_h__
 
-#include <jack/internal.h>
+#include <jack/types.h>
 
-inline jack_time_t
+extern jack_time_t jack_get_microseconds_from_system (void);
+
+static inline jack_time_t
 jack_get_microseconds (void) {
 	return jack_get_microseconds_from_system ();
 }
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/gnu-linux/Makefile.am jack/config/os/gnu-linux/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/config/os/gnu-linux/Makefile.am	2006-08-01 10:26:35.000000000 +0700
+++ jack/config/os/gnu-linux/Makefile.am	2007-08-25 15:30:34.000000000 +0700
@@ -1,2 +1,3 @@
 MAINTAINERCLEANFILES = Makefile.in
 noinst_HEADERS = time.c time.h
+
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/gnu-linux/time.c jack/config/os/gnu-linux/time.c
--- jack-audio-connection-kit-0.103.0.orig/config/os/gnu-linux/time.c	2007-01-17 07:48:46.000000000 +0700
+++ jack/config/os/gnu-linux/time.c	2007-08-25 15:30:34.000000000 +0700
@@ -17,7 +17,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: time.c 992 2006-11-03 18:09:23Z sonarnerd $
 */
 
 #include <config.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/gnu-linux/time.h jack/config/os/gnu-linux/time.h
--- jack-audio-connection-kit-0.103.0.orig/config/os/gnu-linux/time.h	2006-05-26 09:45:14.000000000 +0700
+++ jack/config/os/gnu-linux/time.h	2007-08-25 15:30:34.000000000 +0700
@@ -18,13 +18,12 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: time.h 948 2006-05-15 17:12:44Z pbd $
 */
 
 #ifndef __jack_time_h__
 #define __jack_time_h__
 
-#include <jack/internal.h>
+#include <jack/types.h>
 
 extern jack_time_t (*_jack_get_microseconds)(void);
 
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/macosx/Makefile.am jack/config/os/macosx/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/config/os/macosx/Makefile.am	2006-08-01 10:26:35.000000000 +0700
+++ jack/config/os/macosx/Makefile.am	2007-08-25 15:30:35.000000000 +0700
@@ -1,4 +1,5 @@
 MAINTAINERCLEANFILES = Makefile.in
 noinst_HEADERS = getopt.h ipc.h JACK_LOCATION.h mach_port.h \
 	poll.h pThreadUtilities.h time.c time.h
+
 EXTRA_DIST = jack.xcode/project.pbxproj
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/macosx/jack.xcodeproj/project.pbxproj jack/config/os/macosx/jack.xcodeproj/project.pbxproj
--- jack-audio-connection-kit-0.103.0.orig/config/os/macosx/jack.xcodeproj/project.pbxproj	1970-01-01 07:00:00.000000000 +0700
+++ jack/config/os/macosx/jack.xcodeproj/project.pbxproj	2007-08-25 15:30:35.000000000 +0700
@@ -0,0 +1,1625 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 42;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		4B117C6505DD0C8000B5DA5A /* port.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6305DD0C8000B5DA5A /* port.c */; };
+		4B117C6805DD0C8700B5DA5A /* pool.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6605DD0C8700B5DA5A /* pool.c */; };
+		4B117C6B05DD0C8D00B5DA5A /* driver.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6905DD0C8D00B5DA5A /* driver.c */; };
+		4B117C6E05DD0C9400B5DA5A /* ringbuffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6C05DD0C9400B5DA5A /* ringbuffer.c */; };
+		4B117C7105DD0C9900B5DA5A /* transclient.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6F05DD0C9900B5DA5A /* transclient.c */; };
+		4B117C7405DD0C9D00B5DA5A /* shm.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C7205DD0C9D00B5DA5A /* shm.c */; };
+		4B117C7705DD0CA000B5DA5A /* client.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C7505DD0CA000B5DA5A /* client.c */; };
+		4B117C7C05DD0CC000B5DA5A /* config.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B117C7A05DD0CC000B5DA5A /* config.h */; };
+		4B117C8005DD0D7700B5DA5A /* portaudio_driver.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C7F05DD0D7700B5DA5A /* portaudio_driver.c */; };
+		4B117C8205DD0D7D00B5DA5A /* portaudio_driver.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B117C8105DD0D7D00B5DA5A /* portaudio_driver.h */; };
+		4B117C8305DD0DA700B5DA5A /* driver.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6905DD0C8D00B5DA5A /* driver.c */; };
+		4B29A1C50B53A62E00C7ED2F /* Info-Jack_framework.plist in Resources */ = {isa = PBXBuildFile; fileRef = 4B29A1C40B53A62E00C7ED2F /* Info-Jack_framework.plist */; };
+		4B29A1C60B53A62E00C7ED2F /* Info-Jack_framework.plist in Resources */ = {isa = PBXBuildFile; fileRef = 4B29A1C40B53A62E00C7ED2F /* Info-Jack_framework.plist */; };
+		4B4DCB9405DD229F00DC3452 /* port.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6305DD0C8000B5DA5A /* port.c */; };
+		4B4DCB9505DD22AF00DC3452 /* pool.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6605DD0C8700B5DA5A /* pool.c */; };
+		4B4DCB9805DD22C300DC3452 /* shm.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C7205DD0C9D00B5DA5A /* shm.c */; };
+		4B4DCBA305DD234100DC3452 /* ringbuffer.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4DCBA105DD234100DC3452 /* ringbuffer.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B4DCBA605DD234800DC3452 /* transport.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4DCBA405DD234800DC3452 /* transport.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B4DCBA905DD235B00DC3452 /* types.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4DCBA705DD235B00DC3452 /* types.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B4DCBAF05DD23DE00DC3452 /* metro.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B4DCBAE05DD23DE00DC3452 /* metro.c */; };
+		4B4DCBB305DD243A00DC3452 /* connect.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B4DCBB205DD243A00DC3452 /* connect.c */; };
+		4B4DCBB605DD248300DC3452 /* connect.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B4DCBB205DD243A00DC3452 /* connect.c */; };
+		4B4DCBBA05DD249E00DC3452 /* lsp.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B4DCBB905DD249E00DC3452 /* lsp.c */; };
+		4B5B51EC047D353A00053105 /* ipc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B5B51EA047D353A00053105 /* ipc.h */; };
+		4B5B51F0047D353A00053105 /* ipc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B5B51EA047D353A00053105 /* ipc.h */; };
+		4B6683E40A2D8B2E00E8ADF8 /* midiport.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B6683E30A2D8B2E00E8ADF8 /* midiport.c */; };
+		4B6683ED0A2D8C2A00E8ADF8 /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B6683EC0A2D8C2A00E8ADF8 /* time.c */; };
+		4B77679A072D2B9500F14709 /* transengine.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B776799072D2B9500F14709 /* transengine.h */; };
+		4B77679F072D2BAD00F14709 /* local.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B77679E072D2BAD00F14709 /* local.h */; };
+		4B7F53D20A470FE600075B93 /* pThreadUtilities.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B16FF900467B5A000053105 /* pThreadUtilities.h */; };
+		4B7F53D30A470FE600075B93 /* mach_port.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BB9E091046FADED00053105 /* mach_port.h */; };
+		4B7F53D40A470FE600075B93 /* ipc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B5B51EA047D353A00053105 /* ipc.h */; };
+		4B7F53D50A470FE600075B93 /* config.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B117C7A05DD0CC000B5DA5A /* config.h */; };
+		4B7F53D60A470FE600075B93 /* ringbuffer.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4DCBA105DD234100DC3452 /* ringbuffer.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B7F53D70A470FE600075B93 /* transport.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4DCBA405DD234800DC3452 /* transport.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B7F53D80A470FE600075B93 /* types.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B4DCBA705DD235B00DC3452 /* types.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B7F53D90A470FE600075B93 /* timestamps.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BA39A1E05DD2C63008919E8 /* timestamps.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B7F53DA0A470FE600075B93 /* jack.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BA39A2205DD2CA5008919E8 /* jack.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4B7F53DD0A470FE600075B93 /* port.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6305DD0C8000B5DA5A /* port.c */; };
+		4B7F53DE0A470FE600075B93 /* pool.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6605DD0C8700B5DA5A /* pool.c */; };
+		4B7F53DF0A470FE600075B93 /* driver.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6905DD0C8D00B5DA5A /* driver.c */; };
+		4B7F53E00A470FE600075B93 /* ringbuffer.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6C05DD0C9400B5DA5A /* ringbuffer.c */; };
+		4B7F53E10A470FE600075B93 /* transclient.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6F05DD0C9900B5DA5A /* transclient.c */; };
+		4B7F53E20A470FE600075B93 /* shm.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C7205DD0C9D00B5DA5A /* shm.c */; };
+		4B7F53E30A470FE600075B93 /* client.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C7505DD0CA000B5DA5A /* client.c */; };
+		4B7F53E40A470FE600075B93 /* thread.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B89C95906F596060003AD09 /* thread.c */; };
+		4B7F53E50A470FE600075B93 /* midiport.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B6683E30A2D8B2E00E8ADF8 /* midiport.c */; };
+		4B7F53E60A470FE600075B93 /* time.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B6683EC0A2D8C2A00E8ADF8 /* time.c */; };
+		4B813FF007240D000025D71C /* thread.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B89C95906F596060003AD09 /* thread.c */; };
+		4B81400707240DA30025D71C /* transclient.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6F05DD0C9900B5DA5A /* transclient.c */; };
+		4B81402C07240F650025D71C /* pool.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6605DD0C8700B5DA5A /* pool.c */; };
+		4B81402D07240F660025D71C /* port.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6305DD0C8000B5DA5A /* port.c */; };
+		4B81402E07240F680025D71C /* shm.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C7205DD0C9D00B5DA5A /* shm.c */; };
+		4B81402F07240F690025D71C /* thread.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B89C95906F596060003AD09 /* thread.c */; };
+		4B81403007240F6A0025D71C /* transclient.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6F05DD0C9900B5DA5A /* transclient.c */; };
+		4B81409407241E580025D71C /* driver.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B117C6905DD0C8D00B5DA5A /* driver.c */; };
+		4B89C95A06F596060003AD09 /* thread.c in Sources */ = {isa = PBXBuildFile; fileRef = 4B89C95906F596060003AD09 /* thread.c */; };
+		4BA1CAE60470D1FB00053105 /* pThreadUtilities.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B16FF900467B5A000053105 /* pThreadUtilities.h */; };
+		4BA1CAEA0470D1FD00053105 /* mach_port.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BB9E091046FADED00053105 /* mach_port.h */; };
+		4BA39A2005DD2C63008919E8 /* timestamps.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BA39A1E05DD2C63008919E8 /* timestamps.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4BA39A2405DD2CA5008919E8 /* jack.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BA39A2205DD2CA5008919E8 /* jack.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		4BB9E097046FB05700053105 /* mach_port.h in Headers */ = {isa = PBXBuildFile; fileRef = 4BB9E091046FADED00053105 /* mach_port.h */; };
+		4BE7704107A00B15001AA2F0 /* coreaudio_driver.c in Sources */ = {isa = PBXBuildFile; fileRef = 4BA736DC079FE7E00041E425 /* coreaudio_driver.c */; };
+		4BE7704207A00B15001AA2F0 /* coreaudio_driver.h in Headers */ = {isa = PBXBuildFile; fileRef = 4B1A736907252DDC007105CE /* coreaudio_driver.h */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		4B099343041FB67A00053105 /* fakepoll.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = fakepoll.h; sourceTree = "<group>"; };
+		4B117C5805DD0C3600B5DA5A /* jackd.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = jackd.c; path = ../../../jackd/jackd.c; sourceTree = SOURCE_ROOT; };
+		4B117C5A05DD0C4100B5DA5A /* engine.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = engine.c; path = ../../../jackd/engine.c; sourceTree = SOURCE_ROOT; };
+		4B117C5D05DD0C5B00B5DA5A /* transengine.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = transengine.c; path = ../../../jackd/transengine.c; sourceTree = SOURCE_ROOT; };
+		4B117C6305DD0C8000B5DA5A /* port.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = port.c; path = ../../../libjack/port.c; sourceTree = SOURCE_ROOT; };
+		4B117C6605DD0C8700B5DA5A /* pool.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = pool.c; path = ../../../libjack/pool.c; sourceTree = SOURCE_ROOT; };
+		4B117C6905DD0C8D00B5DA5A /* driver.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = driver.c; path = ../../../libjack/driver.c; sourceTree = SOURCE_ROOT; };
+		4B117C6C05DD0C9400B5DA5A /* ringbuffer.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = ringbuffer.c; path = ../../../libjack/ringbuffer.c; sourceTree = SOURCE_ROOT; };
+		4B117C6F05DD0C9900B5DA5A /* transclient.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = transclient.c; path = ../../../libjack/transclient.c; sourceTree = SOURCE_ROOT; };
+		4B117C7205DD0C9D00B5DA5A /* shm.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = shm.c; path = ../../../libjack/shm.c; sourceTree = SOURCE_ROOT; };
+		4B117C7505DD0CA000B5DA5A /* client.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = client.c; path = ../../../libjack/client.c; sourceTree = SOURCE_ROOT; };
+		4B117C7A05DD0CC000B5DA5A /* config.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = config.h; path = ../../../config.h; sourceTree = SOURCE_ROOT; };
+		4B117C7F05DD0D7700B5DA5A /* portaudio_driver.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = portaudio_driver.c; path = ../../../drivers/portaudio/portaudio_driver.c; sourceTree = SOURCE_ROOT; };
+		4B117C8105DD0D7D00B5DA5A /* portaudio_driver.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = portaudio_driver.h; path = ../../../drivers/portaudio/portaudio_driver.h; sourceTree = SOURCE_ROOT; };
+		4B16FF900467B5A000053105 /* pThreadUtilities.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = pThreadUtilities.h; sourceTree = SOURCE_ROOT; };
+		4B1A736907252DDC007105CE /* coreaudio_driver.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = coreaudio_driver.h; path = ../../../drivers/coreaudio/coreaudio_driver.h; sourceTree = SOURCE_ROOT; };
+		4B29A1C40B53A62E00C7ED2F /* Info-Jack_framework.plist */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = text.xml; path = "Info-Jack_framework.plist"; sourceTree = SOURCE_ROOT; };
+		4B4DCBA105DD234100DC3452 /* ringbuffer.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = ringbuffer.h; path = ../../../jack/ringbuffer.h; sourceTree = SOURCE_ROOT; };
+		4B4DCBA405DD234800DC3452 /* transport.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = transport.h; path = ../../../jack/transport.h; sourceTree = SOURCE_ROOT; };
+		4B4DCBA705DD235B00DC3452 /* types.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = types.h; path = ../../../jack/types.h; sourceTree = SOURCE_ROOT; };
+		4B4DCBAE05DD23DE00DC3452 /* metro.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = metro.c; path = "../../../example-clients/metro.c"; sourceTree = SOURCE_ROOT; };
+		4B4DCBB205DD243A00DC3452 /* connect.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = connect.c; path = "../../../example-clients/connect.c"; sourceTree = SOURCE_ROOT; };
+		4B4DCBB905DD249E00DC3452 /* lsp.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = lsp.c; path = "../../../example-clients/lsp.c"; sourceTree = SOURCE_ROOT; };
+		4B4DCBBD05DD24CD00DC3452 /* capture_client.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = capture_client.c; path = "../../../example-clients/capture_client.c"; sourceTree = SOURCE_ROOT; };
+		4B5B51EA047D353A00053105 /* ipc.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = ipc.h; sourceTree = SOURCE_ROOT; };
+		4B6683E30A2D8B2E00E8ADF8 /* midiport.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = midiport.c; path = ../../../libjack/midiport.c; sourceTree = SOURCE_ROOT; };
+		4B6683EC0A2D8C2A00E8ADF8 /* time.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = time.c; path = ../../../libjack/time.c; sourceTree = SOURCE_ROOT; };
+		4B776780072D2B5700F14709 /* atomicity.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = atomicity.h; path = ../../../jack/atomicity.h; sourceTree = SOURCE_ROOT; };
+		4B776785072D2B5700F14709 /* driver_interface.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = driver_interface.h; path = ../../../jack/driver_interface.h; sourceTree = SOURCE_ROOT; };
+		4B776786072D2B5700F14709 /* driver_parse.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = driver_parse.h; path = ../../../jack/driver_parse.h; sourceTree = SOURCE_ROOT; };
+		4B776787072D2B5700F14709 /* driver.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = driver.h; path = ../../../jack/driver.h; sourceTree = SOURCE_ROOT; };
+		4B776788072D2B5700F14709 /* engine.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = engine.h; path = ../../../jack/engine.h; sourceTree = SOURCE_ROOT; };
+		4B776789072D2B5700F14709 /* hardware.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = hardware.h; path = ../../../jack/hardware.h; sourceTree = SOURCE_ROOT; };
+		4B77678A072D2B5700F14709 /* jslist.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = jslist.h; path = ../../../jack/jslist.h; sourceTree = SOURCE_ROOT; };
+		4B77678E072D2B5700F14709 /* memops.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = memops.h; path = ../../../jack/memops.h; sourceTree = SOURCE_ROOT; };
+		4B77678F072D2B5700F14709 /* pool.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = pool.h; path = ../../../jack/pool.h; sourceTree = SOURCE_ROOT; };
+		4B776790072D2B5700F14709 /* port.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = port.h; path = ../../../jack/port.h; sourceTree = SOURCE_ROOT; };
+		4B776791072D2B5700F14709 /* shm.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = shm.h; path = ../../../jack/shm.h; sourceTree = SOURCE_ROOT; };
+		4B776792072D2B5700F14709 /* start.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = start.h; path = ../../../jack/start.h; sourceTree = SOURCE_ROOT; };
+		4B776793072D2B5700F14709 /* thread.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = thread.h; path = ../../../jack/thread.h; sourceTree = SOURCE_ROOT; };
+		4B776794072D2B5700F14709 /* unlock.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = unlock.h; path = ../../../jack/unlock.h; sourceTree = SOURCE_ROOT; };
+		4B776795072D2B5700F14709 /* version.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = version.h; path = ../../../jack/version.h; sourceTree = SOURCE_ROOT; };
+		4B776799072D2B9500F14709 /* transengine.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = transengine.h; path = ../../../jackd/transengine.h; sourceTree = SOURCE_ROOT; };
+		4B77679E072D2BAD00F14709 /* local.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = local.h; path = ../../../libjack/local.h; sourceTree = SOURCE_ROOT; };
+		4B7F53EA0A470FE600075B93 /* Jack.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Jack.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B81402607240F550025D71C /* jack_coreaudio.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = jack_coreaudio.so; sourceTree = BUILT_PRODUCTS_DIR; };
+		4B8254140779F6AF0016C8D6 /* clientengine.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = clientengine.c; path = ../../../jackd/clientengine.c; sourceTree = SOURCE_ROOT; };
+		4B89C95906F596060003AD09 /* thread.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = thread.c; path = ../../../libjack/thread.c; sourceTree = SOURCE_ROOT; };
+		4BA1CADF0470D14500053105 /* Jack.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; path = Jack.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BA1CB010470D38800053105 /* jack_disconnect */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; path = jack_disconnect; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BA1E4580442D99D00053105 /* jack_lsp */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; path = jack_lsp; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BA39A1E05DD2C63008919E8 /* timestamps.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = timestamps.h; path = ../../../jack/timestamps.h; sourceTree = SOURCE_ROOT; };
+		4BA39A2205DD2CA5008919E8 /* jack.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; name = jack.h; path = ../../../jack/jack.h; sourceTree = SOURCE_ROOT; };
+		4BA736DC079FE7E00041E425 /* coreaudio_driver.c */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.c; name = coreaudio_driver.c; path = ../../../drivers/coreaudio/coreaudio_driver.c; sourceTree = SOURCE_ROOT; };
+		4BAA76A6047E0D5200053105 /* getopt.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = getopt.h; sourceTree = SOURCE_ROOT; };
+		4BB9E091046FADED00053105 /* mach_port.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = mach_port.h; sourceTree = "<group>"; };
+		4BBB87310406EF300019BE76 /* jack_portaudio.so */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; path = jack_portaudio.so; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BCA2603040B8B9400053105 /* jack_metro */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.executable"; path = jack_metro; sourceTree = BUILT_PRODUCTS_DIR; };
+		4BF87130040BDE8200053105 /* jack_connect */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; path = jack_connect; sourceTree = BUILT_PRODUCTS_DIR; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworkTarget section */
+		4BA1CADE0470D14500053105 /* Jack framework */ = {
+			isa = PBXFrameworkTarget;
+			buildConfigurationList = 4B29A19E0B53A60F00C7ED2F /* Build configuration list for PBXFrameworkTarget "Jack framework" */;
+			buildPhases = (
+				4BA1CAD90470D14500053105 /* Headers */,
+				4BA1CADA0470D14500053105 /* Resources */,
+				4BA1CADB0470D14500053105 /* Sources */,
+				4BA1CADC0470D14500053105 /* Frameworks */,
+				4BA1CADD0470D14500053105 /* Rez */,
+			);
+			dependencies = (
+			);
+			name = "Jack framework";
+			productInstallPath = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+			productName = Jack;
+			productReference = 4BA1CADF0470D14500053105 /* Jack.framework */;
+			productSettingsXML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>
+<!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
+<plist version=\"1.0\">
+<dict>
+	<key>CFBundleDevelopmentRegion</key>
+	<string>English</string>
+	<key>CFBundleExecutable</key>
+	<string>Jack</string>
+	<key>CFBundleGetInfoString</key>
+	<string>Jack Server 0.102.8, @03-06 Paul Davis, Grame</string>
+	<key>CFBundleIconFile</key>
+	<string></string>
+	<key>CFBundleIdentifier</key>
+	<string>com.grame.Jack</string>
+	<key>CFBundleInfoDictionaryVersion</key>
+	<string>6.0</string>
+	<key>CFBundleName</key>
+	<string>Jack</string>
+	<key>CFBundlePackageType</key>
+	<string>FMWK</string>
+	<key>CFBundleShortVersionString</key>
+	<string>Jack</string>
+	<key>CFBundleSignature</key>
+	<string>????</string>
+	<key>CFBundleVersion</key>
+	<string>0.102.8</string>
+</dict>
+</plist>
+";
+		};
+/* End PBXFrameworkTarget section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		4B7F53E70A470FE600075B93 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4B81402307240F550025D71C /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CADC0470D14500053105 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CAFE0470D38800053105 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1E4550442D99D00053105 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BBB872E0406EF300019BE76 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BCA2600040B8B9400053105 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BF8712D040BDE8200053105 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		08FB7794FE84155DC02AAC07 /* jackd */ = {
+			isa = PBXGroup;
+			children = (
+				4B29A1C40B53A62E00C7ED2F /* Info-Jack_framework.plist */,
+				4BA9D903040E0CC200053105 /* Headers */,
+				4B6CBA33041F4DDF00053105 /* Porting_code */,
+				4B6AF278041F4DBC00053105 /* Samples */,
+				4BA716600408E047004F4E3A /* Driver */,
+				4BA7165F0408DFF5004F4E3A /* Server */,
+				08FB7795FE84155DC02AAC07 /* Client */,
+				1AB674ADFE9D54B511CA2CBB /* Products */,
+			);
+			name = jackd;
+			sourceTree = "<group>";
+		};
+		08FB7795FE84155DC02AAC07 /* Client */ = {
+			isa = PBXGroup;
+			children = (
+				4B89C95906F596060003AD09 /* thread.c */,
+				4B117C6305DD0C8000B5DA5A /* port.c */,
+				4B117C6605DD0C8700B5DA5A /* pool.c */,
+				4B117C6905DD0C8D00B5DA5A /* driver.c */,
+				4B117C6C05DD0C9400B5DA5A /* ringbuffer.c */,
+				4B117C6F05DD0C9900B5DA5A /* transclient.c */,
+				4B117C7205DD0C9D00B5DA5A /* shm.c */,
+				4B117C7505DD0CA000B5DA5A /* client.c */,
+				4B6683E30A2D8B2E00E8ADF8 /* midiport.c */,
+				4B6683EC0A2D8C2A00E8ADF8 /* time.c */,
+			);
+			name = Client;
+			sourceTree = "<group>";
+		};
+		1AB674ADFE9D54B511CA2CBB /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				4BBB87310406EF300019BE76 /* jack_portaudio.so */,
+				4BCA2603040B8B9400053105 /* jack_metro */,
+				4BF87130040BDE8200053105 /* jack_connect */,
+				4BA1E4580442D99D00053105 /* jack_lsp */,
+				4BA1CADF0470D14500053105 /* Jack.framework */,
+				4BA1CB010470D38800053105 /* jack_disconnect */,
+				4B81402607240F550025D71C /* jack_coreaudio.so */,
+				4B7F53EA0A470FE600075B93 /* Jack.framework */,
+			);
+			name = Products;
+			sourceTree = "<group>";
+		};
+		4B6AF278041F4DBC00053105 /* Samples */ = {
+			isa = PBXGroup;
+			children = (
+				4B4DCBAE05DD23DE00DC3452 /* metro.c */,
+				4B4DCBB205DD243A00DC3452 /* connect.c */,
+				4B4DCBB905DD249E00DC3452 /* lsp.c */,
+				4B4DCBBD05DD24CD00DC3452 /* capture_client.c */,
+			);
+			name = Samples;
+			sourceTree = "<group>";
+		};
+		4B6CBA33041F4DDF00053105 /* Porting_code */ = {
+			isa = PBXGroup;
+			children = (
+				4B117C7A05DD0CC000B5DA5A /* config.h */,
+				4B16FF900467B5A000053105 /* pThreadUtilities.h */,
+				4B099343041FB67A00053105 /* fakepoll.h */,
+				4B5B51EA047D353A00053105 /* ipc.h */,
+				4BB9E091046FADED00053105 /* mach_port.h */,
+				4BAA76A6047E0D5200053105 /* getopt.h */,
+			);
+			name = Porting_code;
+			sourceTree = "<group>";
+		};
+		4BA7165F0408DFF5004F4E3A /* Server */ = {
+			isa = PBXGroup;
+			children = (
+				4B117C5805DD0C3600B5DA5A /* jackd.c */,
+				4B117C5A05DD0C4100B5DA5A /* engine.c */,
+				4B8254140779F6AF0016C8D6 /* clientengine.c */,
+				4B117C5D05DD0C5B00B5DA5A /* transengine.c */,
+			);
+			name = Server;
+			sourceTree = "<group>";
+		};
+		4BA716600408E047004F4E3A /* Driver */ = {
+			isa = PBXGroup;
+			children = (
+				4BA736DC079FE7E00041E425 /* coreaudio_driver.c */,
+				4B1A736907252DDC007105CE /* coreaudio_driver.h */,
+				4B117C7F05DD0D7700B5DA5A /* portaudio_driver.c */,
+				4B117C8105DD0D7D00B5DA5A /* portaudio_driver.h */,
+			);
+			name = Driver;
+			sourceTree = "<group>";
+		};
+		4BA9D903040E0CC200053105 /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				4B77679E072D2BAD00F14709 /* local.h */,
+				4B776799072D2B9500F14709 /* transengine.h */,
+				4B776780072D2B5700F14709 /* atomicity.h */,
+				4B776785072D2B5700F14709 /* driver_interface.h */,
+				4B776786072D2B5700F14709 /* driver_parse.h */,
+				4B776787072D2B5700F14709 /* driver.h */,
+				4B776788072D2B5700F14709 /* engine.h */,
+				4B776789072D2B5700F14709 /* hardware.h */,
+				4B77678A072D2B5700F14709 /* jslist.h */,
+				4B77678E072D2B5700F14709 /* memops.h */,
+				4B77678F072D2B5700F14709 /* pool.h */,
+				4B776790072D2B5700F14709 /* port.h */,
+				4B776791072D2B5700F14709 /* shm.h */,
+				4B776792072D2B5700F14709 /* start.h */,
+				4B776793072D2B5700F14709 /* thread.h */,
+				4B776794072D2B5700F14709 /* unlock.h */,
+				4B776795072D2B5700F14709 /* version.h */,
+				4BA39A2205DD2CA5008919E8 /* jack.h */,
+				4BA39A1E05DD2C63008919E8 /* timestamps.h */,
+				4B4DCBA105DD234100DC3452 /* ringbuffer.h */,
+				4B4DCBA405DD234800DC3452 /* transport.h */,
+				4B4DCBA705DD235B00DC3452 /* types.h */,
+			);
+			name = Headers;
+			sourceTree = "<group>";
+		};
+/* End PBXGroup section */
+
+/* Begin PBXHeadersBuildPhase section */
+		4B7F53D10A470FE600075B93 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B7F53D20A470FE600075B93 /* pThreadUtilities.h in Headers */,
+				4B7F53D30A470FE600075B93 /* mach_port.h in Headers */,
+				4B7F53D40A470FE600075B93 /* ipc.h in Headers */,
+				4B7F53D50A470FE600075B93 /* config.h in Headers */,
+				4B7F53D60A470FE600075B93 /* ringbuffer.h in Headers */,
+				4B7F53D70A470FE600075B93 /* transport.h in Headers */,
+				4B7F53D80A470FE600075B93 /* types.h in Headers */,
+				4B7F53D90A470FE600075B93 /* timestamps.h in Headers */,
+				4B7F53DA0A470FE600075B93 /* jack.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4B81402107240F550025D71C /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B77679A072D2B9500F14709 /* transengine.h in Headers */,
+				4B77679F072D2BAD00F14709 /* local.h in Headers */,
+				4BE7704207A00B15001AA2F0 /* coreaudio_driver.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CAD90470D14500053105 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4BA1CAE60470D1FB00053105 /* pThreadUtilities.h in Headers */,
+				4BA1CAEA0470D1FD00053105 /* mach_port.h in Headers */,
+				4B5B51F0047D353A00053105 /* ipc.h in Headers */,
+				4B117C7C05DD0CC000B5DA5A /* config.h in Headers */,
+				4B4DCBA305DD234100DC3452 /* ringbuffer.h in Headers */,
+				4B4DCBA605DD234800DC3452 /* transport.h in Headers */,
+				4B4DCBA905DD235B00DC3452 /* types.h in Headers */,
+				4BA39A2005DD2C63008919E8 /* timestamps.h in Headers */,
+				4BA39A2405DD2CA5008919E8 /* jack.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CAFC0470D38800053105 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1E4530442D99D00053105 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BBB872C0406EF300019BE76 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4BB9E097046FB05700053105 /* mach_port.h in Headers */,
+				4B5B51EC047D353A00053105 /* ipc.h in Headers */,
+				4B117C8205DD0D7D00B5DA5A /* portaudio_driver.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BCA25FE040B8B9400053105 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BF8712B040BDE8200053105 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXHeadersBuildPhase section */
+
+/* Begin PBXLibraryTarget section */
+		4B81402507240F550025D71C /* jack_coreaudio */ = {
+			isa = PBXLibraryTarget;
+			buildConfigurationList = 4B29A1B60B53A60F00C7ED2F /* Build configuration list for PBXLibraryTarget "jack_coreaudio" */;
+			buildPhases = (
+				4B81402107240F550025D71C /* Headers */,
+				4B81402207240F550025D71C /* Sources */,
+				4B81402307240F550025D71C /* Frameworks */,
+				4B81402407240F550025D71C /* Rez */,
+			);
+			dependencies = (
+			);
+			name = jack_coreaudio;
+			productInstallPath = /usr/local/lib;
+			productName = jack_coreaudio;
+			productReference = 4B81402607240F550025D71C /* jack_coreaudio.so */;
+		};
+		4BBB87300406EF300019BE76 /* jack_portaudio */ = {
+			isa = PBXLibraryTarget;
+			buildConfigurationList = 4B29A1BA0B53A60F00C7ED2F /* Build configuration list for PBXLibraryTarget "jack_portaudio" */;
+			buildPhases = (
+				4BBB872C0406EF300019BE76 /* Headers */,
+				4BBB872D0406EF300019BE76 /* Sources */,
+				4BBB872E0406EF300019BE76 /* Frameworks */,
+				4BBB872F0406EF300019BE76 /* Rez */,
+			);
+			dependencies = (
+			);
+			name = jack_portaudio;
+			productInstallPath = /usr/local/lib;
+			productName = driver;
+			productReference = 4BBB87310406EF300019BE76 /* jack_portaudio.so */;
+		};
+/* End PBXLibraryTarget section */
+
+/* Begin PBXNativeTarget section */
+		4B7F53D00A470FE600075B93 /* Jack framework Universal */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 4B29A1A20B53A60F00C7ED2F /* Build configuration list for PBXNativeTarget "Jack framework Universal" */;
+			buildPhases = (
+				4B7F53D10A470FE600075B93 /* Headers */,
+				4B7F53DB0A470FE600075B93 /* Resources */,
+				4B7F53DC0A470FE600075B93 /* Sources */,
+				4B7F53E70A470FE600075B93 /* Frameworks */,
+				4B7F53E80A470FE600075B93 /* Rez */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "Jack framework Universal";
+			productInstallPath = "$(LOCAL_LIBRARY_DIR)/Frameworks";
+			productName = Jack;
+			productReference = 4B7F53EA0A470FE600075B93 /* Jack.framework */;
+			productType = "com.apple.product-type.framework";
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		08FB7793FE84155DC02AAC07 /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = 4B29A1BE0B53A60F00C7ED2F /* Build configuration list for PBXProject "jack" */;
+			hasScannedForEncodings = 1;
+			mainGroup = 08FB7794FE84155DC02AAC07 /* jackd */;
+			projectDirPath = "";
+			targets = (
+				4BA1CADE0470D14500053105 /* Jack framework */,
+				4B7F53D00A470FE600075B93 /* Jack framework Universal */,
+				4BCA2602040B8B9400053105 /* jack_metro */,
+				4BF8712F040BDE8200053105 /* jack_connect */,
+				4BA1CB000470D38800053105 /* jack_disconnect */,
+				4BA1E4570442D99D00053105 /* jack_lsp */,
+				4B81402507240F550025D71C /* jack_coreaudio */,
+				4BBB87300406EF300019BE76 /* jack_portaudio */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		4B7F53DB0A470FE600075B93 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B29A1C60B53A62E00C7ED2F /* Info-Jack_framework.plist in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CADA0470D14500053105 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B29A1C50B53A62E00C7ED2F /* Info-Jack_framework.plist in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXRezBuildPhase section */
+		4B7F53E80A470FE600075B93 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4B81402407240F550025D71C /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CADD0470D14500053105 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CAFF0470D38800053105 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1E4560442D99D00053105 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BBB872F0406EF300019BE76 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BCA2601040B8B9400053105 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BF8712E040BDE8200053105 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXRezBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		4B7F53DC0A470FE600075B93 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B7F53DD0A470FE600075B93 /* port.c in Sources */,
+				4B7F53DE0A470FE600075B93 /* pool.c in Sources */,
+				4B7F53DF0A470FE600075B93 /* driver.c in Sources */,
+				4B7F53E00A470FE600075B93 /* ringbuffer.c in Sources */,
+				4B7F53E10A470FE600075B93 /* transclient.c in Sources */,
+				4B7F53E20A470FE600075B93 /* shm.c in Sources */,
+				4B7F53E30A470FE600075B93 /* client.c in Sources */,
+				4B7F53E40A470FE600075B93 /* thread.c in Sources */,
+				4B7F53E50A470FE600075B93 /* midiport.c in Sources */,
+				4B7F53E60A470FE600075B93 /* time.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4B81402207240F550025D71C /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B81402C07240F650025D71C /* pool.c in Sources */,
+				4B81402D07240F660025D71C /* port.c in Sources */,
+				4B81402E07240F680025D71C /* shm.c in Sources */,
+				4B81402F07240F690025D71C /* thread.c in Sources */,
+				4B81403007240F6A0025D71C /* transclient.c in Sources */,
+				4B81409407241E580025D71C /* driver.c in Sources */,
+				4BE7704107A00B15001AA2F0 /* coreaudio_driver.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CADB0470D14500053105 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B117C6505DD0C8000B5DA5A /* port.c in Sources */,
+				4B117C6805DD0C8700B5DA5A /* pool.c in Sources */,
+				4B117C6B05DD0C8D00B5DA5A /* driver.c in Sources */,
+				4B117C6E05DD0C9400B5DA5A /* ringbuffer.c in Sources */,
+				4B117C7105DD0C9900B5DA5A /* transclient.c in Sources */,
+				4B117C7405DD0C9D00B5DA5A /* shm.c in Sources */,
+				4B117C7705DD0CA000B5DA5A /* client.c in Sources */,
+				4B89C95A06F596060003AD09 /* thread.c in Sources */,
+				4B6683E40A2D8B2E00E8ADF8 /* midiport.c in Sources */,
+				4B6683ED0A2D8C2A00E8ADF8 /* time.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1CAFD0470D38800053105 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B4DCBB605DD248300DC3452 /* connect.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BA1E4540442D99D00053105 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B4DCBBA05DD249E00DC3452 /* lsp.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BBB872D0406EF300019BE76 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B117C8005DD0D7700B5DA5A /* portaudio_driver.c in Sources */,
+				4B117C8305DD0DA700B5DA5A /* driver.c in Sources */,
+				4B4DCB9405DD229F00DC3452 /* port.c in Sources */,
+				4B4DCB9505DD22AF00DC3452 /* pool.c in Sources */,
+				4B4DCB9805DD22C300DC3452 /* shm.c in Sources */,
+				4B813FF007240D000025D71C /* thread.c in Sources */,
+				4B81400707240DA30025D71C /* transclient.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BCA25FF040B8B9400053105 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B4DCBAF05DD23DE00DC3452 /* metro.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		4BF8712C040BDE8200053105 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				4B4DCBB305DD243A00DC3452 /* connect.c in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXToolTarget section */
+		4BA1CB000470D38800053105 /* jack_disconnect */ = {
+			isa = PBXToolTarget;
+			buildConfigurationList = 4B29A1AE0B53A60F00C7ED2F /* Build configuration list for PBXToolTarget "jack_disconnect" */;
+			buildPhases = (
+				4BA1CAFC0470D38800053105 /* Headers */,
+				4BA1CAFD0470D38800053105 /* Sources */,
+				4BA1CAFE0470D38800053105 /* Frameworks */,
+				4BA1CAFF0470D38800053105 /* Rez */,
+			);
+			dependencies = (
+			);
+			name = jack_disconnect;
+			productInstallPath = /usr/local/bin;
+			productName = jack_disconnect;
+			productReference = 4BA1CB010470D38800053105 /* jack_disconnect */;
+		};
+		4BA1E4570442D99D00053105 /* jack_lsp */ = {
+			isa = PBXToolTarget;
+			buildConfigurationList = 4B29A1B20B53A60F00C7ED2F /* Build configuration list for PBXToolTarget "jack_lsp" */;
+			buildPhases = (
+				4BA1E4530442D99D00053105 /* Headers */,
+				4BA1E4540442D99D00053105 /* Sources */,
+				4BA1E4550442D99D00053105 /* Frameworks */,
+				4BA1E4560442D99D00053105 /* Rez */,
+			);
+			dependencies = (
+			);
+			name = jack_lsp;
+			productInstallPath = /usr/local/bin;
+			productName = jack_lsp;
+			productReference = 4BA1E4580442D99D00053105 /* jack_lsp */;
+		};
+		4BCA2602040B8B9400053105 /* jack_metro */ = {
+			isa = PBXToolTarget;
+			buildConfigurationList = 4B29A1A60B53A60F00C7ED2F /* Build configuration list for PBXToolTarget "jack_metro" */;
+			buildPhases = (
+				4BCA25FE040B8B9400053105 /* Headers */,
+				4BCA25FF040B8B9400053105 /* Sources */,
+				4BCA2600040B8B9400053105 /* Frameworks */,
+				4BCA2601040B8B9400053105 /* Rez */,
+			);
+			dependencies = (
+			);
+			name = jack_metro;
+			productInstallPath = /usr/local/bin;
+			productName = metro;
+			productReference = 4BCA2603040B8B9400053105 /* jack_metro */;
+		};
+		4BF8712F040BDE8200053105 /* jack_connect */ = {
+			isa = PBXToolTarget;
+			buildConfigurationList = 4B29A1AA0B53A60F00C7ED2F /* Build configuration list for PBXToolTarget "jack_connect" */;
+			buildPhases = (
+				4BF8712B040BDE8200053105 /* Headers */,
+				4BF8712C040BDE8200053105 /* Sources */,
+				4BF8712D040BDE8200053105 /* Frameworks */,
+				4BF8712E040BDE8200053105 /* Rez */,
+			);
+			dependencies = (
+			);
+			name = jack_connect;
+			productInstallPath = /usr/local/bin;
+			productName = connect;
+			productReference = 4BF87130040BDE8200053105 /* jack_connect */;
+		};
+/* End PBXToolTarget section */
+
+/* Begin XCBuildConfiguration section */
+		4B29A19F0B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				LIBRARY_SEARCH_PATHS = "";
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_LDFLAGS = (
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PREFIX_HEADER = ./JACK_LOCATION.h;
+				PRINCIPAL_CLASS = "";
+				PRODUCT_NAME = Jack;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				WRAPPER_EXTENSION = framework;
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B29A1A00B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				LIBRARY_SEARCH_PATHS = "";
+				OPTIMIZATION_CFLAGS = "-O3";
+				OTHER_LDFLAGS = (
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PREFIX_HEADER = ./JACK_LOCATION.h;
+				PRINCIPAL_CLASS = "";
+				PRODUCT_NAME = Jack;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				WRAPPER_EXTENSION = framework;
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B29A1A10B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				LIBRARY_SEARCH_PATHS = "";
+				OPTIMIZATION_CFLAGS = "-O3";
+				OTHER_LDFLAGS = (
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PREFIX_HEADER = ./JACK_LOCATION.h;
+				PRINCIPAL_CLASS = "";
+				PRODUCT_NAME = Jack;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				WRAPPER_EXTENSION = framework;
+			};
+			name = Default;
+		};
+		4B29A1A30B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					ppc,
+					i386,
+				);
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PREFIX_HEADER = ./JACK_LOCATION.h;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				INFOPLIST_FILE = "Info-Jack_framework.plist";
+				LIBRARY_SEARCH_PATHS = "";
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_LDFLAGS = (
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PRINCIPAL_CLASS = "";
+				PRODUCT_NAME = Jack;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				WRAPPER_EXTENSION = framework;
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B29A1A40B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					ppc,
+					i386,
+				);
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_OPTIMIZATION_LEVEL = 3;
+				GCC_PREFIX_HEADER = ./JACK_LOCATION.h;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				INFOPLIST_FILE = "Info-Jack_framework.plist";
+				LIBRARY_SEARCH_PATHS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PRINCIPAL_CLASS = "";
+				PRODUCT_NAME = Jack;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				WRAPPER_EXTENSION = framework;
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B29A1A50B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					ppc,
+					i386,
+				);
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_OPTIMIZATION_LEVEL = 3;
+				GCC_PREFIX_HEADER = ./JACK_LOCATION.h;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				INFOPLIST_FILE = "Info-Jack_framework.plist";
+				LIBRARY_SEARCH_PATHS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					CoreAudio,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PRINCIPAL_CLASS = "";
+				PRODUCT_NAME = Jack;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				WRAPPER_EXTENSION = framework;
+			};
+			name = Default;
+		};
+		4B29A1A70B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				HEADER_SEARCH_PATHS = ../../;
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = jack_metro;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B29A1A80B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				HEADER_SEARCH_PATHS = ../../;
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = jack_metro;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B29A1A90B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				HEADER_SEARCH_PATHS = ../../;
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PREBINDING = NO;
+				PRODUCT_NAME = jack_metro;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+			};
+			name = Default;
+		};
+		4B29A1AB0B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				HEADER_SEARCH_PATHS = "";
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_connect;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B29A1AC0B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				HEADER_SEARCH_PATHS = "";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_connect;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B29A1AD0B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				HEADER_SEARCH_PATHS = "";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_connect;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+			};
+			name = Default;
+		};
+		4B29A1AF0B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_disconnect;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B29A1B00B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_disconnect;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B29A1B10B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_disconnect;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+			};
+			name = Default;
+		};
+		4B29A1B30B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				HEADER_SEARCH_PATHS = ../../;
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_lsp;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B29A1B40B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				HEADER_SEARCH_PATHS = ../../;
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_lsp;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B29A1B50B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				HEADER_SEARCH_PATHS = ../../;
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-framework",
+					Jack,
+				);
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_lsp;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+			};
+			name = Default;
+		};
+		4B29A1B70B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				HEADER_SEARCH_PATHS = (
+					../../../,
+					../../,
+				);
+				LIBRARY_STYLE = BUNDLE;
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-ljack",
+					"-framework",
+					CoreAudio,
+					"-framework",
+					AudioUnit,
+					"-framework",
+					CoreServices,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				PRODUCT_NAME = jack_coreaudio.so;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B29A1B80B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				HEADER_SEARCH_PATHS = (
+					../../../,
+					../../,
+				);
+				LIBRARY_STYLE = BUNDLE;
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-ljack",
+					"-framework",
+					CoreAudio,
+					"-framework",
+					AudioUnit,
+					"-framework",
+					CoreServices,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				PRODUCT_NAME = jack_coreaudio.so;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B29A1B90B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				HEADER_SEARCH_PATHS = (
+					../../../,
+					../../,
+				);
+				LIBRARY_STYLE = BUNDLE;
+				OTHER_CFLAGS = "";
+				OTHER_LDFLAGS = (
+					"-ljack",
+					"-framework",
+					CoreAudio,
+					"-framework",
+					AudioUnit,
+					"-framework",
+					CoreServices,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PREFIX_HEADER = "$(SYSTEM_LIBRARY_DIR)/Frameworks/Carbon.framework/Headers/Carbon.h";
+				PRODUCT_NAME = jack_coreaudio.so;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+			};
+			name = Default;
+		};
+		4B29A1BB0B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = YES;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				LIBRARY_SEARCH_PATHS = "";
+				LIBRARY_STYLE = BUNDLE;
+				OPTIMIZATION_CFLAGS = "-O0";
+				OTHER_CFLAGS = "-DJACK_USE_MACH_THREADS";
+				OTHER_LDFLAGS = (
+					"-ljack",
+					"-framework",
+					CoreAudio,
+					"-framework",
+					AudioToolbox,
+					PortAudioLib,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_portaudio.so;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = YES;
+			};
+			name = Development;
+		};
+		4B29A1BC0B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				LIBRARY_SEARCH_PATHS = "";
+				LIBRARY_STYLE = BUNDLE;
+				OPTIMIZATION_CFLAGS = "-O3";
+				OTHER_CFLAGS = "-DJACK_USE_MACH_THREADS";
+				OTHER_LDFLAGS = (
+					"-ljack",
+					"-framework",
+					CoreAudio,
+					"-framework",
+					AudioToolbox,
+					PortAudioLib,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_portaudio.so;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+				ZERO_LINK = NO;
+			};
+			name = Deployment;
+		};
+		4B29A1BD0B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				HEADER_SEARCH_PATHS = (
+					../../,
+					../../../,
+				);
+				LIBRARY_SEARCH_PATHS = "";
+				LIBRARY_STYLE = BUNDLE;
+				OPTIMIZATION_CFLAGS = "-O3";
+				OTHER_CFLAGS = "-DJACK_USE_MACH_THREADS";
+				OTHER_LDFLAGS = (
+					"-ljack",
+					"-framework",
+					CoreAudio,
+					"-framework",
+					AudioToolbox,
+					PortAudioLib,
+				);
+				OTHER_LIBTOOL_FLAGS = "";
+				OTHER_REZFLAGS = "";
+				PRODUCT_NAME = jack_portaudio.so;
+				REZ_EXECUTABLE = YES;
+				SECTORDER_FLAGS = "";
+				WARNING_CFLAGS = (
+					"-Wmost",
+					"-Wno-four-char-constants",
+					"-Wno-unknown-pragmas",
+				);
+			};
+			name = Default;
+		};
+		4B29A1BF0B53A60F00C7ED2F /* Development */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+			};
+			name = Development;
+		};
+		4B29A1C00B53A60F00C7ED2F /* Deployment */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+			};
+			name = Deployment;
+		};
+		4B29A1C10B53A60F00C7ED2F /* Default */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+			};
+			name = Default;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		4B29A19E0B53A60F00C7ED2F /* Build configuration list for PBXFrameworkTarget "Jack framework" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A19F0B53A60F00C7ED2F /* Development */,
+				4B29A1A00B53A60F00C7ED2F /* Deployment */,
+				4B29A1A10B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+		4B29A1A20B53A60F00C7ED2F /* Build configuration list for PBXNativeTarget "Jack framework Universal" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A1A30B53A60F00C7ED2F /* Development */,
+				4B29A1A40B53A60F00C7ED2F /* Deployment */,
+				4B29A1A50B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+		4B29A1A60B53A60F00C7ED2F /* Build configuration list for PBXToolTarget "jack_metro" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A1A70B53A60F00C7ED2F /* Development */,
+				4B29A1A80B53A60F00C7ED2F /* Deployment */,
+				4B29A1A90B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+		4B29A1AA0B53A60F00C7ED2F /* Build configuration list for PBXToolTarget "jack_connect" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A1AB0B53A60F00C7ED2F /* Development */,
+				4B29A1AC0B53A60F00C7ED2F /* Deployment */,
+				4B29A1AD0B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+		4B29A1AE0B53A60F00C7ED2F /* Build configuration list for PBXToolTarget "jack_disconnect" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A1AF0B53A60F00C7ED2F /* Development */,
+				4B29A1B00B53A60F00C7ED2F /* Deployment */,
+				4B29A1B10B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+		4B29A1B20B53A60F00C7ED2F /* Build configuration list for PBXToolTarget "jack_lsp" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A1B30B53A60F00C7ED2F /* Development */,
+				4B29A1B40B53A60F00C7ED2F /* Deployment */,
+				4B29A1B50B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+		4B29A1B60B53A60F00C7ED2F /* Build configuration list for PBXLibraryTarget "jack_coreaudio" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A1B70B53A60F00C7ED2F /* Development */,
+				4B29A1B80B53A60F00C7ED2F /* Deployment */,
+				4B29A1B90B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+		4B29A1BA0B53A60F00C7ED2F /* Build configuration list for PBXLibraryTarget "jack_portaudio" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A1BB0B53A60F00C7ED2F /* Development */,
+				4B29A1BC0B53A60F00C7ED2F /* Deployment */,
+				4B29A1BD0B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+		4B29A1BE0B53A60F00C7ED2F /* Build configuration list for PBXProject "jack" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4B29A1BF0B53A60F00C7ED2F /* Development */,
+				4B29A1C00B53A60F00C7ED2F /* Deployment */,
+				4B29A1C10B53A60F00C7ED2F /* Default */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Default;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 08FB7793FE84155DC02AAC07 /* Project object */;
+}
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/macosx/time.c jack/config/os/macosx/time.c
--- jack-audio-connection-kit-0.103.0.orig/config/os/macosx/time.c	2006-05-26 09:45:15.000000000 +0700
+++ jack/config/os/macosx/time.c	2007-08-25 15:30:35.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: time.c 955 2006-05-16 16:04:31Z pbd $
 */
 
 #ifndef __jack_time_c__
diff -NPur jack-audio-connection-kit-0.103.0.orig/config/os/macosx/time.h jack/config/os/macosx/time.h
--- jack-audio-connection-kit-0.103.0.orig/config/os/macosx/time.h	2006-05-26 09:45:15.000000000 +0700
+++ jack/config/os/macosx/time.h	2007-08-25 15:30:35.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: time.h 948 2006-05-15 17:12:44Z pbd $
 */
 
 #ifndef __jack_time_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/configure.ac jack/configure.ac
--- jack-audio-connection-kit-0.103.0.orig/configure.ac	2007-03-06 12:24:05.000000000 +0700
+++ jack/configure.ac	2007-08-25 15:30:47.000000000 +0700
@@ -1,5 +1,5 @@
 dnl Process this file with autoconf to produce a configure script.
-dnl $Id: configure.ac 1012 2007-02-24 00:01:25Z paul $
+dnl $Id: configure.ac 1050 2007-06-12 20:46:40Z sonarnerd $
 
 AC_INIT(jackd/jackd.c)
 
@@ -16,8 +16,8 @@
 dnl                 changes are made
 dnl ---
 JACK_MAJOR_VERSION=0
-JACK_MINOR_VERSION=103
-JACK_MICRO_VERSION=0
+JACK_MINOR_VERSION=107
+JACK_MICRO_VERSION=2
 
 dnl ---
 dnl HOWTO: updating the jack protocol version
@@ -27,7 +27,7 @@
 dnl that would break applications linked with an older
 dnl version of libjack.
 dnl ---
-JACK_PROTOCOL_VERSION=16
+JACK_PROTOCOL_VERSION=21
 
 dnl ---
 dnl HOWTO: updating the libjack interface version
@@ -44,7 +44,7 @@
 dnl number.
 dnl ---
 JACK_API_CURRENT=0
-JACK_API_REVISION=23
+JACK_API_REVISION=28
 JACK_API_AGE=0
 
 AC_SUBST(JACK_MAJOR_VERSION)
@@ -443,7 +443,7 @@
 USE_CAPABILITIES=false
 
 AC_ARG_ENABLE(capabilities,
-              [  --enable-capabilities   use libcap to gain realtime scheduling priviledges],
+              [  --enable-capabilities   !!! LINUX 2.4 KERNELS ONLY !!! use libcap to gain realtime scheduling priviledges],
               [ if test "x$enable_capabilities" != "xno" ; then
                     AC_CHECK_LIB(cap, capgetp,
                                  [AC_CHECK_HEADER(sys/capability.h,
@@ -513,10 +513,10 @@
 
 # allow specifying default tmpdir
 AC_ARG_WITH(default-tmpdir,
-            [  --with-default-tmpdir=PATH    where jackd and clients will put tmp files (/tmp)])
+            [  --with-default-tmpdir=PATH    where jackd and clients will put tmp files (/dev/shm)])
 
 if test "x$with_default_tmpdir" = "x" ; then
-	DEFAULT_TMP_DIR=/tmp
+	DEFAULT_TMP_DIR=/dev/shm
 else
 	DEFAULT_TMP_DIR=$with_default_tmpdir
 fi
@@ -554,7 +554,7 @@
 JACK_DEFAULT_DRIVER=\"dummy\"
 
 AC_ARG_ENABLE(portaudio, [  --disable-portaudio     ignore PortAudio driver ],
-			TRY_PORTAUDIO=$enableval , TRY_PORTAUDIO=yes ) 
+			TRY_PORTAUDIO=$enableval , TRY_PORTAUDIO=no ) 
 HAVE_PA="false"
 if test "x$TRY_PORTAUDIO" = "xyes"
 then
@@ -595,7 +595,7 @@
 fi
 AM_CONDITIONAL(HAVE_OSS, $HAVE_OSS)
 
-AC_ARG_ENABLE(freebob, [  --disable-freebob       ignore FreeBob driver ],
+AC_ARG_ENABLE(freebob, [  --disable-freebob          ignore FreeBob driver ],
 			TRY_FREEBOB=$enableval , TRY_FREEBOB=yes ) 
 HAVE_FREEBOB="false"
 if test "x$TRY_FREEBOB" = "xyes"
@@ -612,6 +612,23 @@
 fi
 AM_CONDITIONAL(HAVE_FREEBOB,$HAVE_FREEBOB)
 
+AC_ARG_ENABLE(firewire, [  --disable-firewire          ignore FireWire driver (FFADO) ],
+			TRY_FIREWIRE=$enableval , TRY_FIREWIRE=yes ) 
+HAVE_FIREWIRE="false"
+if test "x$TRY_FIREWIRE" = "xyes"
+then
+	# check for FFADO libraries
+	PKG_CHECK_MODULES(LIBFFADO, libffado >= 1.999.0,
+	     [HAVE_FIREWIRE="true"
+              JACK_DEFAULT_DRIVER=\"firewire\"
+	     ], AC_MSG_RESULT([no]))
+
+	AC_SUBST([LIBFFADO_CFLAGS])
+	AC_SUBST([LIBFFADO_LIBS])
+
+fi
+AM_CONDITIONAL(HAVE_FIREWIRE,$HAVE_FIREWIRE)
+
 AC_ARG_ENABLE(alsa, [  --disable-alsa          ignore ALSA driver ],
 			TRY_ALSA=$enableval , TRY_ALSA=yes ) 
 HAVE_ALSA="false"
@@ -628,6 +645,9 @@
 fi
 AM_CONDITIONAL(HAVE_ALSA, $HAVE_ALSA)
 
+HAVE_ALSA_MIDI=$HAVE_ALSA
+AM_CONDITIONAL(HAVE_ALSA_MIDI, $HAVE_ALSA_MIDI)
+
 if test "$JACK_DEFAULT_DRIVER" = \"dummy\"; then
   AC_MSG_WARN([Only the dummy driver can be built])
 fi
@@ -643,17 +663,16 @@
 # point always returns the same result regardless of any dependent
 # libraries specified.  The `unset ac_cv_lib_readline_readline' erases
 # the cached result to work around this problem.
-
 READLINE_DEPS=""
-HAVE_READLINE="false"
-#AC_CHECK_LIB(readline, readline, [:],
-#    [unset ac_cv_lib_readline_readline
-#     AC_CHECK_LIB(readline, readline, [READLINE_DEPS="-ltermcap"],
-#        [unset ac_cv_lib_readline_readline
-#	 AC_CHECK_LIB(readline, readline,
-#	    [READLINE_DEPS="-lncurses"], [HAVE_READLINE=false], "-lncurses")],
-#	"-ltermcap")])
-#AC_CHECK_HEADER(readline/chardefs.h, [], [HAVE_READLINE=false])
+HAVE_READLINE=true
+AC_CHECK_LIB(readline, readline, [:],
+    [unset ac_cv_lib_readline_readline
+     AC_CHECK_LIB(readline, readline, [READLINE_DEPS="-ltermcap"],
+        [unset ac_cv_lib_readline_readline
+	 AC_CHECK_LIB(readline, readline,
+	    [READLINE_DEPS="-lncurses"], [HAVE_READLINE=false], "-lncurses")],
+	"-ltermcap")])
+AC_CHECK_HEADER(readline/chardefs.h, [], [HAVE_READLINE=false])
 if test x$HAVE_READLINE = xfalse; then
 	AC_MSG_WARN([*** the jack_transport example client will not be built])
 fi
@@ -694,11 +713,13 @@
 doc/reference.doxygen
 drivers/Makefile
 drivers/alsa/Makefile
+drivers/alsa-midi/Makefile
 drivers/dummy/Makefile
 drivers/oss/Makefile
 drivers/portaudio/Makefile
 drivers/coreaudio/Makefile
 drivers/freebob/Makefile
+drivers/firewire/Makefile
 example-clients/Makefile
 jack.pc
 jack.spec
@@ -717,7 +738,8 @@
 echo $PACKAGE $VERSION :
 echo
 echo \| Build with ALSA support............................... : $HAVE_ALSA
-echo \| Build with FreeBob support............................ : $HAVE_FREEBOB
+echo \| Build with old FireWire \(FreeBob\) support............. : $HAVE_FREEBOB
+echo \| Build with new FireWire \(FFADO\) support............... : $HAVE_FIREWIRE
 echo \| Build with OSS support................................ : $HAVE_OSS
 echo \| Build with CoreAudio support.......................... : $HAVE_COREAUDIO
 echo \| Build with PortAudio support.......................... : $HAVE_PA
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/Makefile.am jack/drivers/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/drivers/Makefile.am	2006-05-26 09:45:28.000000000 +0700
+++ jack/drivers/Makefile.am	2007-08-25 15:30:47.000000000 +0700
@@ -6,6 +6,12 @@
 ALSA_DIR =
 endif
 
+if HAVE_ALSA_MIDI
+ALSA_MIDI_DIR = alsa-midi
+else
+ALSA_MIDI_DIR =
+endif
+
 if HAVE_OSS
 OSS_DIR = oss
 else
@@ -30,5 +36,11 @@
 FREEBOB_DIR =
 endif
 
-SUBDIRS = $(ALSA_DIR) dummy $(OSS_DIR) $(PA_DIR) $(CA_DIR) $(FREEBOB_DIR)
-DIST_SUBDIRS = alsa dummy oss portaudio coreaudio freebob
+if HAVE_FIREWIRE
+FIREWIRE_DIR = firewire
+else
+FIREWIRE_DIR =
+endif
+
+SUBDIRS = $(ALSA_MIDI_DIR) $(ALSA_DIR) dummy $(OSS_DIR) $(PA_DIR) $(CA_DIR) $(FREEBOB_DIR) $(FIREWIRE_DIR)
+DIST_SUBDIRS = alsa alsa-midi dummy oss portaudio coreaudio freebob firewire
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/Makefile.am jack/drivers/alsa/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/Makefile.am	2006-06-14 09:18:59.000000000 +0700
+++ jack/drivers/alsa/Makefile.am	2007-08-25 15:30:44.000000000 +0700
@@ -8,7 +8,10 @@
 
 jack_alsa_la_LDFLAGS = -module -avoid-version
 jack_alsa_la_SOURCES = alsa_driver.c generic_hw.c memops.c \
-		       hammerfall.c hdsp.c ice1712.c usx2y.c
+		       hammerfall.c hdsp.c ice1712.c usx2y.c \
+                       ../alsa-midi/alsa_rawmidi.c ../alsa-midi/alsa_seqmidi.c
+
+jack_alsa_la_CFLAGS = -I../alsa-midi
 
 noinst_HEADERS = alsa_driver.h \
 		generic.h \
@@ -18,4 +21,4 @@
 		memops.h \
 		usx2y.h
 
-jack_alsa_la_LIBADD = $(ALSA_LIBS)
+jack_alsa_la_LIBADD = $(ALSA_LIBS) 
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/alsa_driver.c jack/drivers/alsa/alsa_driver.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/alsa_driver.c	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/alsa_driver.c	2007-08-25 15:30:44.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: alsa_driver.c 960 2006-05-25 14:01:10Z paul $
 */
 
 #include <math.h>
@@ -415,14 +414,14 @@
 		}
 	}
 	
-	format = (sample_width == 4) ? 0 : FIRST_16BIT_FORMAT;
+	format = (sample_width == 4) ? 0 : NUMFORMATS - 1;
 
 	while (1) {
 		if ((err = snd_pcm_hw_params_set_format (
 			     handle, hw_params, formats[format].format)) < 0) {
 
 			if ((sample_width == 4
-			     ? format++ >= FIRST_16BIT_FORMAT
+			     ? format++ >= NUMFORMATS - 1
 			     : format-- <= 0)) {
 				jack_error ("Sorry. The audio interface \"%s\""
 					    " doesn't support any of the"
@@ -1023,6 +1022,9 @@
 		malloc (sizeof (struct pollfd) * 
 			(driver->playback_nfds + driver->capture_nfds + 2));
 
+	if (driver->midi && !driver->xrun_recovery)
+		(driver->midi->start)(driver->midi);
+
 	if (driver->playback_handle) {
 		/* fill playback buffer with zeroes, and mark 
 		   all fragments as having data.
@@ -1127,15 +1129,26 @@
 		driver->hw->set_input_monitor_mask (driver->hw, 0);
 	}
 
+	if (driver->midi && !driver->xrun_recovery)
+		(driver->midi->stop)(driver->midi);
+
 	return 0;
 }
 
 static int
 alsa_driver_restart (alsa_driver_t *driver)
 {
- 	if (driver->nt_stop((struct _jack_driver_nt *) driver))
- 	    return -1;
- 	return driver->nt_start((struct _jack_driver_nt *) driver);
+	int res;
+
+	driver->xrun_recovery = 1;
+ 	if ((res = driver->nt_stop((struct _jack_driver_nt *) driver))==0)
+		res = driver->nt_start((struct _jack_driver_nt *) driver);
+	driver->xrun_recovery = 0;
+
+	if (res && driver->midi)
+		(driver->midi->stop)(driver->midi);
+
+	return res;
 }
 
 static int
@@ -1235,9 +1248,10 @@
 	
 	while (need_playback || need_capture) {
 
-		unsigned int p_timed_out, c_timed_out;
+		int poll_result;
 		unsigned int ci = 0;
 		unsigned int nfds;
+		unsigned short revents;
 
 		nfds = 0;
 
@@ -1281,7 +1295,8 @@
 			driver->poll_late++;
 		}
 
-		if (poll (driver->pfd, nfds, driver->poll_timeout) < 0) {
+		poll_result = poll (driver->pfd, nfds, driver->poll_timeout);
+		if (poll_result < 0) {
 
 			if (errno == EINTR) {
 				printf ("poll interrupt\n");
@@ -1337,25 +1352,20 @@
 			return (driver->pfd[nfds-1].revents == POLLIN) ? 0 : -1;
 		}
 
-		p_timed_out = 0;
-		
 		if (need_playback) {
-			for (i = 0; i < driver->playback_nfds; i++) {
-				if (driver->pfd[i].revents & POLLERR) {
-					xrun_detected = TRUE;
-				}
-				
-				if (driver->pfd[i].revents == 0) {
-					p_timed_out++;
-#ifdef DEBUG_WAKEUP
-					fprintf (stderr, "%" PRIu64
-						 " playback stream timed out\n",
-						 poll_ret);
-#endif
-				}
+			if (snd_pcm_poll_descriptors_revents
+			    (driver->playback_handle, &driver->pfd[0],
+			     driver->playback_nfds, &revents) < 0) {
+				jack_error ("ALSA: playback revents failed");
+				*status = -6;
+				return 0;
 			}
-			
-			if (p_timed_out == 0) {
+
+			if (revents & POLLERR) {
+				xrun_detected = TRUE;
+			}
+
+			if (revents & POLLOUT) {
 				need_playback = 0;
 #ifdef DEBUG_WAKEUP
 				fprintf (stderr, "%" PRIu64
@@ -1364,26 +1374,21 @@
 #endif
 			}
 		}
-		
-		c_timed_out = 0;
 
 		if (need_capture) {
-			for (i = ci; i < nfds; i++) {
-				if (driver->pfd[i].revents & POLLERR) {
-					xrun_detected = TRUE;
-				}
-				
-				if (driver->pfd[i].revents == 0) {
-					c_timed_out++;
-#ifdef DEBUG_WAKEUP
-					fprintf (stderr, "%" PRIu64
-						 " capture stream timed out\n",
-						 poll_ret);
-#endif
-				}
+			if (snd_pcm_poll_descriptors_revents
+			    (driver->capture_handle, &driver->pfd[ci],
+			     driver->capture_nfds, &revents) < 0) {
+				jack_error ("ALSA: capture revents failed");
+				*status = -6;
+				return 0;
 			}
-			
-			if (c_timed_out == 0) {
+
+			if (revents & POLLERR) {
+				xrun_detected = TRUE;
+			}
+
+			if (revents & POLLIN) {
 				need_capture = 0;
 #ifdef DEBUG_WAKEUP
 				fprintf (stderr, "%" PRIu64
@@ -1393,8 +1398,7 @@
 			}
 		}
 		
-		if ((p_timed_out && (p_timed_out == driver->playback_nfds)) &&
-		    (c_timed_out && (c_timed_out == driver->capture_nfds))){
+		if (poll_result == 0) {
 			jack_error ("ALSA: poll time out, polled for %" PRIu64
 				    " usecs",
 				    poll_ret - poll_enter);
@@ -1554,6 +1558,9 @@
 	if (nframes > driver->frames_per_cycle) {
 		return -1;
 	}
+
+	if (driver->midi)
+		(driver->midi->read)(driver->midi, nframes);
 	
 	nread = 0;
 	contiguous = 0;
@@ -1623,6 +1630,9 @@
 		return -1;
 	}
 
+	if (driver->midi)
+		(driver->midi->write)(driver->midi, nframes);
+	
 	nwritten = 0;
 	contiguous = 0;
 	orig_nframes = nframes;
@@ -1752,7 +1762,7 @@
 
 	for (chn = 0; chn < driver->capture_nchannels; chn++) {
 
-		snprintf (buf, sizeof(buf) - 1, "capture_%lu", chn+1);
+		snprintf (buf, sizeof(buf), "capture_%lu", chn+1);
 
 		if ((port = jack_port_register (driver->client, buf,
 						JACK_DEFAULT_AUDIO_TYPE,
@@ -1806,6 +1816,12 @@
 		}
 	}
 
+	if (driver->midi) {
+		int err = (driver->midi->attach)(driver->midi);
+		if (err)
+			jack_error("ALSA: cannot attach midi: %d", err);
+	}
+	
 
 	return jack_activate (driver->client);
 }
@@ -1819,6 +1835,9 @@
 		return 0;
 	}
 
+	if (driver->midi)
+		(driver->midi->detach)(driver->midi);
+	
 	for (node = driver->capture_ports; node;
 	     node = jack_slist_next (node)) {
 		jack_port_unregister (driver->client,
@@ -1905,6 +1924,9 @@
 {
 	JSList *node;
 
+	if (driver->midi)
+		(driver->midi->destroy)(driver->midi);
+
 	for (node = driver->clock_sync_listeners; node;
 	     node = jack_slist_next (node)) {
 		free (node->data);
@@ -1976,7 +1998,8 @@
 		 int user_playback_nchnls,
 		 int shorts_first,
 		 jack_nframes_t capture_latency,
-		 jack_nframes_t playback_latency
+		 jack_nframes_t playback_latency,
+		 alsa_midi_t *midi_driver
 		 )
 {
 	int err;
@@ -2059,6 +2082,9 @@
 	driver->alsa_name_playback = strdup (playback_alsa_device);
 	driver->alsa_name_capture = strdup (capture_alsa_device);
 
+	driver->midi = midi_driver;
+	driver->xrun_recovery = 0;
+
 	if (alsa_driver_check_card_type (driver)) {
 		alsa_driver_delete (driver);
 		return NULL;
@@ -2220,8 +2246,8 @@
 	driver->capture_and_playback_not_synced = FALSE;
 
 	if (driver->capture_handle && driver->playback_handle) {
-		if (snd_pcm_link (driver->capture_handle,
-				  driver->playback_handle) != 0) {
+		if (snd_pcm_link (driver->playback_handle,
+				  driver->capture_handle) != 0) {
 			driver->capture_and_playback_not_synced = TRUE;
 		} 
 	}
@@ -2333,7 +2359,7 @@
 	desc = calloc (1, sizeof (jack_driver_desc_t));
 
 	strcpy (desc->name,"alsa");
-	desc->nparams = 17;
+	desc->nparams = 18;
   
 	params = calloc (desc->nparams, sizeof (jack_driver_param_desc_t));
 
@@ -2484,6 +2510,18 @@
 	strcpy (params[i].short_desc, "Extra output latency (frames)");
 	strcpy (params[i].long_desc, params[i].short_desc);
 
+	i++;
+	strcpy (params[i].name, "midi");
+	params[i].character  = 'X';
+	params[i].type       = JackDriverParamString;
+	strcpy (params[i].value.str,  "none");
+	strcpy (params[i].short_desc, "ALSA MIDI driver (seq|raw)");
+	strcpy (params[i].long_desc,
+		"ALSA MIDI driver:\n"
+		" none - no MIDI driver\n"
+		" seq - ALSA Sequencer driver\n"
+		" raw - ALSA RawMIDI driver\n");
+
 	desc->params = params;
 
 	return desc;
@@ -2509,6 +2547,8 @@
 	int shorts_first = FALSE;
 	jack_nframes_t systemic_input_latency = 0;
 	jack_nframes_t systemic_output_latency = 0;
+	char *midi_driver_name = "none";
+	alsa_midi_t *midi = NULL;
 	const JSList * node;
 	const jack_driver_param_t * param;
 
@@ -2597,6 +2637,10 @@
 			systemic_output_latency = param->value.ui;
 			break;
 
+		case 'X':
+			midi_driver_name = strdup (param->value.str);
+			break;
+
 		}
 	}
 			
@@ -2606,6 +2650,12 @@
 		playback = TRUE;
 	}
 
+	if (strcmp(midi_driver_name, "seq")==0) {
+		midi = alsa_seqmidi_new(client, NULL);
+	} else if (strcmp(midi_driver_name, "raw")==0) {
+		midi = alsa_rawmidi_new(client);
+	}
+
 	return alsa_driver_new ("alsa_pcm", playback_pcm_name,
 				capture_pcm_name, client,
 				frames_per_interrupt, 
@@ -2615,7 +2665,7 @@
 				user_capture_nchnls, user_playback_nchnls,
 				shorts_first, 
 				systemic_input_latency,
-				systemic_output_latency);
+				systemic_output_latency, midi);
 }
 
 void
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/alsa_driver.h jack/drivers/alsa/alsa_driver.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/alsa_driver.h	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/alsa_driver.h	2007-08-25 15:30:44.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: alsa_driver.h 945 2006-05-04 15:14:45Z pbd $
 */
 
 #ifndef __jack_alsa_driver_h__
@@ -40,6 +39,8 @@
 #include <jack/memops.h>
 #include <jack/jack.h>
 
+#include "../alsa-midi/alsa_midi.h"
+
 typedef void (*ReadCopyFunction)  (jack_default_audio_sample_t *dst, char *src,
 				   unsigned long src_bytes,
 				   unsigned long src_skip_bytes);
@@ -142,6 +143,9 @@
     int xrun_count;
     int process_count;
 
+    alsa_midi_t *midi;
+    int xrun_recovery;
+
 } alsa_driver_t;
 
 static inline void 
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/generic.h jack/drivers/alsa/generic.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/generic.h	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/generic.h	2007-08-25 15:30:44.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: generic.h 483 2003-08-29 00:06:30Z trutkin $
 */
 
 #ifndef __jack_generic_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/generic_hw.c jack/drivers/alsa/generic_hw.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/generic_hw.c	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/generic_hw.c	2007-08-25 15:30:44.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: generic_hw.c 855 2004-12-28 05:50:18Z joq $
 */
 
 #include <jack/hardware.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/hammerfall.c jack/drivers/alsa/hammerfall.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/hammerfall.c	2006-08-31 11:42:11.000000000 +0700
+++ jack/drivers/alsa/hammerfall.c	2007-08-25 15:30:44.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: hammerfall.c 985 2006-08-29 15:21:17Z paul $
 */
 
 #include <jack/hardware.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/hammerfall.h jack/drivers/alsa/hammerfall.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/hammerfall.h	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/hammerfall.h	2007-08-25 15:30:44.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: hammerfall.h 483 2003-08-29 00:06:30Z trutkin $
 */
 
 #ifndef __jack_hammerfall_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/hdsp.c jack/drivers/alsa/hdsp.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/hdsp.c	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/hdsp.c	2007-08-25 15:30:44.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: hdsp.c 855 2004-12-28 05:50:18Z joq $
 */
 
 #include <jack/hardware.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/hdsp.h jack/drivers/alsa/hdsp.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/hdsp.h	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/hdsp.h	2007-08-25 15:30:44.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: hdsp.h 483 2003-08-29 00:06:30Z trutkin $
 */
 
 #ifndef __jack_hdsp_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/memops.c jack/drivers/alsa/memops.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/memops.c	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/memops.c	2007-08-25 15:30:44.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: memops.c 945 2006-05-04 15:14:45Z pbd $
 */
 
 #define _ISOC9X_SOURCE  1
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/memops.h jack/drivers/alsa/memops.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/memops.h	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/memops.h	2007-08-25 15:30:44.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: memops.h 945 2006-05-04 15:14:45Z pbd $
 */
 
 #ifndef __jack_memops_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/usx2y.c jack/drivers/alsa/usx2y.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/usx2y.c	2007-01-17 07:48:47.000000000 +0700
+++ jack/drivers/alsa/usx2y.c	2007-08-25 15:30:44.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: usx2y.c 999 2006-11-29 20:06:36Z rncbc $
 */
 
 #include <jack/hardware.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa/usx2y.h jack/drivers/alsa/usx2y.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa/usx2y.h	2006-05-26 09:45:25.000000000 +0700
+++ jack/drivers/alsa/usx2y.h	2007-08-25 15:30:44.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: usx2y.h 855 2004-12-28 05:50:18Z joq $
 */
 
 #ifndef __jack_usx2y_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/Makefile.am jack/drivers/alsa-midi/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/Makefile.am	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/alsa-midi/Makefile.am	2007-08-25 15:30:44.000000000 +0700
@@ -0,0 +1,5 @@
+MAINTAINERCLEANFILES=Makefile.in
+
+#
+# nothing to do here
+#
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/alsa_midi.h jack/drivers/alsa-midi/alsa_midi.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/alsa_midi.h	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/alsa-midi/alsa_midi.h	2007-08-25 15:30:44.000000000 +0700
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2006 Dmitry S. Baikov
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __jack_alsa_midi_h__
+#define __jack_alsa_midi_h__
+
+#include <jack/jack.h>
+
+typedef struct alsa_midi_t alsa_midi_t;
+struct alsa_midi_t {
+	void (*destroy)(alsa_midi_t *amidi);
+	int (*attach)(alsa_midi_t *amidi);
+	int (*detach)(alsa_midi_t *amidi);
+	int (*start)(alsa_midi_t *amidi);
+	int (*stop)(alsa_midi_t *amidi);
+	void (*read)(alsa_midi_t *amidi, jack_nframes_t nframes);
+	void (*write)(alsa_midi_t *amidi, jack_nframes_t nframes);
+};
+
+alsa_midi_t* alsa_rawmidi_new(jack_client_t *jack);
+alsa_midi_t* alsa_seqmidi_new(jack_client_t *jack, const char* alsa_name);
+
+#endif /* __jack_alsa_midi_h__ */
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/alsa_rawmidi.c jack/drivers/alsa-midi/alsa_rawmidi.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/alsa_rawmidi.c	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/alsa-midi/alsa_rawmidi.c	2007-08-25 15:30:44.000000000 +0700
@@ -0,0 +1,1198 @@
+/*
+ * ALSA RAWMIDI < - > JACK MIDI bridge
+ *
+ * Copyright (c) 2006,2007 Dmitry S. Baikov
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/* Required for clock_nanosleep(). Thanks, Nedko */
+#define _GNU_SOURCE
+
+#include "alsa_midi.h"
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <pthread.h>
+#include <time.h>
+#include <limits.h>
+#include <ctype.h>
+#include <alsa/asoundlib.h>
+#include <jack/thread.h>
+#include <jack/ringbuffer.h>
+#include <jack/midiport.h>
+#include "midi_pack.h"
+#include "midi_unpack.h"
+
+
+#ifdef STANDALONE
+#define MESSAGE(...) fprintf(stderr, __VA_ARGS__)
+#else
+#include <jack/messagebuffer.h>
+#endif
+
+#define info_log(...)  MESSAGE(__VA_ARGS__)
+#define error_log(...) MESSAGE(__VA_ARGS__)
+
+#ifdef JACK_MIDI_DEBUG
+#define debug_log(...) MESSAGE(__VA_ARGS__)
+#else
+#define debug_log(...)
+#endif
+
+
+enum {
+	NANOSLEEP_RESOLUTION = 7000
+};
+
+#define NFRAMES_INF INT_MAX
+
+enum {
+#ifndef DEBUG
+	MAX_PFDS = 64,
+	MAX_PORTS = MAX_PFDS-1,
+	MAX_EVENTS = 4096,
+	MAX_DATA = 64*1024,
+	MIDI_THREAD_PRIO = 80
+#else
+	MAX_PFDS = 6,
+	MAX_PORTS = MAX_PFDS-1,
+	MAX_EVENTS = 16,
+	MAX_DATA = 64,
+	MIDI_THREAD_PRIO = 80
+#endif
+};
+
+enum PortState {
+	PORT_DESTROYED,
+	PORT_CREATED,
+	PORT_ADDED_TO_JACK,
+	PORT_ADDED_TO_MIDI,
+	PORT_REMOVED_FROM_MIDI,
+	PORT_REMOVED_FROM_JACK,
+	PORT_ZOMBIFIED,
+};
+
+typedef struct {
+	int id[4]; //card, dev, dir, sub;
+} alsa_id_t;
+
+
+typedef struct {
+	jack_time_t time;
+	int size;
+	int overruns;
+} event_head_t;
+
+
+typedef struct midi_port_t midi_port_t;
+struct midi_port_t {
+	midi_port_t *next;
+
+	enum PortState state;
+
+	alsa_id_t id;
+	char dev[16];
+	char name[64];
+
+	jack_port_t *jack;
+	snd_rawmidi_t *rawmidi;
+	int npfds;
+	int is_ready;
+
+	jack_ringbuffer_t *event_ring;
+	jack_ringbuffer_t *data_ring;
+
+};
+
+typedef struct input_port_t {
+	midi_port_t base;
+
+	// jack
+	midi_unpack_t unpack;
+	
+	// midi
+	int overruns;
+} input_port_t;
+
+typedef struct output_port_t {
+	midi_port_t base;
+
+	// jack
+	midi_pack_t packer;
+	
+	// midi
+	event_head_t next_event;
+	int todo;
+} output_port_t;
+
+typedef struct alsa_rawmidi_t alsa_rawmidi_t;
+
+typedef struct {
+	alsa_rawmidi_t *midi;
+	midi_port_t *port;
+	void *buffer;
+	jack_time_t frame_time;
+	jack_nframes_t nframes;
+} process_jack_t;
+
+typedef struct {
+	alsa_rawmidi_t *midi;
+	int mode;
+	midi_port_t *port;
+	struct pollfd *rpfds;
+	struct pollfd *wpfds;
+	int max_pfds;
+	jack_nframes_t cur_frames;
+	jack_time_t cur_time;
+	jack_time_t next_time;
+} process_midi_t;
+
+typedef struct midi_stream_t {
+	alsa_rawmidi_t *owner;
+	int mode;
+	const char *name;
+	pthread_t thread;
+	int wake_pipe[2];
+
+	struct {
+		jack_ringbuffer_t *new_ports;
+		int nports;
+		midi_port_t *ports[MAX_PORTS];
+	} jack, midi;
+
+	size_t port_size;
+	int (*port_init)(alsa_rawmidi_t *midi, midi_port_t *port);
+	void (*port_close)(alsa_rawmidi_t *midi, midi_port_t *port);
+	void (*process_jack)(process_jack_t *j);
+	int (*process_midi)(process_midi_t *m);
+} midi_stream_t;
+
+
+struct alsa_rawmidi_t {
+	alsa_midi_t ops;
+
+	jack_client_t *client;
+	int keep_walking;
+
+	struct {
+		pthread_t thread;
+		midi_port_t *ports;
+		int wake_pipe[2];
+	} scan;
+
+	midi_stream_t in;
+	midi_stream_t out;
+};
+
+static int input_port_init(alsa_rawmidi_t *midi, midi_port_t *port);
+static void input_port_close(alsa_rawmidi_t *midi, midi_port_t *port);
+
+static void do_jack_input(process_jack_t *j);
+static int do_midi_input(process_midi_t *m);
+
+static int output_port_init(alsa_rawmidi_t *midi, midi_port_t *port);
+static void output_port_close(alsa_rawmidi_t *midi, midi_port_t *port);
+
+static void do_jack_output(process_jack_t *j);
+static int do_midi_output(process_midi_t *m);
+
+
+
+static
+int stream_init(midi_stream_t *s, alsa_rawmidi_t *midi, const char *name)
+{
+	s->owner = midi;
+	s->name = name;
+	if (pipe(s->wake_pipe)==-1) {
+		s->wake_pipe[0] = -1;
+		error_log("pipe() in stream_init(%s) failed: %s\n", name, strerror(errno));
+		return -errno;
+	}
+	s->jack.new_ports = jack_ringbuffer_create(sizeof(midi_port_t*)*MAX_PORTS);
+	s->midi.new_ports = jack_ringbuffer_create(sizeof(midi_port_t*)*MAX_PORTS);
+	if (!s->jack.new_ports || !s->midi.new_ports)
+		return -ENOMEM;
+	return 0;
+}
+
+static
+void stream_close(midi_stream_t *s)
+{
+	if (s->wake_pipe[0] != -1) {
+		close(s->wake_pipe[0]);
+		close(s->wake_pipe[1]);
+	}
+	if (s->jack.new_ports)
+		jack_ringbuffer_free(s->jack.new_ports);
+	if (s->midi.new_ports)
+		jack_ringbuffer_free(s->midi.new_ports);
+}
+
+static void alsa_rawmidi_delete(alsa_midi_t *m);
+static int alsa_rawmidi_attach(alsa_midi_t *m);
+static int alsa_rawmidi_detach(alsa_midi_t *m);
+static int alsa_rawmidi_start(alsa_midi_t *m);
+static int alsa_rawmidi_stop(alsa_midi_t *m);
+static void alsa_rawmidi_read(alsa_midi_t *m, jack_nframes_t nframes);
+static void alsa_rawmidi_write(alsa_midi_t *m, jack_nframes_t nframes);
+
+alsa_midi_t* alsa_rawmidi_new(jack_client_t *jack)
+{
+	alsa_rawmidi_t *midi = calloc(1, sizeof(alsa_rawmidi_t));
+	if (!midi)
+		goto fail_0;
+	midi->client = jack;
+	if (pipe(midi->scan.wake_pipe)==-1) {
+		error_log("pipe() in alsa_midi_new failed: %s\n", strerror(errno));
+		goto fail_1;
+	}
+
+	if (stream_init(&midi->in, midi, "in"))
+		goto fail_2;
+	midi->in.mode = POLLIN;
+	midi->in.port_size = sizeof(input_port_t);
+	midi->in.port_init = input_port_init;
+	midi->in.port_close = input_port_close;
+	midi->in.process_jack = do_jack_input;
+	midi->in.process_midi = do_midi_input;
+
+	if (stream_init(&midi->out, midi, "out"))
+		goto fail_3;
+	midi->out.mode = POLLOUT;
+	midi->out.port_size = sizeof(output_port_t);
+	midi->out.port_init = output_port_init;
+	midi->out.port_close = output_port_close;
+	midi->out.process_jack = do_jack_output;
+	midi->out.process_midi = do_midi_output;
+
+	midi->ops.destroy = alsa_rawmidi_delete;
+	midi->ops.attach = alsa_rawmidi_attach;
+	midi->ops.detach = alsa_rawmidi_detach;
+	midi->ops.start = alsa_rawmidi_start;
+	midi->ops.stop = alsa_rawmidi_stop;
+	midi->ops.read = alsa_rawmidi_read;
+	midi->ops.write = alsa_rawmidi_write;
+
+	return &midi->ops;
+ fail_3:
+ 	stream_close(&midi->out);
+ fail_2:
+ 	stream_close(&midi->in);
+ 	close(midi->scan.wake_pipe[1]);
+ 	close(midi->scan.wake_pipe[0]);
+ fail_1:
+ 	free(midi);
+ fail_0:
+	return NULL;
+}
+
+static
+midi_port_t** scan_port_del(alsa_rawmidi_t *midi, midi_port_t **list);
+
+static
+void alsa_rawmidi_delete(alsa_midi_t *m)
+{
+	alsa_rawmidi_t *midi = (alsa_rawmidi_t*)m;
+
+	alsa_rawmidi_detach(m);
+
+	stream_close(&midi->out);
+	stream_close(&midi->in);
+	close(midi->scan.wake_pipe[0]);
+	close(midi->scan.wake_pipe[1]);
+
+	free(midi);
+}
+
+static void* scan_thread(void *);
+static void *midi_thread(void *arg);
+
+static
+int alsa_rawmidi_attach(alsa_midi_t *m)
+{
+	return 0;
+}
+
+static
+int alsa_rawmidi_detach(alsa_midi_t *m)
+{
+	alsa_rawmidi_t *midi = (alsa_rawmidi_t*)m;
+	midi_port_t **list;
+
+	alsa_rawmidi_stop(m);
+
+	list = &midi->scan.ports;
+	while (*list) {
+		(*list)->state = PORT_REMOVED_FROM_JACK;
+		list = scan_port_del(midi, list);
+	}
+	return 0;
+}
+
+static
+int alsa_rawmidi_start(alsa_midi_t *m)
+{
+	alsa_rawmidi_t *midi = (alsa_rawmidi_t*)m;
+	int err;
+	char c = 'q';
+	if (midi->keep_walking == 1)
+		return -EALREADY;
+
+	midi->keep_walking = 1;
+	if ((err = jack_client_create_thread(midi->client, &midi->in.thread, MIDI_THREAD_PRIO, jack_is_realtime(midi->client), midi_thread, &midi->in))) {
+		midi->keep_walking = 0;
+		return err;
+	}
+	if ((err = jack_client_create_thread(midi->client, &midi->out.thread, MIDI_THREAD_PRIO, jack_is_realtime(midi->client), midi_thread, &midi->out))) {
+		midi->keep_walking = 0;
+		write(midi->in.wake_pipe[1], &c, 1);
+		pthread_join(midi->in.thread, NULL);
+		return err;
+	}
+	if ((err = jack_client_create_thread(midi->client, &midi->scan.thread, 0, 0, scan_thread, midi))) {
+		midi->keep_walking = 0;
+		write(midi->in.wake_pipe[1], &c, 1);
+		write(midi->out.wake_pipe[1], &c, 1);
+		pthread_join(midi->in.thread, NULL);
+		pthread_join(midi->out.thread, NULL);
+		return err;
+	}
+	return 0;
+}
+
+static
+int alsa_rawmidi_stop(alsa_midi_t *m)
+{
+	alsa_rawmidi_t *midi = (alsa_rawmidi_t*)m;
+	char c = 'q';
+	if (midi->keep_walking == 0)
+		return -EALREADY;
+	midi->keep_walking = 0;
+	write(midi->in.wake_pipe[1], &c, 1);
+	write(midi->out.wake_pipe[1], &c, 1);
+	write(midi->scan.wake_pipe[1], &c, 1);
+	pthread_join(midi->in.thread, NULL);
+	pthread_join(midi->out.thread, NULL);
+	pthread_join(midi->scan.thread, NULL);
+	// ports are freed in alsa_midi_detach()
+	return 0;
+}
+
+static void jack_process(midi_stream_t *str, jack_nframes_t nframes);
+
+static
+void alsa_rawmidi_read(alsa_midi_t *m, jack_nframes_t nframes)
+{
+	alsa_rawmidi_t *midi = (alsa_rawmidi_t*)m;
+	jack_process(&midi->in, nframes);
+}
+
+static
+void alsa_rawmidi_write(alsa_midi_t *m, jack_nframes_t nframes)
+{
+	alsa_rawmidi_t *midi = (alsa_rawmidi_t*)m;
+	jack_process(&midi->out, nframes);
+}
+
+/*
+ * -----------------------------------------------------------------------------
+ */
+static inline
+int can_pass(size_t sz, jack_ringbuffer_t *in, jack_ringbuffer_t *out)
+{
+	return jack_ringbuffer_read_space(in) >= sz && jack_ringbuffer_write_space(out) >= sz;
+}
+
+static
+void midi_port_init(const alsa_rawmidi_t *midi, midi_port_t *port, snd_rawmidi_info_t *info, const alsa_id_t *id)
+{
+	const char *name;
+	char *c;
+
+	port->id = *id;
+	snprintf(port->dev, sizeof(port->dev), "hw:%d,%d,%d", id->id[0], id->id[1], id->id[3]);
+	name = snd_rawmidi_info_get_subdevice_name(info);
+	if (!strlen(name))
+		name = snd_rawmidi_info_get_name(info);
+	snprintf(port->name, sizeof(port->name), "%s %s %s", port->id.id[2] ? "out":"in", port->dev, name);
+
+	// replace all offending characters with '-'
+	for (c=port->name; *c; ++c)
+	        if (!isalnum(*c))
+			*c = '-';
+
+	port->state = PORT_CREATED;
+}
+
+static
+inline int midi_port_open_jack(const alsa_rawmidi_t *midi, midi_port_t *port, int type, const char *name)
+{
+	port->jack = jack_port_register(midi->client, name, JACK_DEFAULT_MIDI_TYPE,
+		type | JackPortIsPhysical|JackPortIsTerminal, 0);
+	return port->jack == NULL;
+}
+
+static
+int midi_port_open(const alsa_rawmidi_t *midi, midi_port_t *port)
+{
+	int err;
+	int type;
+	char name[64];
+	snd_rawmidi_t **in = NULL;
+	snd_rawmidi_t **out = NULL;
+
+	if (port->id.id[2] == 0) {
+		in = &port->rawmidi;
+		type = JackPortIsOutput;
+	} else {
+		out = &port->rawmidi;
+		type = JackPortIsInput;
+	}
+	
+	if ((err = snd_rawmidi_open(in, out, port->dev, SND_RAWMIDI_NONBLOCK))<0)
+		return err;
+
+	/* Some devices (emu10k1) have subdevs with the same name,
+	 * and we need to generate unique port name for jack */
+	snprintf(name, sizeof(name), "%s", port->name);
+	if (midi_port_open_jack(midi, port, type, name)) {
+		int num;
+		num = port->id.id[3] ? port->id.id[3] : port->id.id[1];
+		snprintf(name, sizeof(name), "%s %d", port->name, num);
+		if (midi_port_open_jack(midi, port, type, name))
+			return 2;
+	}
+	if ((port->event_ring = jack_ringbuffer_create(MAX_EVENTS*sizeof(event_head_t)))==NULL)
+		return 3;
+	if ((port->data_ring = jack_ringbuffer_create(MAX_DATA))==NULL)
+		return 4;
+
+	return 0;
+}
+
+static
+void midi_port_close(const alsa_rawmidi_t *midi, midi_port_t *port)
+{
+	if (port->data_ring)
+		jack_ringbuffer_free(port->data_ring);
+	if (port->event_ring)
+		jack_ringbuffer_free(port->event_ring);
+	if (port->jack)
+		jack_port_unregister(midi->client, port->jack);
+	if (port->rawmidi)
+		snd_rawmidi_close(port->rawmidi);
+	memset(port, 0, sizeof(*port));
+}
+
+/*
+ * ------------------------- Port scanning -------------------------------
+ */
+
+static
+int alsa_id_before(const alsa_id_t *p1, const alsa_id_t *p2)
+{
+	int i;
+	for (i=0; i<4; ++i) {
+		if (p1->id[i] < p2->id[i])
+			return 1;
+		else if (p1->id[i] > p2->id[i])
+			return 0;
+	}
+	return 0;
+}
+
+static
+void alsa_get_id(alsa_id_t *id, snd_rawmidi_info_t *info)
+{
+	id->id[0] = snd_rawmidi_info_get_card(info);
+	id->id[1] = snd_rawmidi_info_get_device(info);
+	id->id[2] = snd_rawmidi_info_get_stream(info) == SND_RAWMIDI_STREAM_OUTPUT ? 1 : 0;
+	id->id[3] = snd_rawmidi_info_get_subdevice(info);
+}
+
+static inline
+void alsa_error(const char *func, int err)
+{
+	error_log("%s() failed\n", snd_strerror(err));
+}
+
+typedef struct {
+	alsa_rawmidi_t *midi;
+	midi_port_t **iterator;
+	snd_ctl_t *ctl;
+	snd_rawmidi_info_t *info;
+} scan_t;
+
+static midi_port_t** scan_port_del(alsa_rawmidi_t *midi, midi_port_t **list);
+
+static
+void scan_cleanup(alsa_rawmidi_t *midi)
+{
+	midi_port_t **list = &midi->scan.ports;
+	while (*list)
+		list = scan_port_del(midi, list);
+}
+
+static void scan_card(scan_t *scan);
+static midi_port_t** scan_port_open(alsa_rawmidi_t *midi, midi_port_t **list);
+
+void scan_cycle(alsa_rawmidi_t *midi)
+{
+	int card = -1, err;
+	scan_t scan;
+	midi_port_t **ports;
+
+	//debug_log("scan: cleanup\n");
+	scan_cleanup(midi);
+
+	scan.midi = midi;
+	scan.iterator = &midi->scan.ports;
+	snd_rawmidi_info_alloca(&scan.info);
+
+	//debug_log("scan: rescan\n");
+	while ((err = snd_card_next(&card))>=0 && card>=0) {
+		char name[32];
+		snprintf(name, sizeof(name), "hw:%d", card);
+		if ((err = snd_ctl_open(&scan.ctl, name, SND_CTL_NONBLOCK))>=0) {
+			scan_card(&scan);
+			snd_ctl_close(scan.ctl);
+		} else
+			alsa_error("scan: snd_ctl_open", err);
+	}
+
+	// delayed open to workaround alsa<1.0.14 bug (can't open more than 1 subdevice if ctl is opened).
+	ports = &midi->scan.ports;
+	while (*ports) {
+		midi_port_t *port = *ports;
+		if (port->state == PORT_CREATED)
+			ports = scan_port_open(midi, ports);
+		else
+			ports = &port->next;
+	}
+}
+
+static void scan_device(scan_t *scan);
+
+static
+void scan_card(scan_t *scan)
+{
+	int device = -1;
+	int err;
+
+	while ((err = snd_ctl_rawmidi_next_device(scan->ctl, &device))>=0 && device >=0) {
+		snd_rawmidi_info_set_device(scan->info, device);
+
+		snd_rawmidi_info_set_stream(scan->info, SND_RAWMIDI_STREAM_INPUT);
+		snd_rawmidi_info_set_subdevice(scan->info, 0);
+		if ((err = snd_ctl_rawmidi_info(scan->ctl, scan->info))>=0)
+			scan_device(scan);
+		else if (err != -ENOENT)
+			alsa_error("scan: snd_ctl_rawmidi_info on device", err);
+
+		snd_rawmidi_info_set_stream(scan->info, SND_RAWMIDI_STREAM_OUTPUT);
+		snd_rawmidi_info_set_subdevice(scan->info, 0);
+		if ((err = snd_ctl_rawmidi_info(scan->ctl, scan->info))>=0)
+			scan_device(scan);
+		else if (err != -ENOENT)
+			alsa_error("scan: snd_ctl_rawmidi_info on device", err);
+	}
+}
+
+static void scan_port_update(scan_t *scan);
+
+static
+void scan_device(scan_t *scan)
+{
+	int err;
+	int sub, nsubs = 0;
+	nsubs = snd_rawmidi_info_get_subdevices_count(scan->info);
+
+	for (sub=0; sub<nsubs; ++sub) {
+		snd_rawmidi_info_set_subdevice(scan->info, sub);
+		if ((err = snd_ctl_rawmidi_info(scan->ctl, scan->info)) < 0) {
+			alsa_error("scan: snd_ctl_rawmidi_info on subdevice", err);
+			continue;
+		}
+		scan_port_update(scan);
+	}
+}
+
+static midi_port_t** scan_port_add(scan_t *scan, const alsa_id_t *id, midi_port_t **list);
+
+static
+void scan_port_update(scan_t *scan)
+{
+	midi_port_t **list = scan->iterator;
+	alsa_id_t id;
+	alsa_get_id(&id, scan->info);
+
+	while (*list && alsa_id_before(&(*list)->id, &id))
+		list = scan_port_del(scan->midi, list);
+
+	if (!*list || alsa_id_before(&id, &(*list)->id))
+		list = scan_port_add(scan, &id, list);
+	else if (*list)
+		list = &(*list)->next;
+
+	scan->iterator = list;
+}
+
+static
+midi_port_t** scan_port_add(scan_t *scan, const alsa_id_t *id, midi_port_t **list)
+{
+	midi_port_t *port;
+	midi_stream_t *str = id->id[2] ? &scan->midi->out : &scan->midi->in;
+
+	port = calloc(1, str->port_size);
+	if (!port)
+		return list;
+	midi_port_init(scan->midi, port, scan->info, id);
+
+	port->next = *list;
+	*list = port;
+	error_log("scan: added port %s %s\n", port->dev, port->name);
+	return &port->next;
+}
+
+static
+midi_port_t** scan_port_open(alsa_rawmidi_t *midi, midi_port_t **list)
+{
+	midi_stream_t *str;
+	midi_port_t *port;
+
+	port = *list;
+	str = port->id.id[2] ? &midi->out : &midi->in;
+
+	if (jack_ringbuffer_write_space(str->jack.new_ports) < sizeof(port))
+		goto fail_0;
+
+	if (midi_port_open(midi, port))
+		goto fail_1;
+	if ((str->port_init)(midi, port))
+		goto fail_2;
+
+	port->state = PORT_ADDED_TO_JACK;
+	jack_ringbuffer_write(str->jack.new_ports, (char*) &port, sizeof(port));
+
+	error_log("scan: opened port %s %s\n", port->dev, port->name);
+	return &port->next;
+
+ fail_2:
+ 	(str->port_close)(midi, port);
+ fail_1:
+	midi_port_close(midi, port);
+ fail_0:
+ 	*list = port->next;
+	error_log("scan: can't open port %s %s\n", port->dev, port->name);
+ 	free(port);
+	return list;
+}
+
+static
+midi_port_t** scan_port_del(alsa_rawmidi_t *midi, midi_port_t **list)
+{
+	midi_port_t *port = *list;
+	if (port->state == PORT_REMOVED_FROM_JACK) {
+		error_log("scan: deleted port %s %s\n", port->dev, port->name);
+		*list = port->next;
+		if (port->id.id[2] )
+			(midi->out.port_close)(midi, port);
+		else
+			(midi->in.port_close)(midi, port);
+		midi_port_close(midi, port);
+		free(port);
+		return list;
+	} else {
+		//debug_log("can't delete port %s, wrong state: %d\n", port->name, (int)port->state);
+		return &port->next;
+	}
+}
+
+void* scan_thread(void *arg)
+{
+	alsa_rawmidi_t *midi = arg;
+	struct pollfd wakeup;
+
+	wakeup.fd = midi->scan.wake_pipe[0];
+	wakeup.events = POLLIN|POLLERR|POLLNVAL;
+	while (midi->keep_walking) {
+		int res;
+		//error_log("scanning....\n");
+		scan_cycle(midi);
+		res = poll(&wakeup, 1, 2000);
+		if (res>0) {
+			char c;
+			read(wakeup.fd, &c, 1);
+		} else if (res<0 && errno != EINTR)
+			break;
+	}
+	return NULL;
+}
+
+
+/* 
+ * ------------------------------- Input/Output  ------------------------------
+ */
+
+static
+void jack_add_ports(midi_stream_t *str)
+{
+	midi_port_t *port;
+	while (can_pass(sizeof(port), str->jack.new_ports, str->midi.new_ports) && str->jack.nports < MAX_PORTS) {
+		jack_ringbuffer_read(str->jack.new_ports, (char*)&port, sizeof(port));
+		str->jack.ports[str->jack.nports++] = port;
+		port->state = PORT_ADDED_TO_MIDI;
+		jack_ringbuffer_write(str->midi.new_ports, (char*)&port, sizeof(port));
+	}
+}
+
+static
+void jack_process(midi_stream_t *str, jack_nframes_t nframes)
+{
+	int r, w;
+	process_jack_t proc;
+	jack_nframes_t cur_frames;
+
+	if (!str->owner->keep_walking)
+		return;
+
+	proc.midi = str->owner;
+	proc.nframes = nframes;
+	proc.frame_time = jack_last_frame_time(proc.midi->client);
+	cur_frames = jack_frame_time(proc.midi->client);
+	if (proc.frame_time + proc.nframes < cur_frames) {
+		int periods_lost = (cur_frames - proc.frame_time) / proc.nframes;
+		proc.frame_time += periods_lost * proc.nframes;
+		debug_log("xrun detected: %d periods lost\n", periods_lost);
+	}
+
+	// process existing ports
+	for (r=0, w=0; r<str->jack.nports; ++r) {
+		midi_port_t *port = str->jack.ports[r];
+		proc.port = port;
+
+		assert (port->state > PORT_ADDED_TO_JACK && port->state < PORT_REMOVED_FROM_JACK);
+
+		proc.buffer = jack_port_get_buffer(port->jack, nframes);
+		if (str->mode == POLLIN)
+			jack_midi_clear_buffer(proc.buffer);
+
+		if (port->state == PORT_REMOVED_FROM_MIDI) {
+			port->state = PORT_REMOVED_FROM_JACK; // this signals to scan thread
+			continue; // this effectively removes port from the midi->in.jack.ports[]
+		}
+
+		(str->process_jack)(&proc);
+
+		if (r != w)
+			str->jack.ports[w] = port;
+		++w;
+	}
+	if (str->jack.nports != w)
+		debug_log("jack_%s: nports %d -> %d\n", str->name, str->jack.nports, w);
+	str->jack.nports = w;
+
+	jack_add_ports(str); // it makes no sense to add them earlier since they have no data yet
+
+	// wake midi thread
+	write(str->wake_pipe[1], &r, 1);
+}
+
+static
+void *midi_thread(void *arg)
+{
+	midi_stream_t *str = arg;
+	alsa_rawmidi_t *midi = str->owner;
+	struct pollfd pfds[MAX_PFDS];
+	int npfds;
+	jack_time_t wait_nsec = 1000*1000*1000; // 1 sec
+	process_midi_t proc;
+
+	proc.midi = midi;
+	proc.mode = str->mode;
+
+	pfds[0].fd = str->wake_pipe[0];
+	pfds[0].events = POLLIN|POLLERR|POLLNVAL;
+	npfds = 1;
+
+	//debug_log("midi_thread(%s): enter\n", str->name);
+
+	while (midi->keep_walking) {
+		int poll_timeout;
+		int wait_nanosleep;
+		int r=1, w=1; // read,write pos in pfds
+		int rp=0, wp=0; // read, write pos in ports
+
+		// sleep
+		//if (wait_nsec != 1000*1000*1000) {
+		//	debug_log("midi_thread(%s): ", str->name);
+		//	assert (wait_nsec == 1000*1000*1000);
+		//}
+		poll_timeout = wait_nsec / (1000*1000);
+		wait_nanosleep = wait_nsec % (1000*1000);
+		if (wait_nanosleep > NANOSLEEP_RESOLUTION) {
+			struct timespec ts;
+			ts.tv_sec = 0;
+			ts.tv_nsec = wait_nanosleep;
+			clock_nanosleep(CLOCK_MONOTONIC, 0, &ts, NULL);
+		}
+		int res = poll((struct pollfd*)&pfds, npfds, poll_timeout);
+		//debug_log("midi_thread(%s): poll exit: %d\n", str->name, res);
+		if (!midi->keep_walking)
+			break;
+		if (res < 0) {
+			if (errno == EINTR)
+				continue;
+			error_log("midi_thread(%s) poll failed: %s\n", str->name, strerror(errno));
+			break;
+		}
+
+		// check wakeup pipe
+		if (pfds[0].revents & ~POLLIN)
+			break;
+		if (pfds[0].revents & POLLIN) {
+			char c;
+			read(pfds[0].fd, &c, 1);
+		}
+
+		// add new ports
+		while (jack_ringbuffer_read_space(str->midi.new_ports) >= sizeof(midi_port_t*) && str->midi.nports < MAX_PORTS) {
+			midi_port_t *port;
+			jack_ringbuffer_read(str->midi.new_ports, (char*)&port, sizeof(port));
+			str->midi.ports[str->midi.nports++] = port;
+			debug_log("midi_thread(%s): added port %s\n", str->name, port->name);
+		}
+
+//		if (res == 0)
+//			continue;
+
+		// process ports
+		proc.cur_time = 0; //jack_frame_time(midi->client);
+		proc.next_time = NFRAMES_INF;
+
+		for (rp = 0; rp < str->midi.nports; ++rp) {
+			midi_port_t *port = str->midi.ports[rp];
+			proc.cur_time = jack_frame_time(midi->client);
+			proc.port = port;
+			proc.rpfds = &pfds[r];
+			proc.wpfds = &pfds[w];
+			proc.max_pfds = MAX_PFDS - w;
+			r += port->npfds;
+			if (!(str->process_midi)(&proc)) {
+				port->state = PORT_REMOVED_FROM_MIDI; // this signals to jack thread
+				continue; // this effectively removes port from array
+			}
+			w += port->npfds;
+			if (rp != wp)
+				str->midi.ports[wp] = port;
+			++wp;
+		}
+		if (str->midi.nports != wp)
+			debug_log("midi_%s: nports %d -> %d\n", str->name, str->midi.nports, wp);
+		str->midi.nports = wp;
+		if (npfds != w)
+			debug_log("midi_%s: npfds %d -> %d\n", str->name, npfds, w);
+		npfds = w;
+
+		/*
+		 * Input : ports do not set proc.next_time.
+		 * Output: port sets proc.next_time ONLY if it does not have queued data.
+		 * So, zero timeout will not cause busy-looping.
+		 */
+		if (proc.next_time < proc.cur_time) {
+			debug_log("%s: late: next_time = %d, cur_time = %d\n", str->name, (int)proc.next_time, (int)proc.cur_time);
+			wait_nsec = 0; // we are late
+		} else if (proc.next_time != NFRAMES_INF) {
+			jack_time_t wait_frames = proc.next_time - proc.cur_time;
+			jack_nframes_t rate = jack_get_sample_rate(midi->client);
+			wait_nsec = (wait_frames * (1000*1000*1000)) / rate;
+			debug_log("midi_%s: timeout = %d\n", str->name, (int)wait_frames);
+		} else
+			wait_nsec = 1000*1000*1000;
+		//debug_log("midi_thread(%s): wait_nsec = %lld\n", str->name, wait_nsec);
+	}
+	return NULL;
+}
+
+static
+int midi_is_ready(process_midi_t *proc)
+{
+	midi_port_t *port = proc->port;
+	if (port->npfds) {
+		unsigned short revents = 0;
+		int res = snd_rawmidi_poll_descriptors_revents(port->rawmidi, proc->rpfds, port->npfds, &revents);
+		if (res) {
+			error_log("snd_rawmidi_poll_descriptors_revents failed on port %s with: %s\n", port->name, snd_strerror(res));
+			return 0;
+		}
+
+		if (revents & ~proc->mode) {
+			debug_log("midi: port %s failed\n", port->name);
+			return 0;
+		}
+		if (revents & proc->mode) {
+			port->is_ready = 1;
+			debug_log("midi: is_ready %s\n", port->name);
+		}
+	}
+	return 1;
+}
+
+static
+int midi_update_pfds(process_midi_t *proc)
+{
+	midi_port_t *port = proc->port;
+	if (port->npfds == 0) {
+		port->npfds = snd_rawmidi_poll_descriptors_count(port->rawmidi);
+		if (port->npfds > proc->max_pfds) {
+			debug_log("midi: not enough pfds for port %s\n", port->name);
+			return 0;
+		}
+		snd_rawmidi_poll_descriptors(port->rawmidi, proc->wpfds, port->npfds);
+	} else if (proc->rpfds != proc->wpfds) {
+		memmove(proc->wpfds, proc->rpfds, sizeof(struct pollfd) * port->npfds);
+	}
+	return 1;
+}
+
+/* 
+ * ------------------------------------ Input ------------------------------
+ */
+
+static
+int input_port_init(alsa_rawmidi_t *midi, midi_port_t *port)
+{
+	input_port_t *in = (input_port_t*)port;
+	midi_unpack_init(&in->unpack);
+	return 0;
+}
+
+static
+void input_port_close(alsa_rawmidi_t *midi, midi_port_t *port)
+{
+}
+
+/*
+ * Jack-level input.
+ */
+
+static
+void do_jack_input(process_jack_t *p)
+{
+	input_port_t *port = (input_port_t*) p->port;
+	event_head_t event;
+	while (jack_ringbuffer_read_space(port->base.event_ring) >= sizeof(event)) {
+		jack_ringbuffer_data_t vec[2];
+		jack_nframes_t time;
+		int i, todo;
+
+		jack_ringbuffer_read(port->base.event_ring, (char*)&event, sizeof(event));
+		// TODO: take into account possible warping
+		if ((event.time + p->nframes) < p->frame_time)
+			time = 0;
+		else if (event.time >= p->frame_time)
+			time = p->nframes -1;
+		else
+			time = event.time + p->nframes - p->frame_time;
+
+		jack_ringbuffer_get_read_vector(port->base.data_ring, vec);
+		assert ((vec[0].len + vec[1].len) >= event.size);
+
+		if (event.overruns)
+			midi_unpack_reset(&port->unpack);
+
+		todo = event.size;
+		for (i=0; i<2 && todo>0; ++i) {
+			int avail = todo < vec[i].len ? todo : vec[i].len;
+			int done = midi_unpack_buf(&port->unpack, (unsigned char*)vec[i].buf, avail, p->buffer, time);
+			if (done != avail) {
+				debug_log("jack_in: buffer overflow in port %s\n", port->base.name);
+				break;
+			}
+			todo -= done;
+		}
+		jack_ringbuffer_read_advance(port->base.data_ring, event.size);
+	}
+}
+
+/*
+ * Low level input.
+ */
+static
+int do_midi_input(process_midi_t *proc)
+{
+	input_port_t *port = (input_port_t*) proc->port;
+	if (!midi_is_ready(proc))
+		return 0;
+
+	if (port->base.is_ready) {
+		jack_ringbuffer_data_t vec[2];
+		int res;
+
+		jack_ringbuffer_get_write_vector(port->base.data_ring, vec);
+		if (jack_ringbuffer_write_space(port->base.event_ring) < sizeof(event_head_t) || vec[0].len < 1) {
+			port->overruns++;
+			if (port->base.npfds)
+				debug_log("midi_in: internal overflow on %s\n", port->base.name);
+			// remove from poll to prevent busy-looping
+			port->base.npfds = 0;
+			return 1;
+		}
+		res = snd_rawmidi_read(port->base.rawmidi, vec[0].buf, vec[0].len);
+		if (res < 0 && res != -EWOULDBLOCK) {
+			error_log("midi_in: reading from port %s failed: %s\n", port->base.name, snd_strerror(res));
+			return 0;
+		} else if (res > 0) {
+			event_head_t event;
+			event.time = proc->cur_time;
+			event.size = res;
+			event.overruns = port->overruns;
+			port->overruns = 0;
+			debug_log("midi_in: read %d bytes at %d\n", (int)event.size, (int)event.time);
+			jack_ringbuffer_write_advance(port->base.data_ring, event.size);
+			jack_ringbuffer_write(port->base.event_ring, (char*)&event, sizeof(event));
+		}
+		port->base.is_ready = 0;
+	}
+
+	if (!midi_update_pfds(proc))
+		return 0;
+
+	return 1;
+}
+
+/* 
+ * ------------------------------------ Output ------------------------------
+ */
+
+static int output_port_init(alsa_rawmidi_t *midi, midi_port_t *port)
+{
+	output_port_t *out = (output_port_t*)port;
+	midi_pack_reset(&out->packer);
+	out->next_event.time = 0;
+	out->next_event.size = 0;
+	out->todo = 0;
+	return 0;
+}
+
+static void output_port_close(alsa_rawmidi_t *midi, midi_port_t *port)
+{
+}
+
+static
+void do_jack_output(process_jack_t *proc)
+{
+	output_port_t *port = (output_port_t*) proc->port;
+	int nevents = jack_midi_get_event_count(proc->buffer);
+	int i;
+	if (nevents)
+		debug_log("jack_out: %d events in %s\n", nevents, port->base.name);
+	for (i=0; i<nevents; ++i) {
+		jack_midi_event_t event;
+		event_head_t hdr;
+
+		jack_midi_event_get(&event, proc->buffer, i);
+
+		if (jack_ringbuffer_write_space(port->base.data_ring) < event.size || jack_ringbuffer_write_space(port->base.event_ring) < sizeof(hdr)) {
+			debug_log("jack_out: output buffer overflow on %s\n", port->base.name);
+			break;
+		}
+
+		midi_pack_event(&port->packer, &event);
+
+		jack_ringbuffer_write(port->base.data_ring, (char*)event.buffer, event.size);
+
+		hdr.time = proc->frame_time + event.time + proc->nframes;
+		hdr.size = event.size;
+		jack_ringbuffer_write(port->base.event_ring, (char*)&hdr, sizeof(hdr));
+		debug_log("jack_out: sent %d-byte event at %ld\n", (int)event.size, (long)event.time);
+	}
+}
+
+static
+int do_midi_output(process_midi_t *proc)
+{
+	int worked = 0;
+	output_port_t *port = (output_port_t*) proc->port;
+
+	if (!midi_is_ready(proc))
+		return 0;
+
+	// eat events
+	while (port->next_event.time <= proc->cur_time) {
+		port->todo += port->next_event.size;
+		if (jack_ringbuffer_read(port->base.event_ring, (char*)&port->next_event, sizeof(port->next_event))!=sizeof(port->next_event)) {
+			port->next_event.time = 0;
+			port->next_event.size = 0;
+			break;
+		} else
+			debug_log("midi_out: at %ld got %d bytes for %ld\n", (long)proc->cur_time, (int)port->next_event.size, (long)port->next_event.time);
+	}
+	
+	if (port->todo)
+		debug_log("midi_out: todo = %d at %ld\n", (int)port->todo, (long)proc->cur_time);
+
+	// calc next wakeup time
+	if (!port->todo && port->next_event.time && port->next_event.time < proc->next_time) {
+		proc->next_time = port->next_event.time;
+		debug_log("midi_out: next_time = %ld\n", (long)proc->next_time);
+	}
+
+	if (port->todo && port->base.is_ready) {
+		// write data
+		int size = port->todo;
+		int res;
+		jack_ringbuffer_data_t vec[2];
+
+		jack_ringbuffer_get_read_vector(port->base.data_ring, vec);
+		if (size > vec[0].len) {
+			size = vec[0].len;
+			assert (size > 0);
+		}
+		res = snd_rawmidi_write(port->base.rawmidi, vec[0].buf, size);
+		if (res > 0) {
+			jack_ringbuffer_read_advance(port->base.data_ring, res);
+			debug_log("midi_out: written %d bytes to %s\n", res, port->base.name);
+			port->todo -= res;
+			worked = 1;
+		} else if (res == -EWOULDBLOCK) {
+			port->base.is_ready = 0;
+			debug_log("midi_out: -EWOULDBLOCK on %s\n", port->base.name);
+			return 1;
+		} else {
+			error_log("midi_out: writing to port %s failed: %s\n", port->base.name, snd_strerror(res));
+			return 0;
+		}
+		snd_rawmidi_drain(port->base.rawmidi);
+	}
+
+	// update pfds for this port
+	if (!midi_update_pfds(proc))
+		return 0;
+
+	if (!port->todo) {
+		int i;
+		if (worked)
+			debug_log("midi_out: relaxing on %s\n", port->base.name);
+		for (i=0; i<port->base.npfds; ++i)
+			proc->wpfds[i].events &= ~POLLOUT;
+	} else {
+		int i;
+		for (i=0; i<port->base.npfds; ++i)
+			proc->wpfds[i].events |= POLLOUT;
+	}
+	return 1;
+}
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/alsa_seqmidi.c jack/drivers/alsa-midi/alsa_seqmidi.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/alsa_seqmidi.c	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/alsa-midi/alsa_seqmidi.c	2007-08-25 15:30:44.000000000 +0700
@@ -0,0 +1,886 @@
+/*
+ * ALSA SEQ < - > JACK MIDI bridge
+ *
+ * Copyright (c) 2006,2007 Dmitry S. Baikov <c0ff@konstruktiv.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+/*
+ * alsa_seqmidi_read:
+ *	add new ports
+ * 	reads queued snd_seq_event's
+ * 	if PORT_EXIT: mark port as dead
+ * 	if PORT_ADD, PORT_CHANGE: send addr to port_thread (it also may mark port as dead)
+ * 	else process input event
+ * 	remove dead ports and send them to port_thread
+ *
+ * alsa_seqmidi_write:
+ * 	remove dead ports and send them to port_thread
+ * 	add new ports
+ * 	queue output events
+ *
+ * port_thread:
+ * 	wait for port_sem
+ * 	free deleted ports
+ * 	create new ports or mark existing as dead
+ */
+#include <alsa/asoundlib.h>
+#include <jack/jack.h>
+#include <jack/midiport.h>
+#include <jack/ringbuffer.h>
+#include <jack/thread.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <signal.h>
+#include <semaphore.h>
+#include <time.h>
+#include <ctype.h>
+
+#include "alsa_midi.h"
+
+#ifdef STANDALONE
+#define MESSAGE(...) fprintf(stderr, __VA_ARGS__)
+#else
+#include <jack/messagebuffer.h>
+#endif
+
+#define info_log(...)  MESSAGE(__VA_ARGS__)
+#define error_log(...) MESSAGE(__VA_ARGS__)
+
+#ifdef JACK_MIDI_DEBUG
+#define debug_log(...) MESSAGE(__VA_ARGS__)
+#else
+#define debug_log(...)
+#endif
+
+#define NSEC_PER_SEC ((int64_t)1000*1000*1000)
+
+enum {
+	MAX_PORTS = 64,
+	MAX_EVENT_SIZE = 1024,
+};
+
+typedef struct port_t port_t;
+
+enum {
+	PORT_HASH_BITS = 4,
+	PORT_HASH_SIZE = 1 << PORT_HASH_BITS
+};
+
+typedef port_t* port_hash_t[PORT_HASH_SIZE];
+
+struct port_t {
+	port_t *next;
+	int is_dead;
+	char name[64];
+	snd_seq_addr_t remote;
+	jack_port_t *jack_port;
+
+	jack_ringbuffer_t *early_events; // alsa_midi_event_t + data
+	int64_t last_out_time;
+
+	void *jack_buf;
+};
+
+typedef struct {
+	snd_midi_event_t *codec;
+
+	jack_ringbuffer_t *new_ports;
+
+	port_t *ports[MAX_PORTS];
+} stream_t;
+
+typedef struct alsa_seqmidi {
+	alsa_midi_t ops;
+	jack_client_t *jack;
+
+	snd_seq_t *seq;
+	int client_id;
+	int port_id;
+	int queue;
+
+	int keep_walking;
+
+	pthread_t port_thread;
+	sem_t port_sem;
+	jack_ringbuffer_t *port_add; // snd_seq_addr_t
+	jack_ringbuffer_t *port_del; // port_t*
+
+	stream_t stream[2];
+
+	char alsa_name[32];
+} alsa_seqmidi_t;
+
+struct alsa_midi_event {
+	int64_t time;
+	int size;
+};
+typedef struct alsa_midi_event alsa_midi_event_t;
+
+struct process_info {
+	int dir;
+	jack_nframes_t nframes;
+	jack_nframes_t period_start;
+	jack_nframes_t sample_rate;
+	jack_nframes_t cur_frames;
+	int64_t alsa_time;
+};
+
+
+enum PortType { PORT_INPUT = 0, PORT_OUTPUT = 1 };
+
+typedef void (*port_jack_func)(alsa_seqmidi_t *self, port_t *port,struct process_info* info);
+static void do_jack_input(alsa_seqmidi_t *self, port_t *port, struct process_info* info);
+static void do_jack_output(alsa_seqmidi_t *self, port_t *port, struct process_info* info);
+
+typedef struct {
+	int alsa_mask;
+	int jack_caps;
+	char name[4];
+	port_jack_func jack_func;
+} port_type_t;
+
+static port_type_t port_type[2] = {
+	{
+		SND_SEQ_PORT_CAP_SUBS_READ,
+		JackPortIsOutput|JackPortIsPhysical|JackPortIsTerminal,
+		"in",
+		do_jack_input
+	},
+	{
+		SND_SEQ_PORT_CAP_SUBS_WRITE,
+		JackPortIsInput|JackPortIsPhysical|JackPortIsTerminal,
+		"out",
+		do_jack_output
+	}
+};
+
+
+static void alsa_seqmidi_delete(alsa_midi_t *m);
+static int alsa_seqmidi_attach(alsa_midi_t *m);
+static int alsa_seqmidi_detach(alsa_midi_t *m);
+static int alsa_seqmidi_start(alsa_midi_t *m);
+static int alsa_seqmidi_stop(alsa_midi_t *m);
+static void alsa_seqmidi_read(alsa_midi_t *m, jack_nframes_t nframes);
+static void alsa_seqmidi_write(alsa_midi_t *m, jack_nframes_t nframes);
+
+static
+void stream_init(alsa_seqmidi_t *self, int dir)
+{
+	stream_t *str = &self->stream[dir];
+
+	str->new_ports = jack_ringbuffer_create(MAX_PORTS*sizeof(port_t*));
+	snd_midi_event_new(MAX_EVENT_SIZE, &str->codec);
+}
+
+static void port_free(alsa_seqmidi_t *self, port_t *port);
+static void free_ports(alsa_seqmidi_t *self, jack_ringbuffer_t *ports);
+
+static
+void stream_attach(alsa_seqmidi_t *self, int dir)
+{
+}
+
+static
+void stream_detach(alsa_seqmidi_t *self, int dir)
+{
+	stream_t *str = &self->stream[dir];
+	int i;
+
+	free_ports(self, str->new_ports);
+
+	// delete all ports from hash
+	for (i=0; i<PORT_HASH_SIZE; ++i) {
+		port_t *port = str->ports[i];
+		while (port) {
+			port_t *next = port->next;
+			port_free(self, port);
+			port = next;
+		}
+		str->ports[i] = NULL;
+	}
+}
+
+static
+void stream_close(alsa_seqmidi_t *self, int dir)
+{
+	stream_t *str = &self->stream[dir];
+
+	if (str->codec)
+		snd_midi_event_free(str->codec);
+	if (str->new_ports)
+		jack_ringbuffer_free(str->new_ports);
+}
+
+alsa_midi_t* alsa_seqmidi_new(jack_client_t *client, const char* alsa_name)
+{
+	alsa_seqmidi_t *self = calloc(1, sizeof(alsa_seqmidi_t));
+	debug_log("midi: new\n");
+	if (!self)
+		return NULL;
+	self->jack = client;
+	if (!alsa_name)
+		alsa_name = "jack_midi";
+	snprintf(self->alsa_name, sizeof(self->alsa_name), "%s", alsa_name);
+
+	self->port_add = jack_ringbuffer_create(2*MAX_PORTS*sizeof(snd_seq_addr_t));
+	self->port_del = jack_ringbuffer_create(2*MAX_PORTS*sizeof(port_t*));
+	sem_init(&self->port_sem, 0, 0);
+
+	stream_init(self, PORT_INPUT);
+	stream_init(self, PORT_OUTPUT);
+
+	self->ops.destroy = alsa_seqmidi_delete;
+	self->ops.attach = alsa_seqmidi_attach;
+	self->ops.detach = alsa_seqmidi_detach;
+	self->ops.start = alsa_seqmidi_start;
+	self->ops.stop = alsa_seqmidi_stop;
+	self->ops.read = alsa_seqmidi_read;
+	self->ops.write = alsa_seqmidi_write;
+	return &self->ops;
+}
+
+static
+void alsa_seqmidi_delete(alsa_midi_t *m)
+{
+	alsa_seqmidi_t *self = (alsa_seqmidi_t*) m;
+
+	debug_log("midi: delete\n");
+	alsa_seqmidi_detach(m);
+
+	stream_close(self, PORT_OUTPUT);
+	stream_close(self, PORT_INPUT);
+
+	jack_ringbuffer_free(self->port_add);
+	jack_ringbuffer_free(self->port_del);
+	sem_close(&self->port_sem);
+
+	free(self);
+}
+
+static
+int alsa_seqmidi_attach(alsa_midi_t *m)
+{
+	alsa_seqmidi_t *self = (alsa_seqmidi_t*) m;
+	int err;
+
+	debug_log("midi: attach\n");
+
+	if (self->seq)
+		return -EALREADY;
+
+	if ((err = snd_seq_open(&self->seq, "hw", SND_SEQ_OPEN_DUPLEX, 0)) < 0) {
+		error_log("failed to open alsa seq");
+		return err;
+	}
+	snd_seq_set_client_name(self->seq, self->alsa_name);
+	self->port_id = snd_seq_create_simple_port(self->seq, "port",
+		SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_WRITE
+#ifndef DEBUG
+		|SND_SEQ_PORT_CAP_NO_EXPORT
+#endif
+		,SND_SEQ_PORT_TYPE_APPLICATION);
+	self->client_id = snd_seq_client_id(self->seq);
+
+  	self->queue = snd_seq_alloc_queue(self->seq);
+  	snd_seq_start_queue(self->seq, self->queue, 0); 
+
+	stream_attach(self, PORT_INPUT);
+	stream_attach(self, PORT_OUTPUT);
+
+	snd_seq_nonblock(self->seq, 1);
+
+	return 0;
+}
+
+static
+int alsa_seqmidi_detach(alsa_midi_t *m)
+{
+	alsa_seqmidi_t *self = (alsa_seqmidi_t*) m;
+
+	debug_log("midi: detach\n");
+
+	if (!self->seq)
+		return -EALREADY;
+
+	alsa_seqmidi_stop(m);
+
+	jack_ringbuffer_reset(self->port_add);
+	free_ports(self, self->port_del);
+
+	stream_detach(self, PORT_INPUT);
+	stream_detach(self, PORT_OUTPUT);
+
+	snd_seq_close(self->seq);
+	self->seq = NULL;
+
+	return 0;
+}
+
+static void* port_thread(void *);
+
+static void add_existing_ports(alsa_seqmidi_t *self);
+static void update_ports(alsa_seqmidi_t *self);
+static void add_ports(stream_t *str);
+
+static
+int alsa_seqmidi_start(alsa_midi_t *m)
+{
+	alsa_seqmidi_t *self = (alsa_seqmidi_t*) m;
+	int err;
+
+	debug_log("midi: start\n");
+
+	if (!self->seq)
+		return -EBADF;
+
+	if (self->keep_walking)
+		return -EALREADY;
+
+	snd_seq_connect_from(self->seq, self->port_id, SND_SEQ_CLIENT_SYSTEM, SND_SEQ_PORT_SYSTEM_ANNOUNCE);
+	snd_seq_drop_input(self->seq);
+
+	add_existing_ports(self);
+	update_ports(self);
+	add_ports(&self->stream[PORT_INPUT]);
+	add_ports(&self->stream[PORT_OUTPUT]);
+
+	self->keep_walking = 1;
+
+	if ((err = pthread_create(&self->port_thread, NULL, port_thread, self))) {
+		self->keep_walking = 0;
+		return -errno;
+	}
+
+	return 0;
+}
+
+static
+int alsa_seqmidi_stop(alsa_midi_t *m)
+{
+	alsa_seqmidi_t *self = (alsa_seqmidi_t*) m;
+
+	debug_log("midi: stop\n");
+
+	if (!self->keep_walking)
+		return -EALREADY;
+
+	snd_seq_disconnect_from(self->seq, self->port_id, SND_SEQ_CLIENT_SYSTEM, SND_SEQ_PORT_SYSTEM_ANNOUNCE);
+
+	self->keep_walking = 0;
+
+	sem_post(&self->port_sem);
+	pthread_join(self->port_thread, NULL);
+	self->port_thread = 0;
+
+	return 0;
+}
+
+static
+int alsa_connect_from(alsa_seqmidi_t *self, int client, int port)
+{
+	snd_seq_port_subscribe_t* sub;
+	snd_seq_addr_t seq_addr;
+	int err;
+
+	snd_seq_port_subscribe_alloca(&sub);
+	seq_addr.client = client;
+	seq_addr.port = port;
+	snd_seq_port_subscribe_set_sender(sub, &seq_addr);
+	seq_addr.client = self->client_id;
+	seq_addr.port = self->port_id;
+	snd_seq_port_subscribe_set_dest(sub, &seq_addr);
+
+	snd_seq_port_subscribe_set_time_update(sub, 1);
+	snd_seq_port_subscribe_set_queue(sub, self->queue);
+	snd_seq_port_subscribe_set_time_real(sub, 1);
+
+	if ((err=snd_seq_subscribe_port(self->seq, sub)))
+		error_log("can't subscribe to %d:%d - %s\n", client, port, snd_strerror(err));
+	return err;
+}
+
+/*
+ * ==================== Port routines =============================
+ */
+static inline
+int port_hash(snd_seq_addr_t addr)
+{
+	return (addr.client + addr.port) % PORT_HASH_SIZE;
+}
+
+static
+port_t* port_get(port_hash_t hash, snd_seq_addr_t addr)
+{
+	port_t **pport = &hash[port_hash(addr)];
+	while (*pport) {
+		port_t *port = *pport;
+		if (port->remote.client == addr.client && port->remote.port == addr.port)
+			return port;
+		pport = &port->next;
+	}
+	return NULL;
+}
+
+static
+void port_insert(port_hash_t hash, port_t *port)
+{
+	port_t **pport = &hash[port_hash(port->remote)];
+	port->next = *pport;
+	*pport = port;
+}
+
+static
+void port_setdead(port_hash_t hash, snd_seq_addr_t addr)
+{
+	port_t *port = port_get(hash, addr);
+	if (port)
+		port->is_dead = 1; // see jack_process
+	else
+		debug_log("port_setdead: not found (%d:%d)\n", addr.client, addr.port);
+}
+
+static
+void port_free(alsa_seqmidi_t *self, port_t *port)
+{
+	//snd_seq_disconnect_from(self->seq, self->port_id, port->remote.client, port->remote.port);
+	//snd_seq_disconnect_to(self->seq, self->port_id, port->remote.client, port->remote.port);
+	if (port->early_events)
+		jack_ringbuffer_free(port->early_events);
+	if (port->jack_port)
+		jack_port_unregister(self->jack, port->jack_port);
+	info_log("port deleted: %s\n", port->name);
+
+	free(port);
+}
+
+static
+port_t* port_create(alsa_seqmidi_t *self, int type, snd_seq_addr_t addr, const snd_seq_port_info_t *info)
+{
+	port_t *port;
+	char *c;
+	int err;
+
+	port = calloc(1, sizeof(port_t));
+	if (!port)
+		return NULL;
+
+	port->remote = addr;
+
+	snprintf(port->name, sizeof(port->name), "%s-%d-%d-%s",
+		port_type[type].name, addr.client, addr.port, snd_seq_port_info_get_name(info));
+
+	// replace all offending characters by -
+	for (c = port->name; *c; ++c)
+		if (!isalnum(*c))
+			*c = '-';
+
+	port->jack_port = jack_port_register(self->jack,
+		port->name, JACK_DEFAULT_MIDI_TYPE, port_type[type].jack_caps, 0);
+	if (!port->jack_port)
+		goto failed;
+
+	if (type == PORT_INPUT)
+		err = alsa_connect_from(self, port->remote.client, port->remote.port);
+	else
+		err = snd_seq_connect_to(self->seq, self->port_id, port->remote.client, port->remote.port);
+	if (err)
+		goto failed;
+
+	port->early_events = jack_ringbuffer_create(MAX_EVENT_SIZE*16);
+
+	info_log("port created: %s\n", port->name);
+	return port;
+
+ failed:
+ 	port_free(self, port);
+	return NULL;
+}
+
+/*
+ * ==================== Port add/del handling thread ==============================
+ */
+static
+void update_port_type(alsa_seqmidi_t *self, int type, snd_seq_addr_t addr, int caps, const snd_seq_port_info_t *info)
+{
+	stream_t *str = &self->stream[type];
+	int alsa_mask = port_type[type].alsa_mask;
+	port_t *port = port_get(str->ports, addr);
+
+	debug_log("update_port_type(%d:%d)\n", addr.client, addr.port);
+
+	if (port && (caps & alsa_mask)!=alsa_mask) {
+		debug_log("setdead: %s\n", port->name);
+		port->is_dead = 1;
+	}
+
+	if (!port && (caps & alsa_mask)==alsa_mask) {
+		assert (jack_ringbuffer_write_space(str->new_ports) >= sizeof(port));
+		port = port_create(self, type, addr, info);
+		if (port)
+			jack_ringbuffer_write(str->new_ports, (char*)&port, sizeof(port));
+	}
+}
+
+static
+void update_port(alsa_seqmidi_t *self, snd_seq_addr_t addr, const snd_seq_port_info_t *info)
+{
+	unsigned int port_caps = snd_seq_port_info_get_capability(info);
+	if (port_caps & SND_SEQ_PORT_CAP_NO_EXPORT)
+		return;
+	update_port_type(self, PORT_INPUT, addr, port_caps, info);
+	update_port_type(self, PORT_OUTPUT, addr, port_caps, info);
+}
+
+static
+void free_ports(alsa_seqmidi_t *self, jack_ringbuffer_t *ports)
+{
+	port_t *port;
+	int sz;
+	while ((sz = jack_ringbuffer_read(ports, (char*)&port, sizeof(port)))) {
+		assert (sz == sizeof(port));
+		port_free(self, port);
+	}
+}
+
+static
+void update_ports(alsa_seqmidi_t *self)
+{
+	snd_seq_addr_t addr;
+	int size;
+
+	while ((size = jack_ringbuffer_read(self->port_add, (char*)&addr, sizeof(addr)))) {
+		snd_seq_port_info_t *info;
+		int err;
+
+		snd_seq_port_info_alloca(&info);
+		assert (size == sizeof(addr));
+		assert (addr.client != self->client_id);
+		if ((err=snd_seq_get_any_port_info(self->seq, addr.client, addr.port, info))>=0) {
+			update_port(self, addr, info);
+		} else {
+			//port_setdead(self->stream[PORT_INPUT].ports, addr);
+			//port_setdead(self->stream[PORT_OUTPUT].ports, addr);
+		}
+	}
+}
+
+static
+void* port_thread(void *arg)
+{
+	alsa_seqmidi_t *self = arg;
+
+	while (self->keep_walking) {
+		sem_wait(&self->port_sem);
+		free_ports(self, self->port_del);
+		update_ports(self);
+	}
+	debug_log("port_thread exited\n");
+	return NULL;
+}
+
+static
+void add_existing_ports(alsa_seqmidi_t *self)
+{
+	snd_seq_addr_t addr;
+	snd_seq_client_info_t *client_info;
+	snd_seq_port_info_t *port_info;
+
+	snd_seq_client_info_alloca(&client_info);
+	snd_seq_port_info_alloca(&port_info);
+	snd_seq_client_info_set_client(client_info, -1);
+	while (snd_seq_query_next_client(self->seq, client_info) >= 0)
+	{
+		addr.client = snd_seq_client_info_get_client(client_info);
+		if (addr.client == SND_SEQ_CLIENT_SYSTEM || addr.client == self->client_id)
+			continue;
+		snd_seq_port_info_set_client(port_info, addr.client);
+		snd_seq_port_info_set_port(port_info, -1);
+		while (snd_seq_query_next_port(self->seq, port_info) >= 0)
+		{
+			addr.port = snd_seq_port_info_get_port(port_info);
+			update_port(self, addr, port_info);
+		}
+	}
+}
+
+/*
+ * =================== Input/output port handling =========================
+ */
+static
+void set_process_info(struct process_info *info, alsa_seqmidi_t *self, int dir, jack_nframes_t nframes)
+{
+	const snd_seq_real_time_t* alsa_time;
+	snd_seq_queue_status_t *status;
+
+	snd_seq_queue_status_alloca(&status);
+
+	info->dir = dir;
+
+	info->period_start = jack_last_frame_time(self->jack);
+	info->nframes = nframes;
+	info->sample_rate = jack_get_sample_rate(self->jack);
+
+	info->cur_frames = jack_frame_time(self->jack);
+
+	// immediately get alsa'a real time (uhh, why everybody has their on 'real' time)
+	snd_seq_get_queue_status(self->seq, self->queue, status);
+	alsa_time = snd_seq_queue_status_get_real_time(status);
+	info->alsa_time = alsa_time->tv_sec * NSEC_PER_SEC + alsa_time->tv_nsec;
+
+	if (info->period_start + info->nframes < info->cur_frames) {
+		int periods_lost = (info->cur_frames - info->period_start) / info->nframes; 
+		info->period_start += periods_lost * info->nframes;
+		debug_log("xrun detected: %d periods lost\n", periods_lost);
+	}
+}
+
+static
+void add_ports(stream_t *str)
+{
+	port_t *port;
+	while (jack_ringbuffer_read(str->new_ports, (char*)&port, sizeof(port))) {
+		debug_log("jack: inserted port %s\n", port->name);
+		port_insert(str->ports, port);
+	}
+}
+
+static
+void jack_process(alsa_seqmidi_t *self, struct process_info *info)
+{
+	stream_t *str = &self->stream[info->dir];
+	port_jack_func process = port_type[info->dir].jack_func;
+	int i, del=0;
+
+	add_ports(str);
+
+	// process ports
+	for (i=0; i<PORT_HASH_SIZE; ++i) {
+		port_t **pport = &str->ports[i];
+		while (*pport) {
+			port_t *port = *pport;
+			port->jack_buf = jack_port_get_buffer(port->jack_port, info->nframes);
+			if (info->dir == PORT_INPUT)
+				jack_midi_clear_buffer(port->jack_buf);
+
+			if (!port->is_dead)
+				(*process)(self, port, info);
+			else if (jack_ringbuffer_write_space(self->port_del) >= sizeof(port)) {
+				debug_log("jack: removed port %s\n", port->name);
+				*pport = port->next;
+				jack_ringbuffer_write(self->port_del, (char*)&port, sizeof(port));
+				del++;
+				continue;
+			}
+
+			pport = &port->next;
+		}
+	}
+
+	if (del)
+		sem_post(&self->port_sem);
+}
+
+/*
+ * ============================ Input ==============================
+ */
+static
+void do_jack_input(alsa_seqmidi_t *self, port_t *port, struct process_info *info)
+{
+	// process port->early_events
+	alsa_midi_event_t ev;
+	while (jack_ringbuffer_read(port->early_events, (char*)&ev, sizeof(ev))) {
+		jack_midi_data_t* buf;
+		jack_nframes_t time = ev.time - info->period_start;
+		if (time < 0)
+			time = 0;
+		else if (time >= info->nframes)
+			time = info->nframes - 1;
+		buf = jack_midi_event_reserve(port->jack_buf, time, ev.size);
+		if (buf)
+			jack_ringbuffer_read(port->early_events, (char*)buf, ev.size);
+		else
+			jack_ringbuffer_read_advance(port->early_events, ev.size);
+		debug_log("input: it's time for %d bytes at %d\n", ev.size, time);
+	}
+}
+
+static
+void port_event(alsa_seqmidi_t *self, snd_seq_event_t *ev)
+{
+	const snd_seq_addr_t addr = ev->data.addr;
+
+	if (addr.client == self->client_id)
+		return;
+
+	if (ev->type == SND_SEQ_EVENT_PORT_START || ev->type == SND_SEQ_EVENT_PORT_CHANGE) {
+		assert (jack_ringbuffer_write_space(self->port_add) >= sizeof(addr));
+
+		debug_log("port_event: add/change %d:%d\n", addr.client, addr.port);
+		jack_ringbuffer_write(self->port_add, (char*)&addr, sizeof(addr));
+		sem_post(&self->port_sem);
+	} else if (ev->type == SND_SEQ_EVENT_PORT_EXIT) {
+		debug_log("port_event: del %d:%d\n", addr.client, addr.port);
+		port_setdead(self->stream[PORT_INPUT].ports, addr);
+		port_setdead(self->stream[PORT_OUTPUT].ports, addr);
+	}
+}
+
+static
+void input_event(alsa_seqmidi_t *self, snd_seq_event_t *alsa_event, struct process_info* info)
+{
+	jack_midi_data_t data[MAX_EVENT_SIZE];
+	stream_t *str = &self->stream[PORT_INPUT];
+	long size;
+	int64_t alsa_time, time_offset;
+	int64_t frame_offset, event_frame;
+	port_t *port;
+
+	port = port_get(str->ports, alsa_event->source);
+	if (!port)
+		return;
+
+	/*
+	 * RPNs, NRPNs, Bank Change, etc. need special handling
+	 * but seems, ALSA does it for us already.
+	 */
+	snd_midi_event_reset_decode(str->codec);
+	if ((size = snd_midi_event_decode(str->codec, data, sizeof(data), alsa_event))<0)
+		return;
+
+	// fixup NoteOn with vel 0
+	if (data[0] == 0x90 && data[2] == 0x00) {
+		data[0] = 0x80;
+		data[2] = 0x40;
+	}
+
+	alsa_time = alsa_event->time.time.tv_sec * NSEC_PER_SEC + alsa_event->time.time.tv_nsec;
+	time_offset = info->alsa_time - alsa_time;
+	frame_offset = (info->sample_rate * time_offset) / NSEC_PER_SEC;
+	event_frame = (int64_t)info->cur_frames - info->period_start - frame_offset + info->nframes;
+
+	debug_log("input: %d bytes at event_frame=%d\n", (int)size, (int)event_frame);
+
+	if (event_frame >= info->nframes &&
+	    jack_ringbuffer_write_space(port->early_events) >= (sizeof(alsa_midi_event_t) + size)) {
+		alsa_midi_event_t ev;
+		ev.time = event_frame + info->period_start;
+		ev.size = size;
+		jack_ringbuffer_write(port->early_events, (char*)&ev, sizeof(ev));
+		jack_ringbuffer_write(port->early_events, (char*)data, size);
+		debug_log("postponed to next frame +%d\n", (int) (event_frame - info->nframes)); 
+		return;
+	}
+
+	if (event_frame < 0)
+		event_frame = 0;
+	else if (event_frame >= info->nframes)
+		event_frame = info->nframes - 1;
+
+	jack_midi_event_write(port->jack_buf, event_frame, data, size);
+}
+
+static
+void alsa_seqmidi_read(alsa_midi_t *m, jack_nframes_t nframes)
+{
+	alsa_seqmidi_t *self = (alsa_seqmidi_t*) m;
+	int res;
+	snd_seq_event_t *event;
+	struct process_info info;
+
+	if (!self->keep_walking)
+		return;
+
+	set_process_info(&info, self, PORT_INPUT, nframes);
+	jack_process(self, &info); 
+
+	while ((res = snd_seq_event_input(self->seq, &event))>0) {
+		if (event->source.client == SND_SEQ_CLIENT_SYSTEM)
+			port_event(self, event);
+		else
+			input_event(self, event, &info);
+	}
+}
+
+/*
+ * ============================ Output ==============================
+ */
+
+static
+void do_jack_output(alsa_seqmidi_t *self, port_t *port, struct process_info* info)
+{
+	stream_t *str = &self->stream[info->dir];
+	int nevents = jack_midi_get_event_count(port->jack_buf);
+	int i;
+	for (i=0; i<nevents; ++i) {
+		jack_midi_event_t jack_event;
+		snd_seq_event_t alsa_event;
+		int64_t frame_offset;
+		int64_t out_time;
+		snd_seq_real_time_t out_rt;
+		int err;
+
+		jack_midi_event_get(&jack_event, port->jack_buf, i);
+
+		snd_seq_ev_clear(&alsa_event);
+		snd_midi_event_reset_encode(str->codec);
+		if (!snd_midi_event_encode(str->codec, jack_event.buffer, jack_event.size, &alsa_event))
+			continue; // invalid event
+
+		snd_seq_ev_set_source(&alsa_event, self->port_id);
+		snd_seq_ev_set_dest(&alsa_event, port->remote.client, port->remote.port);
+
+		/* NOTE: in case of xrun it could become negative, so it is essential to use signed type! */
+		frame_offset = (int64_t)jack_event.time + info->period_start + info->nframes - info->cur_frames;
+		if (frame_offset < 0) {
+			frame_offset = info->nframes + jack_event.time;
+			error_log("internal xrun detected: frame_offset = %lld\n", frame_offset);
+		}
+		assert (frame_offset < info->nframes*2);
+
+		out_time = info->alsa_time + (frame_offset * NSEC_PER_SEC) / info->sample_rate;
+
+		// we should use absolute time to prevent reordering caused by rounding errors
+		if (out_time < port->last_out_time) {
+			debug_log("alsa_out: limiting out_time %lld at %lld\n", out_time, port->last_out_time);
+			out_time = port->last_out_time;
+		} else
+			port->last_out_time = out_time;
+
+		out_rt.tv_nsec = out_time % NSEC_PER_SEC;
+		out_rt.tv_sec = out_time / NSEC_PER_SEC;
+		snd_seq_ev_schedule_real(&alsa_event, self->queue, 0, &out_rt);
+
+		err = snd_seq_event_output(self->seq, &alsa_event);
+
+		debug_log("alsa_out: written %d bytes to %s at %d (%lld): %d %s\n",
+			jack_event.size, port->name, (int)frame_offset, out_time - info->alsa_time, err, err < 0 ? snd_strerror(err) : "bytes queued");
+	}
+}
+
+static
+void alsa_seqmidi_write(alsa_midi_t *m, jack_nframes_t nframes)
+{
+	alsa_seqmidi_t *self = (alsa_seqmidi_t*) m;
+	struct process_info info;
+
+	if (!self->keep_walking)
+		return;
+
+	set_process_info(&info, self, PORT_OUTPUT, nframes);
+	jack_process(self, &info);
+	snd_seq_drain_output(self->seq);
+}
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/midi_pack.h jack/drivers/alsa-midi/midi_pack.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/midi_pack.h	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/alsa-midi/midi_pack.h	2007-08-25 15:30:44.000000000 +0700
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2006,2007 Dmitry S. Baikov
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __jack_midi_pack_h__
+#define __jack_midi_pack_h__
+
+#include <jack/midiport.h>
+#include <jack/engine.h>
+
+typedef struct {
+	int running_status;
+} midi_pack_t;
+
+static inline
+void midi_pack_reset(midi_pack_t *p)
+{
+	p->running_status = 0;
+}
+
+static
+void midi_pack_event(midi_pack_t *p, jack_midi_event_t *e)
+{
+	if (e->buffer[0] >= 0x80 && e->buffer[0] < 0xF0) { // Voice Message
+		if (e->buffer[0] == p->running_status) {
+			e->buffer++;
+			e->size--;
+		} else
+			p->running_status = e->buffer[0];
+	} else if (e->buffer[0] < 0xF8) { // not System Realtime
+		p->running_status = 0;
+	}
+}
+
+#endif /* __jack_midi_pack_h__ */
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/midi_unpack.h jack/drivers/alsa-midi/midi_unpack.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/alsa-midi/midi_unpack.h	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/alsa-midi/midi_unpack.h	2007-08-25 15:30:44.000000000 +0700
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2006,2007 Dmitry S. Baikov
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef __jack_midi_unpack_h__
+#define __jack_midi_unpack_h__
+
+#include <jack/midiport.h>
+#include <jack/engine.h>
+
+enum {
+	MIDI_UNPACK_MAX_MSG = 1024
+};
+
+typedef struct {
+	int pos, need, size;
+	unsigned char data[MIDI_UNPACK_MAX_MSG];
+} midi_unpack_t;
+
+static inline
+void midi_unpack_init(midi_unpack_t *u)
+{
+	u->pos = 0;
+	u->size = sizeof(u->data);
+	u->need = u->size;
+}
+
+static inline
+void midi_unpack_reset(midi_unpack_t *u)
+{
+	u->pos = 0;
+	u->need = u->size;
+}
+
+static const unsigned char midi_voice_len[] = {
+	3, /*0x80 Note Off*/
+	3, /*0x90 Note On*/
+	3, /*0xA0 Aftertouch*/
+	3, /*0xB0 Control Change*/
+	2, /*0xC0 Program Change*/
+	2, /*0xD0 Channel Pressure*/
+	3, /*0xE0 Pitch Wheel*/
+	1  /*0xF0 System*/
+};
+
+static const unsigned char midi_system_len[] = {
+	0, /*0xF0 System Exclusive Start*/
+	2, /*0xF1 MTC Quarter Frame*/
+	3, /*0xF2 Song Postion*/
+	2, /*0xF3 Song Select*/
+	0, /*0xF4 undefined*/
+	0, /*0xF5 undefined*/
+	1, /*0xF6 Tune Request*/
+	1  /*0xF7 System Exlusive End*/
+};
+
+static
+int midi_unpack_buf(midi_unpack_t *buf, const unsigned char *data, int len, void *jack_port_buf, jack_nframes_t time)
+{
+	int i;
+	for (i=0; i<len; ++i)
+	{
+		const unsigned char byte = data[i];
+		if (byte >= 0xF8) // system realtime
+		{
+			jack_midi_event_write(jack_port_buf, time, &data[i], 1);
+			//jack_error("midi_unpack: written system relatime event\n");
+			//midi_input_write(in, &data[i], 1);
+		}
+		else if (byte < 0x80) // data
+		{
+			assert (buf->pos < buf->size);
+			buf->data[buf->pos++] = byte;
+		}
+		else if (byte < 0xF0) // voice
+		{
+			assert (byte >= 0x80 && byte < 0xF0);
+			//buf->need = ((byte|0x0F) == 0xCF || (byte|0x0F)==0xDF) ? 2 : 3;
+			buf->need = midi_voice_len[(byte-0x80)>>4];
+			buf->data[0] = byte;
+			buf->pos = 1;
+		}
+		else if (byte == 0xF7) // sysex end
+		{
+			assert (buf->pos < buf->size);
+			buf->data[buf->pos++] = byte;
+			buf->need = buf->pos;
+		}
+		else
+		{
+			assert (byte >= 0xF0 && byte < 0xF8);
+			buf->pos = 1;
+			buf->data[0] = byte;
+			buf->need = midi_system_len[byte - 0xF0];
+			if (!buf->need)
+				buf->need = buf->size;
+		}
+		if (buf->pos == buf->need)
+		{
+			// TODO: deal with big sysex'es (they are silently dropped for now)
+			if (buf->data[0] >= 0x80 || (buf->data[0]==0xF0 && buf->data[buf->pos-1] == 0xF7)) {
+				/* convert Note On with velocity 0 to Note Off */
+				if ((buf->data[0] & 0xF0) == 0x90 && buf->data[2] == 0) {
+					// we use temp array here to keep running status in sync
+					jack_midi_data_t temp[3] = { 0x80, 0, 0x40 };
+					temp[0] |= buf->data[0] & 0x0F;
+					temp[1] = buf->data[1];
+					jack_midi_event_write(jack_port_buf, time, temp, 3);
+				} else
+					jack_midi_event_write(jack_port_buf, time, &buf->data[0], buf->pos);
+				//jack_error("midi_unpack: written %d-byte event\n", buf->pos);
+				//midi_input_write(in, &buf->data[0], buf->pos);
+			}
+			/* keep running status */
+			if (buf->data[0] >= 0x80 && buf->data[0] < 0xF0)
+				buf->pos = 1;
+			else
+			{
+				buf->pos = 0;
+				buf->need = buf->size;
+			}
+		}
+	}
+	assert (i==len);
+	return i;
+}
+
+#endif /* __jack_midi_unpack_h__ */
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/dummy/dummy_driver.c jack/drivers/dummy/dummy_driver.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/dummy/dummy_driver.c	2006-08-31 11:42:12.000000000 +0700
+++ jack/drivers/dummy/dummy_driver.c	2007-08-25 15:30:46.000000000 +0700
@@ -17,7 +17,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: dummy_driver.c 985 2006-08-29 15:21:17Z paul $
 */
 
 #include <math.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/firewire/Makefile.am jack/drivers/firewire/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/drivers/firewire/Makefile.am	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/firewire/Makefile.am	2007-08-25 15:30:46.000000000 +0700
@@ -0,0 +1,20 @@
+# plugin is called 'firewire',
+# driver code is called 'ffado*' because it is an implementation
+# of a firewire backend
+
+MAINTAINERCLEANFILES=Makefile.in
+
+AM_CFLAGS = $(JACK_CFLAGS) $(LIBFFADO_CFLAGS) $(ALSA_CFLAGS)
+
+plugindir = $(ADDON_DIR)
+
+plugin_LTLIBRARIES = jack_firewire.la
+
+jack_firewire_la_SOURCES = ffado_driver.c
+
+jack_firewire_la_LIBADD = $(LIBFFADO_LIBS) $(ALSA_LIBS)
+
+jack_firewire_la_LDFLAGS = -module -avoid-version
+
+noinst_HEADERS = ffado_driver.h
+
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/firewire/ffado_driver.c jack/drivers/firewire/ffado_driver.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/firewire/ffado_driver.c	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/firewire/ffado_driver.c	2007-08-25 15:30:46.000000000 +0700
@@ -0,0 +1,1216 @@
+/*
+ *   FireWire Backend for Jack
+ *   using FFADO
+ *   FFADO = Firewire (pro-)audio for linux
+ *
+ *   http://www.ffado.org
+ *   http://www.jackaudio.org
+ *
+ *   Copyright (C) 2005-2007 Pieter Palmers
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* 
+ * Main Jack driver entry routines
+ *
+ */ 
+
+#include <math.h>
+#include <stdio.h>
+#include <memory.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <sys/mman.h>
+
+#include <jack/types.h>
+#include <jack/internal.h>
+#include <jack/engine.h>
+#include <sysdeps/time.h>
+
+#include "ffado_driver.h"
+
+#define SAMPLE_MAX_24BIT  8388608.0f
+#define SAMPLE_MAX_16BIT  32768.0f
+
+static int ffado_driver_stop (ffado_driver_t *driver);
+
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+	static ffado_driver_midi_handle_t *ffado_driver_midi_init(ffado_driver_t *driver);
+	static void ffado_driver_midi_finish (ffado_driver_midi_handle_t *m);
+	static int ffado_driver_midi_start (ffado_driver_midi_handle_t *m);
+	static int ffado_driver_midi_stop (ffado_driver_midi_handle_t *m);
+#endif
+
+// enable verbose messages
+static int g_verbose=0;
+
+static int
+ffado_driver_attach (ffado_driver_t *driver)
+{
+	char buf[64];
+	channel_t chn;
+	jack_port_t *port;
+	int port_flags;
+
+	g_verbose=driver->engine->verbose;
+	driver->device_options.verbose=g_verbose;
+
+	driver->engine->set_buffer_size (driver->engine, driver->period_size);
+	driver->engine->set_sample_rate (driver->engine, driver->sample_rate);
+
+	/* packetizer thread options */
+	driver->device_options.realtime=(driver->engine->control->real_time? 1 : 0);
+	
+	driver->device_options.packetizer_priority=driver->engine->control->client_priority +
+		FFADO_RT_PRIORITY_PACKETIZER_RELATIVE;
+	if (driver->device_options.packetizer_priority>98) {
+		driver->device_options.packetizer_priority=98;
+	}
+
+	driver->dev=ffado_streaming_init(&driver->device_info,driver->device_options);
+
+	if(!driver->dev) {
+		printError("Error creating FFADO streaming device");
+		return -1;
+	}
+
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+	driver->midi_handle=ffado_driver_midi_init(driver);
+	if(!driver->midi_handle) {
+		printError("-----------------------------------------------------------");
+		printError("Error creating midi device!");
+		printError("The FireWire backend will run without MIDI support.");
+		printError("Consult the above error messages to solve the problem. ");
+		printError("-----------------------------------------------------------\n\n");
+	}
+#endif
+
+	if (driver->device_options.realtime) {
+		printMessage("Streaming thread running with Realtime scheduling, priority %d",
+		           driver->device_options.packetizer_priority);
+	} else {
+		printMessage("Streaming thread running without Realtime scheduling");
+	}
+
+	/* ports */
+	port_flags = JackPortIsOutput|JackPortIsPhysical|JackPortIsTerminal;
+
+	driver->capture_nchannels=ffado_streaming_get_nb_capture_streams(driver->dev);
+
+	for (chn = 0; chn < driver->capture_nchannels; chn++) {
+		
+		ffado_streaming_get_capture_stream_name(driver->dev, chn, buf, sizeof(buf) - 1);
+		
+		if(ffado_streaming_get_capture_stream_type(driver->dev, chn) != ffado_stream_type_audio) {
+			printMessage ("Don't register capture port %s", buf);
+
+			// we have to add a NULL entry in the list to be able to loop over the channels in the read/write routines
+			driver->capture_ports =
+				jack_slist_append (driver->capture_ports, NULL);
+		} else {
+			printMessage ("Registering capture port %s", buf);
+			if ((port = jack_port_register (driver->client, buf,
+							JACK_DEFAULT_AUDIO_TYPE,
+							port_flags, 0)) == NULL) {
+				printError (" cannot register port for %s", buf);
+				break;
+			}
+			driver->capture_ports =
+				jack_slist_append (driver->capture_ports, port);
+			// setup port parameters
+			if(ffado_streaming_set_capture_buffer_type(driver->dev, chn, ffado_buffer_type_float)) {
+				printError(" cannot set port buffer type for %s", buf);
+			}
+			if (ffado_streaming_set_capture_stream_buffer(driver->dev, chn, NULL)) {
+				printError(" cannot configure initial port buffer for %s", buf);
+			}
+			if(ffado_streaming_capture_stream_onoff(driver->dev, chn, 1)) {
+				printError(" cannot enable port %s", buf);
+			}
+		}
+// 		jack_port_set_latency (port, driver->period_size);
+
+	}
+	
+	port_flags = JackPortIsInput|JackPortIsPhysical|JackPortIsTerminal;
+
+	driver->playback_nchannels=ffado_streaming_get_nb_playback_streams(driver->dev);
+
+	for (chn = 0; chn < driver->playback_nchannels; chn++) {
+
+		ffado_streaming_get_playback_stream_name(driver->dev, chn, buf, sizeof(buf) - 1);
+		
+		if(ffado_streaming_get_playback_stream_type(driver->dev, chn) != ffado_stream_type_audio) {
+			printMessage ("Don't register playback port %s", buf);
+
+			// we have to add a NULL entry in the list to be able to loop over the channels in the read/write routines
+			driver->playback_ports =
+				jack_slist_append (driver->playback_ports, NULL);
+		} else {
+			printMessage ("Registering playback port %s", buf);
+			if ((port = jack_port_register (driver->client, buf,
+							JACK_DEFAULT_AUDIO_TYPE,
+							port_flags, 0)) == NULL) {
+				printError(" cannot register port for %s", buf);
+				break;
+			}
+			driver->playback_ports =
+				jack_slist_append (driver->playback_ports, port);
+
+			// setup port parameters
+			if(ffado_streaming_set_playback_buffer_type(driver->dev, chn, ffado_buffer_type_float)) {
+				printError(" cannot set port buffer type for %s", buf);
+			}
+			if (ffado_streaming_set_playback_stream_buffer(driver->dev, chn, NULL)) {
+				printError(" cannot configure initial port buffer for %s", buf);
+			}
+			if(ffado_streaming_playback_stream_onoff(driver->dev, chn, 1)) {
+				printError(" cannot enable port %s", buf);
+			}
+		}
+// 		jack_port_set_latency (port, (driver->period_size * (driver->user_nperiods - 1)) + driver->playback_frame_latency);
+
+	}
+
+	if(!ffado_streaming_prepare(driver->dev)) {
+		printError("Could not prepare streaming device!");
+		return -1;
+	}
+	
+
+	return jack_activate (driver->client);
+}
+
+static int 
+ffado_driver_detach (ffado_driver_t *driver)
+{
+	JSList *node;
+
+	if (driver->engine == NULL) {
+		return 0;
+	}
+
+	for (node = driver->capture_ports; node;
+	     node = jack_slist_next (node)) {
+		// Don't try to unregister NULL entries added for non-audio
+		// ffado ports by ffado_driver_attach().
+		if (node->data != NULL) {
+			jack_port_unregister (driver->client,
+					      ((jack_port_t *) node->data));
+		}
+	}
+
+	jack_slist_free (driver->capture_ports);
+	driver->capture_ports = 0;
+		
+	for (node = driver->playback_ports; node;
+	     node = jack_slist_next (node)) {
+        if (node->data != NULL) {
+    		jack_port_unregister (driver->client,
+				      ((jack_port_t *) node->data));
+        }
+	}
+
+	jack_slist_free (driver->playback_ports);
+	driver->playback_ports = 0;
+
+	ffado_streaming_finish(driver->dev);
+	driver->dev=NULL;
+
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+	if(driver->midi_handle) {
+		ffado_driver_midi_finish(driver->midi_handle);	
+	}
+	driver->midi_handle=NULL;
+#endif
+
+	return 0;
+}
+
+static inline void 
+ffado_driver_read_from_channel (ffado_driver_t *driver,
+			       channel_t channel,
+			       jack_default_audio_sample_t *dst,
+			       jack_nframes_t nsamples)
+{
+	
+	ffado_sample_t buffer[nsamples];
+	char *src=(char *)buffer;
+	
+	ffado_streaming_read(driver->dev, channel, buffer, nsamples);
+	
+	/* ALERT: signed sign-extension portability !!! */
+
+	while (nsamples--) {
+		int x;
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+		memcpy((char*)&x + 1, src, 3);
+#elif __BYTE_ORDER == __BIG_ENDIAN
+		memcpy(&x, src, 3);
+#endif
+		x >>= 8;
+		*dst = x / SAMPLE_MAX_24BIT;
+		dst++;
+		src += sizeof(ffado_sample_t);
+	}
+	
+}
+
+static int
+ffado_driver_read (ffado_driver_t * driver, jack_nframes_t nframes)
+{
+	jack_default_audio_sample_t* buf;
+	channel_t chn;
+	JSList *node;
+	jack_port_t* port;
+	
+	ffado_sample_t nullbuffer[nframes];
+
+	ffado_streaming_stream_type stream_type;
+	
+	printEnter();
+	
+	for (chn = 0, node = driver->capture_ports; node; node = jack_slist_next (node), chn++) {
+		stream_type = ffado_streaming_get_capture_stream_type(driver->dev, chn);
+		if(stream_type == ffado_stream_type_audio) {
+			port = (jack_port_t *) node->data;
+
+			buf = jack_port_get_buffer (port, nframes);
+			if(!buf) buf=(jack_default_audio_sample_t*)nullbuffer;
+				
+			ffado_streaming_set_capture_stream_buffer(driver->dev, chn, (char *)(buf));
+		}
+	}
+
+	// now transfer the buffers
+	ffado_streaming_transfer_capture_buffers(driver->dev);
+	
+	printExit();
+	
+	return 0;
+
+}
+
+static inline void 
+ffado_driver_write_to_channel (ffado_driver_t *driver,
+			      channel_t channel, 
+			      jack_default_audio_sample_t *buf, 
+			      jack_nframes_t nsamples)
+{
+    long long y;
+	ffado_sample_t buffer[nsamples];
+	unsigned int i=0;	
+    char *dst=(char *)buffer;
+	
+	// convert from float to integer
+	for(;i<nsamples;i++) {
+		y = (long long)(*buf * SAMPLE_MAX_24BIT);
+
+		if (y > (INT_MAX >> 8 )) {
+			y = (INT_MAX >> 8);
+		} else if (y < (INT_MIN >> 8 )) {
+			y = (INT_MIN >> 8 );
+		}
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+		memcpy (dst, &y, 3);
+#elif __BYTE_ORDER == __BIG_ENDIAN
+		memcpy (dst, (char *)&y + 5, 3);
+#endif
+		dst += sizeof(ffado_sample_t);
+		buf++;
+	}
+	
+	// write to the ffado streaming device
+	ffado_streaming_write(driver->dev, channel, buffer, nsamples);
+	
+}
+
+static int
+ffado_driver_write (ffado_driver_t * driver, jack_nframes_t nframes)
+{
+	channel_t chn;
+	JSList *node;
+	jack_default_audio_sample_t* buf;
+
+	jack_port_t *port;
+
+	ffado_streaming_stream_type stream_type;
+
+	ffado_sample_t nullbuffer[nframes];
+
+	memset(&nullbuffer,0,nframes*sizeof(ffado_sample_t));
+
+	printEnter();
+
+	driver->process_count++;
+
+	assert(driver->dev);
+
+ 	if (driver->engine->freewheeling) {
+ 		return 0;
+ 	}
+
+	for (chn = 0, node = driver->playback_ports; node; node = jack_slist_next (node), chn++) {
+		stream_type=ffado_streaming_get_playback_stream_type(driver->dev, chn);
+		if(stream_type == ffado_stream_type_audio) {
+			port = (jack_port_t *) node->data;
+
+			buf = jack_port_get_buffer (port, nframes);
+			if(!buf) buf=(jack_default_audio_sample_t*)nullbuffer;
+				
+			ffado_streaming_set_playback_stream_buffer(driver->dev, chn, (char *)(buf));
+		}
+	}
+
+	ffado_streaming_transfer_playback_buffers(driver->dev);
+
+	printExit();
+	
+	return 0;
+}
+
+//static inline jack_nframes_t 
+static jack_nframes_t 
+ffado_driver_wait (ffado_driver_t *driver, int extra_fd, int *status,
+		   float *delayed_usecs)
+{
+	int nframes;
+	jack_time_t                   wait_enter;
+	jack_time_t                   wait_ret;
+	
+	printEnter();
+
+	wait_enter = jack_get_microseconds ();
+	if (wait_enter > driver->wait_next) {
+		/*
+			* This processing cycle was delayed past the
+			* next due interrupt!  Do not account this as
+			* a wakeup delay:
+			*/
+		driver->wait_next = 0;
+		driver->wait_late++;
+	}
+// *status = -2; interrupt
+// *status = -3; timeout
+// *status = -4; extra FD
+
+	nframes=ffado_streaming_wait(driver->dev);
+	
+	wait_ret = jack_get_microseconds ();
+	
+	if (driver->wait_next && wait_ret > driver->wait_next) {
+		*delayed_usecs = wait_ret - driver->wait_next;
+	}
+	driver->wait_last = wait_ret;
+	driver->wait_next = wait_ret + driver->period_usecs;
+	driver->engine->transport_cycle_start (driver->engine, wait_ret);
+	
+	// transfer the streaming buffers
+	// we now do this in the read/write functions
+// 	ffado_streaming_transfer_buffers(driver->dev);
+	
+	if (nframes < 0) {
+		*status=0;
+		
+		return 0;
+		//nframes=driver->period_size; //debug
+	}
+
+	*status = 0;
+	driver->last_wait_ust = wait_ret;
+
+	// FIXME: this should do something more usefull
+	*delayed_usecs = 0;
+	
+	printExit();
+
+	return nframes - nframes % driver->period_size;
+	
+}
+
+static int
+ffado_driver_run_cycle (ffado_driver_t *driver)
+{
+	jack_engine_t *engine = driver->engine;
+	int wait_status=0;
+	float delayed_usecs=0.0;
+
+	jack_nframes_t nframes = ffado_driver_wait (driver, -1,
+	   &wait_status, &delayed_usecs);
+	
+	if ((wait_status < 0)) {
+		printError( "wait status < 0! (= %d)",wait_status);
+		return -1;
+	}
+		
+	if ((nframes == 0)) {
+		/* we detected an xrun and restarted: notify
+		 * clients about the delay. */
+		printMessage("xrun detected");
+		engine->delay (engine, delayed_usecs);
+		return 0;
+	} 
+	
+	return engine->run_cycle (engine, nframes, delayed_usecs);
+
+}
+/*
+ * in a null cycle we should discard the input and write silence to the outputs
+ */
+static int
+ffado_driver_null_cycle (ffado_driver_t* driver, jack_nframes_t nframes)
+{
+	channel_t chn;
+	JSList *node;
+	snd_pcm_sframes_t nwritten;
+
+	ffado_streaming_stream_type stream_type;
+
+	jack_default_audio_sample_t buff[nframes];
+	jack_default_audio_sample_t* buffer=(jack_default_audio_sample_t*)buff;
+	
+	printEnter();
+
+	memset(buffer,0,nframes*sizeof(jack_default_audio_sample_t));
+	
+	assert(driver->dev);
+
+ 	if (driver->engine->freewheeling) {
+ 		return 0;
+ 	}
+
+	// write silence to buffer
+	nwritten = 0;
+
+	for (chn = 0, node = driver->playback_ports; node; node = jack_slist_next (node), chn++) {
+		stream_type=ffado_streaming_get_playback_stream_type(driver->dev, chn);
+
+		if(stream_type == ffado_stream_type_audio) {
+			ffado_streaming_set_playback_stream_buffer(driver->dev, chn, (char *)(buffer));
+		}
+	}
+
+	ffado_streaming_transfer_playback_buffers(driver->dev);
+	
+	// read & discard from input ports
+	for (chn = 0, node = driver->capture_ports; node; node = jack_slist_next (node), chn++) {
+		stream_type=ffado_streaming_get_capture_stream_type(driver->dev, chn);
+		if(stream_type == ffado_stream_type_audio) {
+			ffado_streaming_set_capture_stream_buffer(driver->dev, chn, (char *)(buffer));
+		}
+	}
+
+	// now transfer the buffers
+	ffado_streaming_transfer_capture_buffers(driver->dev);
+		
+	printExit();
+	return 0;
+}
+
+static int
+ffado_driver_start (ffado_driver_t *driver)
+{
+	int retval=0;
+
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+	if(driver->midi_handle) {
+		if((retval=ffado_driver_midi_start(driver->midi_handle))) {
+			printError("Could not start MIDI threads");
+			return retval;
+		}
+	}
+#endif	
+
+	if((retval=ffado_streaming_start(driver->dev))) {
+		printError("Could not start streaming threads");
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+		if(driver->midi_handle) {
+			ffado_driver_midi_stop(driver->midi_handle);
+		}
+#endif	
+		return retval;
+	}
+
+	return 0;
+
+}
+
+static int
+ffado_driver_stop (ffado_driver_t *driver)
+{
+	int retval=0;
+	
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+	if(driver->midi_handle) {
+		if((retval=ffado_driver_midi_stop(driver->midi_handle))) {
+			printError("Could not stop MIDI threads");
+			return retval;
+		}
+	}
+#endif	
+	if((retval=ffado_streaming_stop(driver->dev))) {
+		printError("Could not stop streaming threads");
+		return retval;
+	}
+
+	return 0;
+}
+
+
+static int
+ffado_driver_bufsize (ffado_driver_t* driver, jack_nframes_t nframes)
+{
+	printError("Buffer size change requested but not supported!!!");
+
+	/*
+	 driver->period_size = nframes;  
+	driver->period_usecs =
+		(jack_time_t) floor ((((float) nframes) / driver->sample_rate)
+				     * 1000000.0f);
+	*/
+	
+	/* tell the engine to change its buffer size */
+	//driver->engine->set_buffer_size (driver->engine, nframes);
+
+	return -1; // unsupported
+}
+
+typedef void (*JackDriverFinishFunction) (jack_driver_t *);
+
+ffado_driver_t *
+ffado_driver_new (jack_client_t * client,
+		  char *name,
+		  ffado_jack_settings_t *params)
+{
+	ffado_driver_t *driver;
+
+	assert(params);
+
+	if(ffado_get_api_version() != 2) {
+		printError("Incompatible libffado version! (%s)", ffado_get_version());
+		return NULL;
+	}
+
+	printMessage("Starting Freebob backend (%s)", ffado_get_version());
+
+	driver = calloc (1, sizeof (ffado_driver_t));
+
+	/* Setup the jack interfaces */  
+	jack_driver_nt_init ((jack_driver_nt_t *) driver);
+
+	driver->nt_attach    = (JackDriverNTAttachFunction)   ffado_driver_attach;
+	driver->nt_detach    = (JackDriverNTDetachFunction)   ffado_driver_detach;
+	driver->nt_start     = (JackDriverNTStartFunction)    ffado_driver_start;
+	driver->nt_stop      = (JackDriverNTStopFunction)     ffado_driver_stop;
+	driver->nt_run_cycle = (JackDriverNTRunCycleFunction) ffado_driver_run_cycle;
+	driver->null_cycle   = (JackDriverNullCycleFunction)  ffado_driver_null_cycle;
+	driver->write        = (JackDriverReadFunction)       ffado_driver_write;
+	driver->read         = (JackDriverReadFunction)       ffado_driver_read;
+	driver->nt_bufsize   = (JackDriverNTBufSizeFunction)  ffado_driver_bufsize;
+	
+	/* copy command line parameter contents to the driver structure */
+	memcpy(&driver->settings,params,sizeof(ffado_jack_settings_t));
+	
+	/* prepare all parameters */
+	driver->sample_rate = params->sample_rate;
+	driver->period_size = params->period_size;
+	driver->last_wait_ust = 0;
+	
+	driver->period_usecs =
+		(jack_time_t) floor ((((float) driver->period_size) * 1000000.0f) / driver->sample_rate);
+
+	driver->client = client;
+	driver->engine = NULL;
+
+	memset(&driver->device_options,0,sizeof(driver->device_options));	
+	driver->device_options.sample_rate=params->sample_rate;
+	driver->device_options.period_size=params->period_size;
+	driver->device_options.nb_buffers=params->buffer_size;
+	driver->device_options.node_id=params->node_id;
+	driver->device_options.port=params->port;
+	driver->device_options.slave_mode=params->slave_mode;
+	driver->device_options.snoop_mode=params->snoop_mode;
+
+	if(!params->capture_ports) {
+		driver->device_options.directions |= FFADO_IGNORE_CAPTURE;
+	}
+
+	if(!params->playback_ports) {
+		driver->device_options.directions |= FFADO_IGNORE_PLAYBACK;
+	}
+
+	debugPrint(DEBUG_LEVEL_STARTUP, " Driver compiled on %s %s", __DATE__, __TIME__);
+	debugPrint(DEBUG_LEVEL_STARTUP, " Created driver %s", name);
+	debugPrint(DEBUG_LEVEL_STARTUP, "            period_size: %d", driver->period_size);
+	debugPrint(DEBUG_LEVEL_STARTUP, "            period_usecs: %d", driver->period_usecs);
+	debugPrint(DEBUG_LEVEL_STARTUP, "            sample rate: %d", driver->sample_rate);
+
+	return (ffado_driver_t *) driver;
+
+}
+
+static void
+ffado_driver_delete (ffado_driver_t *driver)
+{
+	jack_driver_nt_finish ((jack_driver_nt_t *) driver);
+	free (driver);
+}
+
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+/*
+ * MIDI support
+ */ 
+
+// the thread that will queue the midi events from the seq to the stream buffers
+
+void * ffado_driver_midi_queue_thread(void *arg)
+{
+	ffado_driver_midi_handle_t *m=(ffado_driver_midi_handle_t *)arg;
+	assert(m);
+	snd_seq_event_t *ev;
+	unsigned char work_buffer[MIDI_TRANSMIT_BUFFER_SIZE];
+	int bytes_to_send;
+	int b;
+	int i;
+
+	printMessage("MIDI queue thread started");
+
+	while(1) {
+		// get next event, if one is present
+		while ((snd_seq_event_input(m->seq_handle, &ev) > 0)) {
+			// get the port this event is originated from
+			ffado_midi_port_t *port=NULL;
+			for (i=0;i<m->nb_output_ports;i++) {
+				if(m->output_ports[i]->seq_port_nr == ev->dest.port) {
+					port=m->output_ports[i];
+					break;
+				}
+			}
+	
+			if(!port) {
+				printError(" Could not find target port for event: dst=%d src=%d", ev->dest.port, ev->source.port);
+
+				break;
+			}
+			
+			// decode it to the work buffer
+			if((bytes_to_send = snd_midi_event_decode ( port->parser, 
+				work_buffer,
+				MIDI_TRANSMIT_BUFFER_SIZE, 
+				ev))<0) 
+			{ // failed
+				printError(" Error decoding event for port %d (errcode=%d)", port->seq_port_nr,bytes_to_send);
+				bytes_to_send=0;
+				//return -1;
+			}
+	
+			for(b=0;b<bytes_to_send;b++) {
+				ffado_sample_t tmp_event=work_buffer[b];
+				if(ffado_streaming_write(m->dev, port->stream_nr, &tmp_event, 1)<1) {
+					printError(" Midi send buffer overrun");
+				}
+			}
+	
+		}
+
+		// sleep for some time
+		usleep(MIDI_THREAD_SLEEP_TIME_USECS);
+	}
+	return NULL;
+}
+
+// the dequeue thread (maybe we need one thread per stream)
+void *ffado_driver_midi_dequeue_thread (void *arg) {
+	ffado_driver_midi_handle_t *m=(ffado_driver_midi_handle_t *)arg;
+
+	int i;
+	int s;
+	
+	int samples_read;
+
+	assert(m);
+
+	while(1) {
+		// read incoming events
+	
+		for (i=0;i<m->nb_input_ports;i++) {
+			unsigned int buff[64];
+	
+			ffado_midi_port_t *port=m->input_ports[i];
+		
+			if(!port) {
+				printError(" something went wrong when setting up the midi input port map (%d)",i);
+			}
+		
+			do {
+				samples_read=ffado_streaming_read(m->dev, port->stream_nr, buff, 64);
+			
+				for (s=0;s<samples_read;s++) {
+					unsigned int *byte=(buff+s) ;
+					snd_seq_event_t ev;
+					if ((snd_midi_event_encode_byte(port->parser,(*byte) & 0xFF, &ev)) > 0) {
+						// a midi message is complete, send it out to ALSA
+						snd_seq_ev_set_subs(&ev);  
+						snd_seq_ev_set_direct(&ev);
+						snd_seq_ev_set_source(&ev, port->seq_port_nr);
+						snd_seq_event_output_direct(port->seq_handle, &ev);						
+					}
+				}
+			} while (samples_read>0);
+		}
+
+		// sleep for some time
+		usleep(MIDI_THREAD_SLEEP_TIME_USECS);
+	}
+	return NULL;
+}
+
+static ffado_driver_midi_handle_t *ffado_driver_midi_init(ffado_driver_t *driver) {
+// 	int err;
+
+	char buf[256];
+	channel_t chn;
+	int nchannels;
+	int i=0;
+
+	ffado_device_t *dev=driver->dev;
+
+	assert(dev);
+
+	ffado_driver_midi_handle_t *m=calloc(1,sizeof(ffado_driver_midi_handle_t));
+	if (!m) {
+		printError("not enough memory to create midi structure");
+		return NULL;
+	}
+
+	if (snd_seq_open(&m->seq_handle, "default", SND_SEQ_OPEN_DUPLEX, SND_SEQ_NONBLOCK) < 0) {
+		printError("Error opening ALSA sequencer.");
+		free(m);
+		return NULL;
+	}
+
+	snd_seq_set_client_name(m->seq_handle, "FreeBoB Jack MIDI");
+
+	// find out the number of midi in/out ports we need to setup
+	nchannels=ffado_streaming_get_nb_capture_streams(dev);
+
+	m->nb_input_ports=0;
+
+	for (chn = 0; chn < nchannels; chn++) {	
+		if(ffado_streaming_get_capture_stream_type(dev, chn) == ffado_stream_type_midi) {
+			m->nb_input_ports++;
+		}
+	}
+
+	m->input_ports=calloc(m->nb_input_ports,sizeof(ffado_midi_port_t *));
+	if(!m->input_ports) {
+		printError("not enough memory to create midi structure");
+		free(m);
+		return NULL;
+	}
+
+	i=0;
+	for (chn = 0; chn < nchannels; chn++) {
+		if(ffado_streaming_get_capture_stream_type(dev, chn) == ffado_stream_type_midi) {
+			m->input_ports[i]=calloc(1,sizeof(ffado_midi_port_t));
+			if(!m->input_ports[i]) {
+				// fixme
+				printError("Could not allocate memory for seq port");
+				continue;
+			}
+
+	 		ffado_streaming_get_capture_stream_name(dev, chn, buf, sizeof(buf) - 1);
+			printMessage("Register MIDI IN port %s", buf);
+
+			m->input_ports[i]->seq_port_nr=snd_seq_create_simple_port(m->seq_handle, buf,
+				SND_SEQ_PORT_CAP_READ|SND_SEQ_PORT_CAP_SUBS_READ,
+				SND_SEQ_PORT_TYPE_MIDI_GENERIC);
+
+			if(m->input_ports[i]->seq_port_nr<0) {
+				printError("Could not create seq port");
+				m->input_ports[i]->stream_nr=-1;
+				m->input_ports[i]->seq_port_nr=-1;
+			} else {
+				m->input_ports[i]->stream_nr=chn;
+				m->input_ports[i]->seq_handle=m->seq_handle;
+				if (snd_midi_event_new  ( ALSA_SEQ_BUFF_SIZE, &(m->input_ports[i]->parser)) < 0) {
+					printError("could not init parser for MIDI IN port %d",i);
+					m->input_ports[i]->stream_nr=-1;
+					m->input_ports[i]->seq_port_nr=-1;
+				} else {
+					if(ffado_streaming_set_capture_buffer_type(dev, chn, ffado_buffer_type_midi)) {
+						printError(" cannot set port buffer type for %s", buf);
+						m->input_ports[i]->stream_nr=-1;
+						m->input_ports[i]->seq_port_nr=-1;
+					}
+					if(ffado_streaming_capture_stream_onoff(dev, chn, 1)) {
+						printError(" cannot enable port %s", buf);
+						m->input_ports[i]->stream_nr=-1;
+						m->input_ports[i]->seq_port_nr=-1;
+					}
+
+				}
+			}
+
+			i++;
+		}
+	}
+
+	// playback
+	nchannels=ffado_streaming_get_nb_playback_streams(dev);
+
+	m->nb_output_ports=0;
+
+	for (chn = 0; chn < nchannels; chn++) {	
+		if(ffado_streaming_get_playback_stream_type(dev, chn) == ffado_stream_type_midi) {
+			m->nb_output_ports++;
+		}
+	}
+
+	m->output_ports=calloc(m->nb_output_ports,sizeof(ffado_midi_port_t *));
+	if(!m->output_ports) {
+		printError("not enough memory to create midi structure");
+		for (i = 0; i < m->nb_input_ports; i++) {	
+			free(m->input_ports[i]);
+		}
+		free(m->input_ports);
+		free(m);
+		return NULL;
+	}
+
+	i=0;
+	for (chn = 0; chn < nchannels; chn++) {
+		if(ffado_streaming_get_playback_stream_type(dev, chn) == ffado_stream_type_midi) {
+			m->output_ports[i]=calloc(1,sizeof(ffado_midi_port_t));
+			if(!m->output_ports[i]) {
+				// fixme
+				printError("Could not allocate memory for seq port");
+				continue;
+			}
+
+	 		ffado_streaming_get_playback_stream_name(dev, chn, buf, sizeof(buf) - 1);
+			printMessage("Register MIDI OUT port %s", buf);
+
+			m->output_ports[i]->seq_port_nr=snd_seq_create_simple_port(m->seq_handle, buf,
+				SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE,
+              			SND_SEQ_PORT_TYPE_MIDI_GENERIC);
+
+
+			if(m->output_ports[i]->seq_port_nr<0) {
+				printError("Could not create seq port");
+				m->output_ports[i]->stream_nr=-1;
+				m->output_ports[i]->seq_port_nr=-1;
+			} else {
+				m->output_ports[i]->stream_nr=chn;
+				m->output_ports[i]->seq_handle=m->seq_handle;
+				if (snd_midi_event_new  ( ALSA_SEQ_BUFF_SIZE, &(m->output_ports[i]->parser)) < 0) {
+					printError("could not init parser for MIDI OUT port %d",i);
+					m->output_ports[i]->stream_nr=-1;
+					m->output_ports[i]->seq_port_nr=-1;
+				} else {
+					if(ffado_streaming_set_playback_buffer_type(dev, chn, ffado_buffer_type_midi)) {
+						printError(" cannot set port buffer type for %s", buf);
+						m->input_ports[i]->stream_nr=-1;
+						m->input_ports[i]->seq_port_nr=-1;
+					}
+					if(ffado_streaming_playback_stream_onoff(dev, chn, 1)) {
+						printError(" cannot enable port %s", buf);
+						m->input_ports[i]->stream_nr=-1;
+						m->input_ports[i]->seq_port_nr=-1;
+					}
+				}
+			}
+
+			i++;
+		}
+	}
+
+	m->dev=dev;
+	m->driver=driver;
+
+	return m;
+}
+
+static int
+ffado_driver_midi_start (ffado_driver_midi_handle_t *m)
+{
+	assert(m);
+	// start threads
+
+	m->queue_thread_realtime=(m->driver->engine->control->real_time? 1 : 0);
+ 	m->queue_thread_priority=
+		m->driver->engine->control->client_priority +
+		FFADO_RT_PRIORITY_MIDI_RELATIVE;
+
+	if (m->queue_thread_priority>98) {
+		m->queue_thread_priority=98;
+	}
+	if (m->queue_thread_realtime) {
+		printMessage("MIDI threads running with Realtime scheduling, priority %d",
+		           m->queue_thread_priority);
+	} else {
+		printMessage("MIDI threads running without Realtime scheduling");
+	}
+
+	if (jack_client_create_thread(NULL, &m->queue_thread, m->queue_thread_priority, m->queue_thread_realtime, ffado_driver_midi_queue_thread, (void *)m)) {
+		printError(" cannot create midi queueing thread");
+		return -1;
+	}
+
+	if (jack_client_create_thread(NULL, &m->dequeue_thread, m->queue_thread_priority, m->queue_thread_realtime, ffado_driver_midi_dequeue_thread, (void *)m)) {
+		printError(" cannot create midi dequeueing thread");
+		return -1;
+	}
+	return 0;
+}
+
+static int
+ffado_driver_midi_stop (ffado_driver_midi_handle_t *m)
+{
+	assert(m);
+
+	pthread_cancel (m->queue_thread);
+	pthread_join (m->queue_thread, NULL);
+
+	pthread_cancel (m->dequeue_thread);
+	pthread_join (m->dequeue_thread, NULL);
+	return 0;
+
+}
+
+static void
+ffado_driver_midi_finish (ffado_driver_midi_handle_t *m)
+{
+	assert(m);
+
+	int i;
+	// TODO: add state info here, if not stopped then stop
+
+	for (i=0;i<m->nb_input_ports;i++) {
+		free(m->input_ports[i]);
+
+	}
+	free(m->input_ports);
+
+	for (i=0;i<m->nb_output_ports;i++) {
+		free(m->output_ports[i]);
+	}
+	free(m->output_ports);
+
+	free(m);
+}
+#endif	
+/*
+ * dlopen plugin stuff
+ */
+
+const char driver_client_name[] = "firewire_pcm";
+
+const jack_driver_desc_t *
+driver_get_descriptor ()
+{
+	jack_driver_desc_t * desc;
+	jack_driver_param_desc_t * params;
+	unsigned int i;
+
+	desc = calloc (1, sizeof (jack_driver_desc_t));
+
+	strcpy (desc->name, "firewire");
+	desc->nparams = 8;
+  
+	params = calloc (desc->nparams, sizeof (jack_driver_param_desc_t));
+	desc->params = params;
+
+	i = 0;
+	strcpy (params[i].name, "device");
+	params[i].character  = 'd';
+	params[i].type       = JackDriverParamString;
+	strcpy (params[i].value.str,  "hw:0");
+	strcpy (params[i].short_desc, "The FireWire device to use. Format is: 'hw:port[,node]'.");
+	strcpy (params[i].long_desc,  params[i].short_desc);
+	
+	i++;
+	strcpy (params[i].name, "period");
+	params[i].character  = 'p';
+	params[i].type       = JackDriverParamUInt;
+	params[i].value.ui   = 1024;
+	strcpy (params[i].short_desc, "Frames per period");
+	strcpy (params[i].long_desc, params[i].short_desc);
+	
+	i++;
+	strcpy (params[i].name, "nperiods");
+	params[i].character  = 'n';
+	params[i].type       = JackDriverParamUInt;
+	params[i].value.ui   = 3;
+	strcpy (params[i].short_desc, "Number of periods of playback latency");
+	strcpy (params[i].long_desc, params[i].short_desc);
+
+	i++;
+	strcpy (params[i].name, "rate");
+	params[i].character  = 'r';
+	params[i].type       = JackDriverParamUInt;
+	params[i].value.ui   = 48000U;
+	strcpy (params[i].short_desc, "Sample rate");
+	strcpy (params[i].long_desc, params[i].short_desc);
+
+	i++;
+	strcpy (params[i].name, "capture");
+	params[i].character  = 'i';
+	params[i].type       = JackDriverParamUInt;
+	params[i].value.ui   = 1U;
+	strcpy (params[i].short_desc, "Provide capture ports.");
+	strcpy (params[i].long_desc, params[i].short_desc);
+
+	i++;
+	strcpy (params[i].name, "playback");
+	params[i].character  = 'o';
+	params[i].type       = JackDriverParamUInt;
+	params[i].value.ui   = 1U;
+	strcpy (params[i].short_desc, "Provide playback ports.");
+	strcpy (params[i].long_desc, params[i].short_desc);
+
+	i++;
+	strcpy (params[i].name, "slave");
+	params[i].character  = 'x';
+	params[i].type       = JackDriverParamUInt;
+	params[i].value.ui   = 0U;
+	strcpy (params[i].short_desc, "Act as a BounceDevice slave");
+	strcpy (params[i].long_desc, params[i].short_desc);
+
+	i++;
+	strcpy (params[i].name, "slave");
+	params[i].character  = 'X';
+	params[i].type       = JackDriverParamUInt;
+	params[i].value.ui   = 0U;
+	strcpy (params[i].short_desc, "Operate in snoop mode");
+	strcpy (params[i].long_desc, params[i].short_desc);
+
+	return desc;
+}
+
+
+jack_driver_t *
+driver_initialize (jack_client_t *client, JSList * params)
+{
+	jack_driver_t *driver;
+
+    unsigned int port=0;
+    unsigned int node_id=-1;
+    int nbitems;
+      
+	const JSList * node;
+	const jack_driver_param_t * param;
+
+	ffado_jack_settings_t cmlparams;
+	
+    char *device_name="hw:0"; 
+      
+	cmlparams.period_size_set=0;
+	cmlparams.sample_rate_set=0;
+	cmlparams.buffer_size_set=0;
+	cmlparams.port_set=0;
+	cmlparams.node_id_set=0;
+
+	/* default values */
+	cmlparams.period_size=1024;
+	cmlparams.sample_rate=48000;
+	cmlparams.buffer_size=3;
+	cmlparams.port=0;
+	cmlparams.node_id=-1;
+	cmlparams.playback_ports=1;
+	cmlparams.capture_ports=1;
+	cmlparams.slave_mode=0;
+	cmlparams.snoop_mode=0;
+	
+	for (node = params; node; node = jack_slist_next (node))
+	{
+		param = (jack_driver_param_t *) node->data;
+
+		switch (param->character)
+		{
+		case 'd':
+			device_name = strdup (param->value.str);
+			break;
+		case 'p':
+			cmlparams.period_size = param->value.ui;
+			cmlparams.period_size_set = 1;
+			break;
+		case 'n':
+			cmlparams.buffer_size = param->value.ui;
+			cmlparams.buffer_size_set = 1;
+			break;        
+		case 'r':
+			cmlparams.sample_rate = param->value.ui;
+			cmlparams.sample_rate_set = 1;
+			break;
+		case 'i':
+			cmlparams.capture_ports = param->value.ui;
+			break;
+		case 'o':
+			cmlparams.playback_ports = param->value.ui;
+			break;
+		case 'x':
+			cmlparams.slave_mode = param->value.ui;
+			break;
+		case 'X':
+			cmlparams.snoop_mode = param->value.ui;
+			break;
+		}
+	}
+	
+    nbitems=sscanf(device_name,"hw:%u,%u",&port,&node_id);
+    if (nbitems<2) {
+        nbitems=sscanf(device_name,"hw:%u",&port);
+      
+        if(nbitems < 1) {
+            free(device_name);
+            printError("device (-d) argument not valid\n");
+            return NULL;
+        } else {
+            cmlparams.port = port;
+            cmlparams.port_set=1;
+            
+            cmlparams.node_id = -1;
+            cmlparams.node_id_set=0;
+        }
+     } else {
+        cmlparams.port = port;
+        cmlparams.port_set=1;
+        
+        cmlparams.node_id = node_id;
+        cmlparams.node_id_set=1;
+     }
+
+    jack_error("Freebob using Firewire port %d, node %d",cmlparams.port,cmlparams.node_id);
+    
+	driver=(jack_driver_t *)ffado_driver_new (client, "ffado_pcm", &cmlparams);
+
+	return driver;
+}
+
+void
+driver_finish (jack_driver_t *driver)
+{
+	ffado_driver_t *drv=(ffado_driver_t *) driver;
+	// If jack hasn't called the detach method, do it now.  As of jack 0.101.1
+	// the detach method was not being called explicitly on closedown, and 
+	// we need it to at least deallocate the iso resources.
+	if (drv->dev != NULL)
+		ffado_driver_detach(drv);
+	ffado_driver_delete (drv);
+}
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/firewire/ffado_driver.h jack/drivers/firewire/ffado_driver.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/firewire/ffado_driver.h	1970-01-01 07:00:00.000000000 +0700
+++ jack/drivers/firewire/ffado_driver.h	2007-08-25 15:30:46.000000000 +0700
@@ -0,0 +1,244 @@
+/*
+ *   FireWire Backend for Jack
+ *   using FFADO
+ *   FFADO = Firewire (pro-)audio for linux
+ *
+ *   http://www.ffado.org
+ *   http://www.jackaudio.org
+ *
+ *   Copyright (C) 2005-2007 Pieter Palmers
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* 
+ * Main Jack driver entry routines
+ *
+ */ 
+ 
+#ifndef __JACK_FFADO_DRIVER_H__
+#define __JACK_FFADO_DRIVER_H__
+
+#define FFADO_DRIVER_WITH_ASEQ_MIDI
+
+#include <libffado/ffado.h>
+
+#include <jack/driver.h>
+#include <jack/engine.h>
+#include <jack/types.h>
+
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <stdio.h>
+#include <poll.h>
+#include <sys/time.h>
+#include <netinet/in.h>
+#include <endian.h>
+
+#include <pthread.h>
+#include <semaphore.h>
+
+#include <jack/internal.h>
+#include <jack/types.h>
+#include <jack/ringbuffer.h>
+#include <jack/driver.h>
+#include <jack/engine.h>
+#include <jack/types.h>
+#include <jack/thread.h>
+
+#include <alsa/asoundlib.h>
+
+// debug print control flags
+#define DEBUG_LEVEL_BUFFERS           	(1<<0)
+#define DEBUG_LEVEL_HANDLERS			(1<<1)
+#define DEBUG_LEVEL_XRUN_RECOVERY     	(1<<2)
+#define DEBUG_LEVEL_WAIT     			(1<<3)
+
+#define DEBUG_LEVEL_RUN_CYCLE         	(1<<8)
+
+#define DEBUG_LEVEL_PACKETCOUNTER		(1<<16)
+#define DEBUG_LEVEL_STARTUP				(1<<17)
+#define DEBUG_LEVEL_THREADS				(1<<18)
+
+
+#ifdef DEBUG_ENABLED
+
+	// default debug level
+	#define DEBUG_LEVEL (  DEBUG_LEVEL_RUN_CYCLE | \
+	(DEBUG_LEVEL_XRUN_RECOVERY)| DEBUG_LEVEL_STARTUP | DEBUG_LEVEL_WAIT | DEBUG_LEVEL_PACKETCOUNTER)
+
+	#warning Building debug build!
+
+	#define printMessage(format, args...) jack_error( "FreeBoB MSG: %s:%d (%s): " format,  __FILE__, __LINE__, __FUNCTION__, ##args )
+	#define printError(format, args...) jack_error( "FreeBoB ERR: %s:%d (%s): " format,  __FILE__, __LINE__, __FUNCTION__, ##args )
+	
+	//#define printEnter() jack_error( "FBDRV ENTERS: %s (%s)\n", __FUNCTION__,  __FILE__)
+	//#define printExit() jack_error( "FBDRV EXITS: %s (%s)\n", __FUNCTION__,  __FILE__)
+	#define printEnter() 
+	#define printExit() 
+	
+	#define debugError(format, args...) jack_error( "FREEBOB ERR: %s:%d (%s): " format,  __FILE__, __LINE__, __FUNCTION__, ##args )
+	#define debugPrint(Level, format, args...) if(DEBUG_LEVEL & (Level))  jack_error("DEBUG %s:%d (%s) :"  format, __FILE__, __LINE__, __FUNCTION__, ##args );
+	#define debugPrintShort(Level, format, args...) if(DEBUG_LEVEL & (Level))  jack_error( format,##args );
+	#define debugPrintWithTimeStamp(Level, format, args...) if(DEBUG_LEVEL & (Level)) jack_error( "%16lu: "format, debugGetCurrentUTime(),##args );
+	#define SEGFAULT int *test=NULL;	*test=1;
+#else
+	#define DEBUG_LEVEL
+	
+	#define printMessage(format, args...) if(g_verbose) \
+	                                         jack_error("FreeBoB MSG: " format, ##args )
+	#define printError(format, args...)   jack_error("FreeBoB ERR: " format, ##args )
+	
+	#define printEnter() 
+	#define printExit() 
+	
+	#define debugError(format, args...) 
+	#define debugPrint(Level, format, args...) 
+	#define debugPrintShort(Level, format, args...)	
+	#define debugPrintWithTimeStamp(Level, format, args...)
+#endif
+
+// thread priority setup
+#define FFADO_RT_PRIORITY_PACKETIZER_RELATIVE	5
+
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+
+	#define ALSA_SEQ_BUFF_SIZE 1024
+	#define MIDI_TRANSMIT_BUFFER_SIZE 1024
+	#define MIDI_THREAD_SLEEP_TIME_USECS 100
+	// midi priority should be higher than the audio priority in order to
+	// make sure events are not only delivered on period boundarys
+	// but I think it should be smaller than the packetizer thread in order not 
+	// to lose any packets
+	#define FFADO_RT_PRIORITY_MIDI_RELATIVE 	4
+
+#endif
+
+typedef struct _ffado_driver ffado_driver_t;
+
+/*
+ * Jack Driver command line parameters
+ */
+
+typedef struct _ffado_jack_settings ffado_jack_settings_t;
+struct _ffado_jack_settings {
+    int period_size_set;
+    jack_nframes_t period_size;
+    
+    int sample_rate_set;
+    int sample_rate;
+    
+    int buffer_size_set;
+    jack_nframes_t buffer_size;
+    
+    int port_set;
+    int port;
+   
+    int node_id_set;
+    int node_id;
+    
+    int playback_ports;
+    int capture_ports;
+    
+    int slave_mode;
+    int snoop_mode;
+    
+    ffado_handle_t fb_handle;
+};
+
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+
+typedef struct {
+	int stream_nr;
+	int seq_port_nr;
+	snd_midi_event_t *parser;
+	snd_seq_t *seq_handle;
+} ffado_midi_port_t;
+
+typedef struct _ffado_driver_midi_handle {
+	ffado_device_t *dev;
+	ffado_driver_t *driver;
+
+	snd_seq_t *seq_handle;
+	
+	pthread_t queue_thread;
+	pthread_t dequeue_thread;
+	int queue_thread_realtime;
+	int queue_thread_priority;
+
+	int nb_input_ports;
+	int nb_output_ports;
+
+	ffado_midi_port_t **input_ports;
+	ffado_midi_port_t **output_ports;
+
+	ffado_midi_port_t **input_stream_port_map;
+	int *output_port_stream_map;
+
+
+} ffado_driver_midi_handle_t;
+
+#endif
+/*
+ * JACK driver structure
+ */
+ 
+
+struct _ffado_driver
+{
+	JACK_DRIVER_NT_DECL
+	
+	jack_nframes_t  sample_rate;
+	jack_nframes_t  period_size;
+	unsigned long   wait_time;
+
+    jack_time_t                   wait_last;
+    jack_time_t                   wait_next;
+	int wait_late;
+	
+	jack_client_t  *client;
+	
+	int		xrun_detected;
+	int		xrun_count;
+	
+	int process_count;
+	
+	/* settings from the command line */
+	ffado_jack_settings_t settings;
+	
+	/* the freebob virtual device */
+	ffado_device_t *dev;
+	
+    JSList                       *capture_ports;
+    JSList                       *playback_ports;
+    JSList                       *monitor_ports;
+    channel_t                     playback_nchannels;
+    channel_t                     capture_nchannels;
+    	
+	ffado_device_info_t device_info;
+	ffado_options_t device_options;
+
+#ifdef FFADO_DRIVER_WITH_ASEQ_MIDI
+	ffado_driver_midi_handle_t *midi_handle;
+#endif
+
+}; 
+
+
+
+#endif /* __JACK_FFADO_DRIVER_H__ */
+
+
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/freebob/Makefile.am jack/drivers/freebob/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/drivers/freebob/Makefile.am	2006-05-26 09:45:26.000000000 +0700
+++ jack/drivers/freebob/Makefile.am	2007-08-25 15:30:45.000000000 +0700
@@ -8,7 +8,12 @@
 
 jack_freebob_la_SOURCES = freebob_driver.c
 
-jack_freebob_la_LIBADD = $(LIBFREEBOB_LIBS) $(ALSA_LIBS)
+jack_freebob_la_LIBADD = $(LIBFREEBOB_LIBS) $(ALSA_LIBS) 
+
+if HAVE_ALSA_MIDI
+jack_freebob_la_SOURCES += ../alsa-midi/alsa_rawmidi.c ../alsa-midi/alsa_seqmidi.c
+jack_freebob_la_CFLAGS = -I../alsa-midi
+endif
 
 jack_freebob_la_LDFLAGS = -module -avoid-version
 
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/freebob/freebob_driver.c jack/drivers/freebob/freebob_driver.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/freebob/freebob_driver.c	2007-03-06 12:24:05.000000000 +0700
+++ jack/drivers/freebob/freebob_driver.c	2007-08-25 15:30:45.000000000 +0700
@@ -5,7 +5,7 @@
  *   http://freebob.sf.net
  *   http://jackit.sf.net
  *
- *   Copyright (C) 2005 Pieter Palmers <pieterpalmers@users.sourceforge.net>
+ *   Copyright (C) 2005-2007 Pieter Palmers <pieter.palmers@ffado.org>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -50,7 +50,7 @@
 
 static int freebob_driver_stop (freebob_driver_t *driver);
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 	static freebob_driver_midi_handle_t *freebob_driver_midi_init(freebob_driver_t *driver);
 	static void freebob_driver_midi_finish (freebob_driver_midi_handle_t *m);
 	static int freebob_driver_midi_start (freebob_driver_midi_handle_t *m);
@@ -64,9 +64,13 @@
 freebob_driver_attach (freebob_driver_t *driver)
 {
 	char buf[64];
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+	char buf2[64];
+#endif
 	channel_t chn;
 	jack_port_t *port=NULL;
 	int port_flags;
+	int error=0;
 
 	g_verbose=driver->engine->verbose;
 	driver->device_options.verbose=g_verbose;
@@ -90,7 +94,7 @@
 		return -1;
 	}
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 	driver->midi_handle=freebob_driver_midi_init(driver);
 	if(!driver->midi_handle) {
 		printError("-----------------------------------------------------------");
@@ -113,59 +117,117 @@
 
 	driver->capture_nchannels=freebob_streaming_get_nb_capture_streams(driver->dev);
 
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+	// allocate midi structures
+	driver->midi_in_ports=calloc(driver->capture_nchannels, sizeof(freebob_midi_input_port_t));
+	if (driver->midi_in_ports == NULL) return -ENOMEM;
+#endif
+
 	for (chn = 0; chn < driver->capture_nchannels; chn++) {
-		
+		error=0;
+
 		freebob_streaming_get_capture_stream_name(driver->dev, chn, buf, sizeof(buf) - 1);
-		
-		if(freebob_streaming_get_capture_stream_type(driver->dev, chn) != freebob_stream_type_audio) {
-			printMessage ("Don't register capture port %s", buf);
-// 			continue;
-			// we have to add a NULL entry in the list to be able to loop over the channels in the read/write routines
-			driver->capture_ports =
-				jack_slist_append (driver->capture_ports, NULL);
-		} else {
-			printMessage ("Registering capture port %s", buf);
+		switch(freebob_streaming_get_capture_stream_type(driver->dev, chn)) {
+		case freebob_stream_type_audio:
+			printMessage ("Registering audio capture port %s", buf);
 			if ((port = jack_port_register (driver->client, buf,
 							JACK_DEFAULT_AUDIO_TYPE,
 							port_flags, 0)) == NULL) {
 				printError (" cannot register port for %s", buf);
+				error=1;
+				break;
+			}
+			driver->capture_ports =
+				jack_slist_append (driver->capture_ports, port);
+			break;
+
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+		case freebob_stream_type_midi:
+			snprintf(buf2, 64, "midiin%d_%s",(int)chn,buf); // needed to avoid duplicate names
+			printMessage ("Registering midi capture port %s", buf2);
+			if ((port = jack_port_register (driver->client, buf2,
+							JACK_DEFAULT_MIDI_TYPE,
+							port_flags, 0)) == NULL) {
+				printError (" cannot register port for %s", buf2);
+				error=1;
 				break;
 			}
+
+			// init the midi unpacker for this port
+			midi_unpack_init(&driver->midi_in_ports[chn].unpack);
+
 			driver->capture_ports =
 				jack_slist_append (driver->capture_ports, port);
+			break;
+#endif
+
+		default:
+			printMessage ("Don't register capture port for %s", buf);
+			// we have to add a NULL entry in the list to be able to loop over the channels in the read/write routines
+			driver->capture_ports =
+				jack_slist_append (driver->capture_ports, NULL);
+			break;
 		}
 
-		jack_port_set_latency (port, driver->period_size + driver->capture_frame_latency);
+		if(error) break;
 
+		jack_port_set_latency (port, driver->period_size + driver->capture_frame_latency);
 	}
 	
 	port_flags = JackPortIsInput|JackPortIsPhysical|JackPortIsTerminal;
 
 	driver->playback_nchannels=freebob_streaming_get_nb_playback_streams(driver->dev);
 
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+	// allocate midi structures
+	driver->midi_out_ports=calloc(driver->playback_nchannels, sizeof(freebob_midi_output_port_t));
+	if (driver->midi_out_ports == NULL) return -ENOMEM;
+#endif
+
 	for (chn = 0; chn < driver->playback_nchannels; chn++) {
+		error=0;
 
 		freebob_streaming_get_playback_stream_name(driver->dev, chn, buf, sizeof(buf) - 1);
 		
-		if(freebob_streaming_get_playback_stream_type(driver->dev, chn) != freebob_stream_type_audio) {
-			printMessage ("Don't register playback port %s", buf);
-// 			continue;
-			// we have to add a NULL entry in the list to be able to loop over the channels in the read/write routines
-			driver->playback_ports =
-				jack_slist_append (driver->playback_ports, NULL);
-		} else {
-			printMessage ("Registering playback port %s", buf);
+		switch(freebob_streaming_get_playback_stream_type(driver->dev, chn)){
+		case freebob_stream_type_audio:
+			printMessage ("Registering playback audio port %s", buf);
 			if ((port = jack_port_register (driver->client, buf,
 							JACK_DEFAULT_AUDIO_TYPE,
 							port_flags, 0)) == NULL) {
 				printError(" cannot register port for %s", buf);
+				error=1;
 				break;
 			}
 			driver->playback_ports =
 				jack_slist_append (driver->playback_ports, port);
+			break;
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+		case freebob_stream_type_midi:
+			snprintf(buf2, 64, "midiout%d_%s",(int)chn,buf); // needed to avoid duplicate names
+			printMessage ("Registering playback midi port %s", buf2);
+			if ((port = jack_port_register (driver->client, buf2,
+							JACK_DEFAULT_MIDI_TYPE,
+							port_flags, 0)) == NULL) {
+				printError(" cannot register port for %s", buf2);
+				error=1;
+				break;
+			}
+
+			driver->playback_ports =
+				jack_slist_append (driver->playback_ports, port);
+			break;
+#endif
+		default:
+			printMessage ("Don't register playback port %s", buf);
+			// we have to add a NULL entry in the list to be able to loop over the channels in the read/write routines
+			driver->playback_ports =
+				jack_slist_append (driver->playback_ports, NULL);
 		}
-		jack_port_set_latency (port, (driver->period_size * (driver->device_options.nb_buffers - 1)) + driver->playback_frame_latency); 
 
+		if(error) break;
+
+		jack_port_set_latency (port, (driver->period_size * (driver->device_options.nb_buffers - 1)) + driver->playback_frame_latency); 
 	}
 
 	return jack_activate (driver->client);
@@ -182,8 +244,10 @@
 
 	for (node = driver->capture_ports; node && node->data;
 	     node = jack_slist_next (node)) {
-		jack_port_unregister (driver->client,
+		if(node->data != NULL) {
+			jack_port_unregister (driver->client,
 				      ((jack_port_t *) node->data));
+		}
 	}
 
 	jack_slist_free (driver->capture_ports);
@@ -191,8 +255,10 @@
 		
 	for (node = driver->playback_ports; node && node->data;
 	     node = jack_slist_next (node)) {
-		jack_port_unregister (driver->client,
+		if(node->data != NULL) {
+			jack_port_unregister (driver->client,
 				      ((jack_port_t *) node->data));
+		}
 	}
 
 	jack_slist_free (driver->playback_ports);
@@ -201,44 +267,18 @@
 	freebob_streaming_finish(driver->dev);
 	driver->dev=NULL;
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 	if(driver->midi_handle) {
 		freebob_driver_midi_finish(driver->midi_handle);	
 	}
 	driver->midi_handle=NULL;
 #endif
 
-	return 0;
-
-}
-
-static inline void 
-freebob_driver_read_from_channel (freebob_driver_t *driver,
-			       channel_t channel,
-			       jack_default_audio_sample_t *dst,
-			       jack_nframes_t nsamples)
-{
-	
-	freebob_sample_t buffer[nsamples];
-	char *src=(char *)buffer;
-	
-	freebob_streaming_read(driver->dev, channel, buffer, nsamples);
-	
-	/* ALERT: signed sign-extension portability !!! */
-
-	while (nsamples--) {
-		int x;
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-		memcpy((char*)&x + 1, src, 3);
-#elif __BYTE_ORDER == __BIG_ENDIAN
-		memcpy(&x, src, 3);
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+	free(driver->midi_in_ports);
+	free(driver->midi_out_ports);
 #endif
-		x >>= 8;
-		*dst = x / SAMPLE_MAX_24BIT;
-		dst++;
-		src += sizeof(freebob_sample_t);
-	}
-	
+	return 0;
 }
 
 static int
@@ -260,14 +300,44 @@
 		stream_type = freebob_streaming_get_capture_stream_type(driver->dev, chn);
 		if(stream_type == freebob_stream_type_audio) {
 			port = (jack_port_t *) node->data;
-
 			buf = jack_port_get_buffer (port, nframes);
+
 			if(!buf) buf=(jack_default_audio_sample_t *)addr_of_nullbuffer;
 				
-			freebob_streaming_set_capture_stream_buffer(driver->dev, chn, (char *)(buf), freebob_buffer_type_float);
+			freebob_streaming_set_capture_stream_buffer(
+				driver->dev, chn, (char *)(buf), freebob_buffer_type_float);
+
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
 		} else if(stream_type == freebob_stream_type_midi) {
-			// these should be read/written with the per-stream functions
+			unsigned int midibuff[64];
+			unsigned char midibuff2[64];
+			int samples_read;
+
+			port = (jack_port_t *) node->data;
+			buf = jack_port_get_buffer (port, nframes);
+
+			jack_midi_clear_buffer(buf);
+
+			samples_read=freebob_streaming_read(
+				driver->dev, chn, midibuff, 64);
+
+			while(samples_read) {
+				int idx;
+				int done;
+				//printMessage("MIDI: ");
+				for (idx=0;idx<samples_read;idx++) {
+					midibuff2[idx]=(unsigned char)(midibuff[idx] & 0xFF);
+					//printMessage(" %02X", midibuff2[idx]);
+				}
 
+				done = midi_unpack_buf(
+					&driver->midi_in_ports[chn].unpack,
+					midibuff2, samples_read, buf, 0 /* time */);
+
+				samples_read=freebob_streaming_read(
+					driver->dev, chn, midibuff, 64);
+			}
+#endif
 		} else { // empty other buffers without doing something with them
 			freebob_streaming_set_capture_stream_buffer(driver->dev, chn, (char *)(nullbuffer), freebob_buffer_type_uint24);
 		}
@@ -279,41 +349,6 @@
 	printExit();
 	
 	return 0;
-
-}
-
-static inline void 
-freebob_driver_write_to_channel (freebob_driver_t *driver,
-			      channel_t channel, 
-			      jack_default_audio_sample_t *buf, 
-			      jack_nframes_t nsamples)
-{
-    long long y;
-	freebob_sample_t buffer[nsamples];
-	unsigned int i=0;	
-    char *dst=(char *)buffer;
-	
-	// convert from float to integer
-	for(;i<nsamples;i++) {
-		y = (long long)(*buf * SAMPLE_MAX_24BIT);
-
-		if (y > (INT_MAX >> 8 )) {
-			y = (INT_MAX >> 8);
-		} else if (y < (INT_MIN >> 8 )) {
-			y = (INT_MIN >> 8 );
-		}
-#if __BYTE_ORDER == __LITTLE_ENDIAN
-		memcpy (dst, &y, 3);
-#elif __BYTE_ORDER == __BIG_ENDIAN
-		memcpy (dst, (char *)&y + 5, 3);
-#endif
-		dst += sizeof(freebob_sample_t);
-		buf++;
-	}
-	
-	// write to the freebob streaming device
-	freebob_streaming_write(driver->dev, channel, buffer, nsamples);
-	
 }
 
 static int
@@ -352,9 +387,41 @@
 				
 			freebob_streaming_set_playback_stream_buffer(driver->dev, chn, (char *)(buf), freebob_buffer_type_float);
 
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
 		} else if(stream_type == freebob_stream_type_midi) {
-			// these should be read/written with the per-stream functions
+			int i,idx;
+			int samples_written;
 
+			port = (jack_port_t *) node->data;
+			buf = jack_port_get_buffer (port, nframes);
+
+			int nevents = jack_midi_get_event_count(buf);
+
+			if (nevents)
+				printMessage("jack_out: %d events\n", nevents);
+			for (i=0; i<nevents; ++i) {
+				jack_midi_event_t event;
+		
+				jack_midi_event_get(&event, buf, i);
+		
+				midi_pack_event(&driver->midi_out_ports[chn].packer, &event);
+
+				freebob_sample_t midibuff[event.size];
+				for (idx=0;idx<event.size;idx++) {
+					midibuff[idx]=(freebob_sample_t)(event.buffer[idx]);
+				}
+
+				samples_written=freebob_streaming_write(
+					driver->dev, chn, midibuff, event.size);
+
+				if (samples_written!=event.size) {
+					printMessage("midi out: buffer overrun\n");
+					break;
+				} else {
+					printMessage("midi out: sent %d-byte event at %ld\n", (int)event.size, (long)event.time);
+				}
+			}
+#endif
 		} else { // empty other buffers without doing something with them
 			freebob_streaming_set_playback_stream_buffer(driver->dev, chn, (char *)(nullbuffer), freebob_buffer_type_uint24);
 		}
@@ -442,10 +509,27 @@
 	}
 		
 	if ((nframes == 0)) {
+		int chn;
+		chn=0; // avoid unused variable warning when compiling without jack midi
+
 		/* we detected an xrun and restarted: notify
 		 * clients about the delay. */
 		printMessage("xrun detected");
 		engine->delay (engine, delayed_usecs);
+
+		// reset the midi stuff
+		#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+			for (chn = 0; chn < driver->capture_nchannels; chn++) {
+				// init the midi unpacker for this port
+				midi_unpack_reset(&driver->midi_in_ports[chn].unpack);
+			}
+			
+			for (chn = 0; chn < driver->playback_nchannels; chn++) {
+				// init the midi unpacker for this port
+				midi_pack_reset(&driver->midi_out_ports[chn].packer);
+			}
+		#endif
+
 		return 0;
 	} 
 	
@@ -519,8 +603,10 @@
 freebob_driver_start (freebob_driver_t *driver)
 {
 	int retval=0;
+	int chn;
+	chn=0; // avoid unused variable warning when compiling without jack midi
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 	if(driver->midi_handle) {
 		if((retval=freebob_driver_midi_start(driver->midi_handle))) {
 			printError("Could not start MIDI threads");
@@ -529,13 +615,26 @@
 	}
 #endif	
 
+	// reset the midi stuff
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+	for (chn = 0; chn < driver->capture_nchannels; chn++) {
+		// init the midi unpacker for this port
+		midi_unpack_reset(&driver->midi_in_ports[chn].unpack);
+	}
+	
+	for (chn = 0; chn < driver->playback_nchannels; chn++) {
+		// init the midi unpacker for this port
+		midi_pack_reset(&driver->midi_out_ports[chn].packer);
+	}
+#endif
+
 	if((retval=freebob_streaming_start(driver->dev))) {
 		printError("Could not start streaming threads");
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 		if(driver->midi_handle) {
 			freebob_driver_midi_stop(driver->midi_handle);
 		}
-#endif	
+#endif
 		return retval;
 	}
 
@@ -548,7 +647,7 @@
 {
 	int retval=0;
 	
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 	if(driver->midi_handle) {
 		if((retval=freebob_driver_midi_stop(driver->midi_handle))) {
 			printError("Could not stop MIDI threads");
@@ -668,7 +767,7 @@
 	free (driver);
 }
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 /*
  * MIDI support
  */ 
@@ -690,6 +789,9 @@
 	while(1) {
 		// get next event, if one is present
 		while ((snd_seq_event_input(m->seq_handle, &ev) > 0)) {
+			if (ev->source.client == SND_SEQ_CLIENT_SYSTEM)
+				continue;
+
 			// get the port this event is originated from
 			freebob_midi_port_t *port=NULL;
 			for (i=0;i<m->nb_output_ports;i++) {
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/freebob/freebob_driver.h jack/drivers/freebob/freebob_driver.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/freebob/freebob_driver.h	2007-03-06 12:24:05.000000000 +0700
+++ jack/drivers/freebob/freebob_driver.h	2007-08-25 15:30:45.000000000 +0700
@@ -6,7 +6,7 @@
  *   http://freebob.sf.net
  *   http://jackit.sf.net
  *
- *   Copyright (C) 2005 Pieter Palmers <pieterpalmers@users.sourceforge.net>
+ *   Copyright (C) 2005-2007 Pieter Palmers <pieter.palmers@ffado.org>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -31,7 +31,19 @@
 #ifndef __JACK_FREEBOB_DRIVER_H__
 #define __JACK_FREEBOB_DRIVER_H__
 
-#define FREEBOB_DRIVER_WITH_MIDI
+// Only one of these !
+#define FREEBOB_DRIVER_WITH_ALSA_MIDI
+//#define FREEBOB_DRIVER_WITH_JACK_MIDI
+
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
+	#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+		#error "Can't have both ALSA midi and JACK midi defined for the FreeBoB backend"
+	#endif
+#endif
+
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+	#warning "JACK midi for FreeBoB is experimental and has severe jitter issues."
+#endif
 
 #include <libfreebob/freebob.h>
 #include <libfreebob/freebob_streaming.h>
@@ -52,11 +64,6 @@
 #include <jack/engine.h>
 #include <jack/types.h>
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
-#include <jack/thread.h>
-#include <alsa/asoundlib.h>
-#endif
-
 // debug print control flags
 #define DEBUG_LEVEL_BUFFERS           	(1<<0)
 #define DEBUG_LEVEL_HANDLERS			(1<<1)
@@ -110,18 +117,45 @@
 // thread priority setup
 #define FREEBOB_RT_PRIORITY_PACKETIZER_RELATIVE	5
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+// MIDI 
 
-	#define ALSA_SEQ_BUFF_SIZE 1024
-	#define MIDI_TRANSMIT_BUFFER_SIZE 1024
-	#define MIDI_THREAD_SLEEP_TIME_USECS 100
-	// midi priority should be higher than the audio priority in order to
-	// make sure events are not only delivered on period boundarys
-	// but I think it should be smaller than the packetizer thread in order not 
-	// to lose any packets
-	#define FREEBOB_RT_PRIORITY_MIDI_RELATIVE 	4
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
+
+#include <jack/thread.h>
+#include <alsa/asoundlib.h>
+
+#define ALSA_SEQ_BUFF_SIZE 1024
+#define MIDI_TRANSMIT_BUFFER_SIZE 1024
+#define MIDI_THREAD_SLEEP_TIME_USECS 100
+// midi priority should be higher than the audio priority in order to
+// make sure events are not only delivered on period boundarys
+// but I think it should be smaller than the packetizer thread in order not 
+// to lose any packets
+#define FREEBOB_RT_PRIORITY_MIDI_RELATIVE 	4
+
+#endif // FREEBOB_DRIVER_WITH_ALSA_MIDI
+
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+
+#include "../alsa-midi/midi_pack.h"
+#include "../alsa-midi/midi_unpack.h"
+#include <jack/midiport.h>
+
+typedef struct freebob_midi_input_port_t {
+	// jack
+	midi_unpack_t unpack;
+	
+	// midi
+	int overruns;
+} freebob_midi_input_port_t;
+
+typedef struct freebob_midi_output_port_t {
+	// jack
+	midi_pack_t packer;
+} freebob_midi_output_port_t;
+
+#endif // FREEBOB_DRIVER_WITH_JACK_MIDI
 
-#endif
 
 typedef struct _freebob_driver freebob_driver_t;
 
@@ -155,7 +189,7 @@
 	freebob_handle_t fb_handle;
 };
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 
 
 typedef struct {
@@ -202,8 +236,8 @@
 	jack_nframes_t  period_size;
 	unsigned long   wait_time;
 
-    jack_time_t                   wait_last;
-    jack_time_t                   wait_next;
+	jack_time_t                   wait_last;
+	jack_time_t                   wait_next;
 	int wait_late;
 	
 	jack_client_t  *client;
@@ -219,11 +253,11 @@
 	/* the freebob virtual device */
 	freebob_device_t *dev;
 	
-    JSList                       *capture_ports;
-    JSList                       *playback_ports;
-    JSList                       *monitor_ports;
-    channel_t                     playback_nchannels;
-    channel_t                     capture_nchannels;
+	JSList                       *capture_ports;
+	JSList                       *playback_ports;
+	JSList                       *monitor_ports;
+	channel_t                     playback_nchannels;
+	channel_t                     capture_nchannels;
 
 	jack_nframes_t  playback_frame_latency;
 	jack_nframes_t  capture_frame_latency;
@@ -231,10 +265,16 @@
 	freebob_device_info_t device_info;
 	freebob_options_t device_options;
 
-#ifdef FREEBOB_DRIVER_WITH_MIDI
+#ifdef FREEBOB_DRIVER_WITH_ALSA_MIDI
 	freebob_driver_midi_handle_t *midi_handle;
 #endif
 
+#ifdef FREEBOB_DRIVER_WITH_JACK_MIDI
+	freebob_midi_input_port_t  *midi_in_ports;
+	freebob_midi_output_port_t *midi_out_ports;
+#endif
+
+
 }; 
 
 
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/oss/oss_driver.c jack/drivers/oss/oss_driver.c
--- jack-audio-connection-kit-0.103.0.orig/drivers/oss/oss_driver.c	2006-05-26 09:45:26.000000000 +0700
+++ jack/drivers/oss/oss_driver.c	2007-08-25 15:30:45.000000000 +0700
@@ -1,7 +1,7 @@
 /*
 
 	OSS driver for Jack
-	Copyright (C) 2003-2005 Jussi Laako <jussi@sonarnerd.net>
+	Copyright (C) 2003-2007 Jussi Laako <jussi@sonarnerd.net>
 
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -456,6 +456,7 @@
 			samplesize = sizeof(short);
 			break;
 	}
+	driver->trigger = 0;
 	if (strcmp(indev, outdev) != 0)
 	{
 		if (driver->capture_channels > 0)
@@ -529,6 +530,8 @@
 		}
 		if (infd >= 0 && outfd >= 0)
 		{
+			ioctl(outfd, SNDCTL_DSP_SETTRIGGER, &driver->trigger);
+			driver->trigger = (PCM_ENABLE_INPUT|PCM_ENABLE_OUTPUT);
 			if (ioctl(infd, SNDCTL_DSP_SETDUPLEX, 0) < 0)
 			{
 				if (errno != EINVAL) /* Dont care */
@@ -961,6 +964,13 @@
 				__FILE__, __LINE__);
 			return NULL;
 		}
+		if (driver->trigger)
+		{
+			/* don't care too much if this fails */
+			memset(localbuf, 0x00, localsize);
+			write(driver->outfd, localbuf, localsize);
+			ioctl(driver->outfd, SNDCTL_DSP_SETTRIGGER, &driver->trigger);
+		}
 
 		while (driver->run)
 		{
@@ -992,6 +1002,13 @@
 		jack_error("OSS: malloc() failed: %s@%i", __FILE__, __LINE__);
 		return NULL;
 	}
+	if (driver->trigger)
+	{
+		/* don't care too much if this fails */
+		memset(localbuf, 0x00, localsize);
+		write(driver->outfd, localbuf, driver->outdevbufsize);
+		ioctl(driver->outfd, SNDCTL_DSP_SETTRIGGER, &driver->trigger);
+	}
 
 	while (driver->run)
 	{
@@ -1119,6 +1136,7 @@
 	driver->indev = NULL;
 	driver->outdev = NULL;
 	driver->ignorehwbuf = 0;
+	driver->trigger = 0;
 
 	pnode = params;
 	while (pnode != NULL)
diff -NPur jack-audio-connection-kit-0.103.0.orig/drivers/oss/oss_driver.h jack/drivers/oss/oss_driver.h
--- jack-audio-connection-kit-0.103.0.orig/drivers/oss/oss_driver.h	2006-05-26 09:45:26.000000000 +0700
+++ jack/drivers/oss/oss_driver.h	2007-08-25 15:30:45.000000000 +0700
@@ -1,7 +1,7 @@
 /*
 
 	OSS driver for Jack
-	Copyright (C) 2003-2005 Jussi Laako <jussi@sonarnerd.net>
+	Copyright (C) 2003-2007 Jussi Laako <jussi@sonarnerd.net>
 
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
@@ -62,6 +62,7 @@
 	int outfd;
 	int format;
 	int ignorehwbuf;
+	int trigger;
 
 	size_t indevbufsize;
 	size_t outdevbufsize;
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/Makefile.am jack/example-clients/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/example-clients/Makefile.am	2006-05-26 09:45:08.000000000 +0700
+++ jack/example-clients/Makefile.am	2007-08-25 15:30:33.000000000 +0700
@@ -36,11 +36,15 @@
                jack_bufsize \
 	       jack_lsp \
 	       jack_freewheel \
+	       jack_evmon \
+	       jack_alias \
 	       $(JACKREC) \
 	       $(JACK_TRANSPORT) \
 		   jack_midisine \
 		   jack_midiseq
 
+noinst_PROGRAMS = jack_thread_wait
+
 if HAVE_SNDFILE
 # note! jackrec_CFLAGS syntax not supported by automake-1.4
 sndfile_cflags = @SNDFILE_CFLAGS@
@@ -69,6 +73,18 @@
 jack_metro_LDFLAGS = @OS_LDFLAGS@
 jack_metro_LDADD = ../libjack/libjack.la
 
+jack_thread_wait_SOURCES = tw.c
+jack_thread_wait_LDFLAGS = @OS_LDFLAGS@
+jack_thread_wait_LDADD = ../libjack/libjack.la
+
+jack_evmon_SOURCES = evmon.c
+jack_evmon_LDFLAGS = @OS_LDFLAGS@
+jack_evmon_LDADD = ../libjack/libjack.la
+
+jack_alias_SOURCES = alias.c
+jack_alias_LDFLAGS = @OS_LDFLAGS@
+jack_alias_LDADD = ../libjack/libjack.la
+
 jack_lsp_SOURCES = lsp.c
 jack_lsp_LDFLAGS = @OS_LDFLAGS@
 jack_lsp_LDADD = ../libjack/libjack.la
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/alias.c jack/example-clients/alias.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/alias.c	1970-01-01 07:00:00.000000000 +0700
+++ jack/example-clients/alias.c	2007-08-25 15:30:33.000000000 +0700
@@ -0,0 +1,121 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <getopt.h>
+
+#include <config.h>
+
+#include <jack/jack.h>
+
+char * my_name;
+
+void
+show_version (void)
+{
+	fprintf (stderr, "%s: JACK Audio Connection Kit version " VERSION "\n",
+		my_name);
+}
+
+void
+show_usage (void)
+{
+	show_version ();
+	fprintf (stderr, "\nUsage: %s [options] portname alias\n", my_name);
+	fprintf (stderr, "List active Jack ports, and optionally display extra information.\n\n");
+	fprintf (stderr, "Display options:\n");
+	fprintf (stderr, "        -u, --unalias         remove `alias' as an alias for `port'\n");
+	fprintf (stderr, "        -h, --help            Display this help message\n");
+	fprintf (stderr, "        --version             Output version information and exit\n\n");
+	fprintf (stderr, "For more information see http://jackaudio.org/\n");
+}
+
+int
+main (int argc, char *argv[])
+{
+	jack_client_t *client;
+	jack_status_t status;
+	char* portname;
+	char* alias;
+	int unset = 0;
+	int ret;
+	int c;
+	int option_index;
+	extern int optind;
+	jack_port_t* port;
+	
+	struct option long_options[] = {
+		{ "unalias", 0, 0, 'u' },
+		{ "help", 0, 0, 'h' },
+		{ "version", 0, 0, 'v' },
+		{ 0, 0, 0, 0 }
+	};
+
+	if (argc < 3) {
+		show_usage ();
+		return 1;
+	}
+
+	my_name = strrchr(argv[0], '/');
+	if (my_name == 0) {
+		my_name = argv[0];
+	} else {
+		my_name ++;
+	}
+
+	while ((c = getopt_long (argc, argv, "uhv", long_options, &option_index)) >= 0) {
+		switch (c) {
+		case 'u':
+			unset = 1;
+			break;
+		case 'h':
+			show_usage ();
+			return 1;
+			break;
+		case 'v':
+			show_version ();
+			return 1;
+			break;
+		default:
+			show_usage ();
+			return 1;
+			break;
+		}
+	}
+
+	portname = argv[optind++];
+	alias = argv[optind];
+
+	/* Open a client connection to the JACK server.  Starting a
+	 * new server only to list its ports seems pointless, so we
+	 * specify JackNoStartServer. */
+	//JOQ: need a new server name option
+
+	client = jack_client_open ("lsp", JackNoStartServer, &status);
+
+	if (client == NULL) {
+		if (status & JackServerFailed) {
+			fprintf (stderr, "JACK server not running\n");
+		} else {
+			fprintf (stderr, "jack_client_open() failed, "
+				 "status = 0x%2.0x\n", status);
+		}
+		return 1;
+	}
+
+	if ((port = jack_port_by_name (client, portname)) == 0) {
+		fprintf (stderr, "No port named \"%s\"\n", portname);
+		return 1;
+	}
+
+	if (!unset) {
+		ret = jack_port_set_alias (port, alias);
+	} else {
+		ret = jack_port_unset_alias (port, alias);
+	}
+
+	jack_client_close (client);
+
+	return ret;
+	
+}
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/capture_client.c jack/example-clients/capture_client.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/capture_client.c	2007-01-17 07:48:43.000000000 +0700
+++ jack/example-clients/capture_client.c	2007-08-25 15:30:33.000000000 +0700
@@ -19,7 +19,6 @@
     * 2002/08/23 - modify for libsndfile 1.0.0 <andy@alsaplayer.org>
     * 2003/05/26 - use ringbuffers - joq
     
-    $Id: capture_client.c 994 2006-11-08 18:28:15Z joq $
 */
 
 #include <stdio.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/connect.c jack/example-clients/connect.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/connect.c	2006-05-26 09:45:08.000000000 +0700
+++ jack/example-clients/connect.c	2007-08-25 15:30:33.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: connect.c 473 2003-08-27 16:26:23Z joq $
 */
 
 #include <stdio.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/evmon.c jack/example-clients/evmon.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/evmon.c	1970-01-01 07:00:00.000000000 +0700
+++ jack/example-clients/evmon.c	2007-08-25 15:30:33.000000000 +0700
@@ -0,0 +1,92 @@
+/*
+    Copyright (C) 2007 Paul Davis
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <jack/jack.h>
+
+void
+port_callback (jack_port_id_t port, int yn, void* arg)
+{
+	printf ("Port %d %s\n", port, (yn ? "registered" : "unregistered"));
+}
+
+void
+connect_callback (jack_port_id_t a, jack_port_id_t b, int yn, void* arg)
+{
+	printf ("Ports %d and %d %s\n", a, b, (yn ? "connected" : "disconnected"));
+}
+
+void
+client_callback (const char* client, int yn, void* arg)
+{
+	printf ("Client %s %s\n", client, (yn ? "registered" : "unregistered"));
+}
+
+int
+graph_callback (void* arg)
+{
+	printf ("Graph reordered\n");
+	return 0;
+}
+
+int
+main (int argc, char *argv[])
+{
+	jack_client_t *client;
+	jack_options_t options = JackNullOption;
+	jack_status_t status;
+
+	if ((client = jack_client_open ("event-monitor", options, &status, NULL)) == 0) {
+		fprintf (stderr, "jack_client_open() failed, "
+			 "status = 0x%2.0x\n", status);
+		if (status & JackServerFailed) {
+			fprintf (stderr, "Unable to connect to JACK server\n");
+		}
+		return 1;
+	}
+	
+	if (jack_set_port_registration_callback (client, port_callback, NULL)) {
+		fprintf (stderr, "cannot set port registration callback\n");
+		return 1;
+	}
+	if (jack_set_port_connect_callback (client, connect_callback, NULL)) {
+		fprintf (stderr, "cannot set port connect callback\n");
+		return 1;
+	}
+	if (jack_set_client_registration_callback (client, client_callback, NULL)) {
+		fprintf (stderr, "cannot set client registration callback\n");
+		return 1;
+	}
+	if (jack_set_graph_order_callback (client, graph_callback, NULL)) {
+		fprintf (stderr, "cannot set graph order registration callback\n");
+		return 1;
+	}
+	if (jack_activate (client)) {
+		fprintf (stderr, "cannot activate client");
+		return 1;
+	}
+
+	sleep (-1);
+	exit (0);
+}
+
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/impulse_grabber.c jack/example-clients/impulse_grabber.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/impulse_grabber.c	2006-05-26 09:45:08.000000000 +0700
+++ jack/example-clients/impulse_grabber.c	2007-08-25 15:30:33.000000000 +0700
@@ -15,7 +15,6 @@
  *     along with this program; if not, write to the Free Software
  *     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- *     $Id: impulse_grabber.c 676 2004-03-27 22:08:55Z joq $
  */
 
 #include <stdio.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/lsp.c jack/example-clients/lsp.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/lsp.c	2007-01-17 07:48:43.000000000 +0700
+++ jack/example-clients/lsp.c	2007-08-25 15:30:33.000000000 +0700
@@ -24,6 +24,7 @@
 	fprintf (stderr, "\nUsage: %s [options]\n", my_name);
 	fprintf (stderr, "List active Jack ports, and optionally display extra information.\n\n");
 	fprintf (stderr, "Display options:\n");
+	fprintf (stderr, "        -A, --aliases         List aliases for each port\n");
 	fprintf (stderr, "        -c, --connections     List connections to/from each port\n");
 	fprintf (stderr, "        -l, --latency         Display per-port latency in frames at each port\n");
 	fprintf (stderr, "        -L, --latency         Display total latency in frames at each port\n");
@@ -32,7 +33,7 @@
 	fprintf (stderr, "        -t, --type            Display port type\n");
 	fprintf (stderr, "        -h, --help            Display this help message\n");
 	fprintf (stderr, "        --version             Output version information and exit\n\n");
-	fprintf (stderr, "For more information see http://jackit.sourceforge.net/\n");
+	fprintf (stderr, "For more information see http://jackaudio.org/\n");
 }
 
 int
@@ -42,6 +43,7 @@
 	jack_status_t status;
 	const char **ports, **connections;
 	unsigned int i, j;
+	int show_aliases = 0;
 	int show_con = 0;
 	int show_port_latency = 0;
 	int show_total_latency = 0;
@@ -49,8 +51,10 @@
 	int show_type = 0;
 	int c;
 	int option_index;
-
+	char* aliases[2];
+	
 	struct option long_options[] = {
+		{ "aliases", 0, 0, 'A' },
 		{ "connections", 0, 0, 'c' },
 		{ "port-latency", 0, 0, 'l' },
 		{ "total-latency", 0, 0, 'L' },
@@ -68,8 +72,13 @@
 		my_name ++;
 	}
 
-	while ((c = getopt_long (argc, argv, "clLphvt", long_options, &option_index)) >= 0) {
+	while ((c = getopt_long (argc, argv, "AclLphvt", long_options, &option_index)) >= 0) {
 		switch (c) {
+		case 'A':
+			aliases[0] = (char *) malloc (jack_port_name_size());
+			aliases[1] = (char *) malloc (jack_port_name_size());
+			show_aliases = 1;
+			break;
 		case 'c':
 			show_con = 1;
 			break;
@@ -123,6 +132,16 @@
 
 		jack_port_t *port = jack_port_by_name (client, ports[i]);
 
+		if (show_aliases) {
+			int cnt;
+			int i;
+
+			cnt = jack_port_get_aliases (port, aliases);
+			for (i = 0; i < cnt; ++i) {
+				printf ("   %s\n", aliases[i]);
+			}
+		}
+				
 		if (show_con) {
 			if ((connections = jack_port_get_all_connections (client, jack_port_by_name(client, ports[i]))) != 0) {
 				for (j = 0; connections[j]; j++) {
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/midiseq.c jack/example-clients/midiseq.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/midiseq.c	2007-01-17 07:48:43.000000000 +0700
+++ jack/example-clients/midiseq.c	2007-08-25 15:30:33.000000000 +0700
@@ -45,7 +45,7 @@
 	int i,j;
 	void* port_buf = jack_port_get_buffer(output_port, nframes);
 	unsigned char* buffer;
-	jack_midi_clear_buffer(port_buf, nframes);
+	jack_midi_clear_buffer(port_buf);
 	/*memset(buffer, 0, nframes*sizeof(jack_default_audio_sample_t));*/
 
 	for(i=0; i<nframes; i++)
@@ -54,7 +54,7 @@
 		{
 			if(note_starts[j] == loop_index)
 			{
-				buffer = jack_midi_event_reserve(port_buf, i, 3, nframes);
+				buffer = jack_midi_event_reserve(port_buf, i, 3);
 /*				printf("wrote a note on, port buffer = 0x%x, event buffer = 0x%x\n", port_buf, buffer);*/
 				buffer[2] = 64;		/* velocity */
 				buffer[1] = note_frqs[j];
@@ -62,7 +62,7 @@
 			}
 			else if(note_starts[j] + note_lengths[j] == loop_index)
 			{
-				buffer = jack_midi_event_reserve(port_buf, i, 3, nframes);
+				buffer = jack_midi_event_reserve(port_buf, i, 3);
 /*				printf("wrote a note off, port buffer = 0x%x, event buffer = 0x%x\n", port_buf, buffer);*/
 				buffer[2] = 64;		/* velocity */
 				buffer[1] = note_frqs[j];
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/midisine.c jack/example-clients/midisine.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/midisine.c	2007-01-17 07:48:43.000000000 +0700
+++ jack/example-clients/midisine.c	2007-08-25 15:30:33.000000000 +0700
@@ -49,18 +49,18 @@
 	jack_default_audio_sample_t *out = (jack_default_audio_sample_t *) jack_port_get_buffer (output_port, nframes);
 	jack_midi_event_t in_event;
 	jack_nframes_t event_index = 0;
-	jack_nframes_t event_count = jack_midi_get_event_count(port_buf, nframes);
+	jack_nframes_t event_count = jack_midi_get_event_count(port_buf);
 	if(event_count > 1)
 	{
 		printf(" midisine: have %d events\n", event_count);
 		for(i=0; i<event_count; i++)
 		{
-			jack_midi_event_get(&in_event, port_buf, i, nframes);
+			jack_midi_event_get(&in_event, port_buf, i);
 			printf("    event %d time is %d. 1st byte is 0x%x\n", i, in_event.time, *(in_event.buffer));
 		}
 /*		printf("1st byte of 1st event addr is %p\n", in_events[0].buffer);*/
 	}
-	jack_midi_event_get(&in_event, port_buf, 0, nframes);
+	jack_midi_event_get(&in_event, port_buf, 0);
 	for(i=0; i<nframes; i++)
 	{
 		if((in_event.time == i) && (event_index < event_count))
@@ -79,7 +79,7 @@
 			}
 			event_index++;
 			if(event_index < event_count)
-				jack_midi_event_get(&in_event, port_buf, event_index, nframes);
+				jack_midi_event_get(&in_event, port_buf, event_index);
 		}
 		ramp += note_frqs[note];
 		ramp = (ramp > 1.0) ? ramp - 2.0 : ramp;
diff -NPur jack-audio-connection-kit-0.103.0.orig/example-clients/tw.c jack/example-clients/tw.c
--- jack-audio-connection-kit-0.103.0.orig/example-clients/tw.c	1970-01-01 07:00:00.000000000 +0700
+++ jack/example-clients/tw.c	2007-08-25 15:30:33.000000000 +0700
@@ -0,0 +1,202 @@
+/** @file simple_client.c
+ *
+ * @brief This simple client demonstrates the basic features of JACK
+ * as they would be used by many applications.
+ */
+
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <jack/jack.h>
+
+jack_port_t *input_port;
+jack_port_t *output_port;
+jack_client_t *client;
+
+/* a simple state machine for this client */
+volatile enum {
+	Init,
+	Run,
+	Exit
+} client_state = Init;
+
+/**
+ * The process callback for this JACK application is called in a
+ * special realtime thread once for each audio cycle.
+ *
+ * This client follows a simple rule: when the JACK transport is
+ * running, copy the input port to the output.  When it stops, exit.
+ */
+int
+_process (jack_nframes_t nframes)
+{
+	jack_default_audio_sample_t *in, *out;
+	jack_transport_state_t ts = jack_transport_query(client, NULL);
+	
+	if (ts == JackTransportRolling) {
+		
+		if (client_state == Init)
+			client_state = Run;
+		
+		in = jack_port_get_buffer (input_port, nframes);
+		out = jack_port_get_buffer (output_port, nframes);
+		memcpy (out, in,
+			sizeof (jack_default_audio_sample_t) * nframes);
+		
+	} else if (ts == JackTransportStopped) {
+		
+		if (client_state == Run)
+			client_state = Exit;
+	}
+
+	return 0;      
+}
+
+int
+process (jack_nframes_t nframes, void* arg)
+{
+	jack_client_t* client = (jack_client_t*) arg;
+
+	while ((nframes = jack_thread_wait (client, _process (nframes))) != 0);
+}
+
+/**
+ * JACK calls this shutdown_callback if the server ever shuts down or
+ * decides to disconnect the client.
+ */
+void
+jack_shutdown (void *arg)
+{
+	exit (1);
+}
+
+int
+main (int argc, char *argv[])
+{
+	const char **ports;
+	const char *client_name;
+	const char *server_name = NULL;
+	jack_options_t options = JackNullOption;
+	jack_status_t status;
+
+	if (argc >= 2) {		/* client name specified? */
+		client_name = argv[1];
+		if (argc >= 3) {	/* server name specified? */
+			server_name = argv[2];
+			options |= JackServerName;
+		}
+	} else {			/* use basename of argv[0] */
+		client_name = strrchr(argv[0], '/');
+		if (client_name == 0) {
+			client_name = argv[0];
+		} else {
+			client_name++;
+		}
+	}
+
+	/* open a client connection to the JACK server */
+
+	client = jack_client_open (client_name, options, &status, server_name);
+	if (client == NULL) {
+		fprintf (stderr, "jack_client_open() failed, "
+			 "status = 0x%2.0x\n", status);
+		if (status & JackServerFailed) {
+			fprintf (stderr, "Unable to connect to JACK server\n");
+		}
+		exit (1);
+	}
+	if (status & JackServerStarted) {
+		fprintf (stderr, "JACK server started\n");
+	}
+	if (status & JackNameNotUnique) {
+		client_name = jack_get_client_name(client);
+		fprintf (stderr, "unique name `%s' assigned\n", client_name);
+	}
+
+	/* tell the JACK server to call `process()' whenever
+	   there is work to be done.
+	*/
+
+	jack_set_process_callback (client, process, client);
+
+	/* tell the JACK server to call `jack_shutdown()' if
+	   it ever shuts down, either entirely, or if it
+	   just decides to stop calling us.
+	*/
+
+	jack_on_shutdown (client, jack_shutdown, 0);
+
+	/* display the current sample rate. 
+	 */
+
+	printf ("engine sample rate: %" PRIu32 "\n",
+		jack_get_sample_rate (client));
+
+	/* create two ports */
+
+	input_port = jack_port_register (client, "input",
+					 JACK_DEFAULT_AUDIO_TYPE,
+					 JackPortIsInput, 0);
+	output_port = jack_port_register (client, "output",
+					  JACK_DEFAULT_AUDIO_TYPE,
+					  JackPortIsOutput, 0);
+
+	if ((input_port == NULL) || (output_port == NULL)) {
+		fprintf(stderr, "no more JACK ports available\n");
+		exit (1);
+	}
+
+	/* Tell the JACK server that we are ready to roll.  Our
+	 * process() callback will start running now. */
+
+	if (jack_activate (client)) {
+		fprintf (stderr, "cannot activate client");
+		exit (1);
+	}
+
+	/* Connect the ports.  You can't do this before the client is
+	 * activated, because we can't make connections to clients
+	 * that aren't running.  Note the confusing (but necessary)
+	 * orientation of the driver backend ports: playback ports are
+	 * "input" to the backend, and capture ports are "output" from
+	 * it.
+	 */
+
+	ports = jack_get_ports (client, NULL, NULL,
+				JackPortIsPhysical|JackPortIsOutput);
+	if (ports == NULL) {
+		fprintf(stderr, "no physical capture ports\n");
+		exit (1);
+	}
+
+	if (jack_connect (client, ports[0], jack_port_name (input_port))) {
+		fprintf (stderr, "cannot connect input ports\n");
+	}
+
+	free (ports);
+	
+	ports = jack_get_ports (client, NULL, NULL,
+				JackPortIsPhysical|JackPortIsInput);
+	if (ports == NULL) {
+		fprintf(stderr, "no physical playback ports\n");
+		exit (1);
+	}
+
+	if (jack_connect (client, jack_port_name (output_port), ports[0])) {
+		fprintf (stderr, "cannot connect output ports\n");
+	}
+
+	free (ports);
+
+	/* keep running until the transport stops */
+
+	while (client_state != Exit) {
+		sleep (1);
+	}
+
+	jack_client_close (client);
+	exit (0);
+}
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/atomicity.h jack/jack/atomicity.h
--- jack-audio-connection-kit-0.103.0.orig/jack/atomicity.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/atomicity.h	2007-08-25 15:30:41.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: atomicity.h 673 2004-03-25 19:31:51Z joq $
 */
 
 #ifndef __jack_atomicity_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/bitset.h jack/jack/bitset.h
--- jack-audio-connection-kit-0.103.0.orig/jack/bitset.h	2006-05-26 09:45:21.000000000 +0700
+++ jack/jack/bitset.h	2007-08-25 15:30:41.000000000 +0700
@@ -10,7 +10,6 @@
  * cardinality (number of elements allowed), followed by one or more
  * words containing bit vectors.
  *
- *  $Id: bitset.h 864 2005-01-03 00:15:31Z joq $
  */
 
 /*
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/driver.h jack/jack/driver.h
--- jack-audio-connection-kit-0.103.0.orig/jack/driver.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/driver.h	2007-08-25 15:30:41.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: driver.h 945 2006-05-04 15:14:45Z pbd $
 */
 
 #ifndef __jack_driver_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/engine.h jack/jack/engine.h
--- jack-audio-connection-kit-0.103.0.orig/jack/engine.h	2006-06-22 11:39:02.000000000 +0700
+++ jack/jack/engine.h	2007-08-25 15:30:41.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: engine.h 978 2006-06-20 22:15:52Z joq $
 */
 
 #ifndef __jack_engine_h__
@@ -119,6 +118,7 @@
     int		    feedbackcount;
     pid_t           wait_pid;
     pthread_t       freewheel_thread;
+    int             nozombies;
 
     /* these lists are protected by `client_lock' */
     JSList	   *clients;
@@ -156,7 +156,8 @@
 				 const char *server_name, int temporary,
 				 int verbose, int client_timeout,
 				 unsigned int port_max,
-                                 pid_t waitpid, jack_nframes_t frame_time_offset, JSList *drivers);
+                                 pid_t waitpid, jack_nframes_t frame_time_offset, int nozombies, 
+				 JSList *drivers);
 void		jack_engine_delete (jack_engine_t *);
 int		jack_run (jack_engine_t *engine);
 int		jack_wait (jack_engine_t *engine);
@@ -204,5 +205,6 @@
 void	jack_port_registration_notify (jack_engine_t *, jack_port_id_t, int);
 void	jack_port_release (jack_engine_t *engine, jack_port_internal_t *);
 void	jack_sort_graph (jack_engine_t *engine);
+void    jack_engine_munge_backend_port_names (jack_engine_t* engine);
 
 #endif /* __jack_engine_h__ */
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/hardware.h jack/jack/hardware.h
--- jack-audio-connection-kit-0.103.0.orig/jack/hardware.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/hardware.h	2007-08-25 15:30:41.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: hardware.h 350 2003-03-20 20:49:23Z pbd $
 */
 
 #ifndef __jack_hardware_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/intclient.h jack/jack/intclient.h
--- jack-audio-connection-kit-0.103.0.orig/jack/intclient.h	2006-05-26 09:45:21.000000000 +0700
+++ jack/jack/intclient.h	2007-08-25 15:30:41.000000000 +0700
@@ -15,7 +15,6 @@
  *  along with this program; if not, write to the Free Software 
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
- *  $Id: intclient.h 807 2004-11-29 17:54:35Z joq $
  */
 
 #ifndef __jack_intclient_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/internal.h jack/jack/internal.h
--- jack-audio-connection-kit-0.103.0.orig/jack/internal.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/internal.h	2007-08-25 15:30:42.000000000 +0700
@@ -21,7 +21,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: internal.h 948 2006-05-15 17:12:44Z pbd $
 */
 
 #ifndef __jack_internal_h__
@@ -171,13 +170,16 @@
   PortUnregistered,
   XRun,
   StartFreewheel,
-  StopFreewheel
+  StopFreewheel,
+  ClientRegistered,
+  ClientUnregistered
 } JackEventType;
 
 typedef struct {
     JackEventType type;
     union {
 	uint32_t n;
+        char name[JACK_CLIENT_NAME_SIZE];    
 	jack_port_id_t port_id;
 	jack_port_id_t self_id;
     } x;
@@ -240,6 +242,8 @@
     void *srate_arg;
     JackPortRegistrationCallback port_register;
     void *port_register_arg;
+    JackPortConnectCallback port_connect;
+    void *port_connect_arg;
     JackGraphOrderCallback graph_order;
     void *graph_order_arg;
     JackXRunCallback xrun;
@@ -250,7 +254,9 @@
     void *timebase_arg;
     JackFreewheelCallback freewheel_cb;
     void *freewheel_arg;
-	
+    JackClientRegistrationCallback client_register;	
+    void *client_register_arg;
+
     /* external clients: set by libjack
      * internal clients: set by engine */
     int (*deliver_request)(void*, jack_request_t*); /* JOQ: 64/32 bug! */
@@ -330,7 +336,8 @@
 	IntClientLoad = 20,
 	IntClientName = 21,
 	IntClientUnload = 22,
-	RecomputeTotalLatencies = 23
+	RecomputeTotalLatencies = 23,
+	RecomputeTotalLatency = 24
 } RequestType;
 
 struct _jack_request {
@@ -456,6 +463,7 @@
 
 jack_port_t *jack_port_by_name_int (jack_client_t *client,
 				    const char *port_name);
+int jack_port_name_equals (jack_port_shared_t* port, const char* target);
 
 #ifdef __GNUC__
 #  define likely(x)	__builtin_expect((x),1)
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/intsimd.h jack/jack/intsimd.h
--- jack-audio-connection-kit-0.103.0.orig/jack/intsimd.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/intsimd.h	2007-08-25 15:30:41.000000000 +0700
@@ -1,5 +1,5 @@
 /*
-    Copyright (C) 2005 Jussi Laako
+    Copyright (C) 2005-2007 Jussi Laako
      
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  
-    $Id: intsimd.h 929 2006-01-03 21:10:49Z sonarnerd $
 */
 
 #ifndef __jack_intsimd_h__
@@ -40,9 +39,16 @@
 
 extern int cpu_type;
 
+int have_3dnow (void);
+int have_sse (void);
+void x86_3dnow_copyf (float *, const float *, int);
+void x86_3dnow_add2f (float *, const float *, int);
+void x86_sse_copyf (float *, const float *, int);
+void x86_sse_add2f (float *, const float *, int);
+
 #endif /* ARCH_X86 */
 
-extern void jack_port_set_funcs (void);
+void jack_port_set_funcs (void);
 
 #endif /* __jack_intsimd_h__ */
 
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/jack.h jack/jack/jack.h
--- jack-audio-connection-kit-0.103.0.orig/jack/jack.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/jack.h	2007-08-25 15:30:42.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: jack.h 895 2005-05-11 02:06:47Z pbd $
 */
 
 #ifndef __jack_h__
@@ -73,25 +72,9 @@
 				 jack_status_t *status, ...);
 
 /**
- * Attempt to become an external client of the Jack server.
+ * \bold THIS FUNCTION IS DEPRECATED AND SHOULD NOT BE USED IN
+ *  NEW JACK CLIENTS
  *
- * JACK is evolving a mechanism for automatically starting the server
- * when needed.  As a transition, jack_client_new() only does this
- * when \$JACK_START_SERVER is defined in the environment of the
- * calling process.  In the future this will become normal behavior.
- * For full control of this feature, use jack_client_open(), instead.
- * In either case, defining \$JACK_NO_START_SERVER disables this
- * feature.
- *
- * @param client_name of at most jack_client_name_size() characters.
- * If this name is already in use, the request fails.
- *
- * @return Opaque client handle if successful, otherwise NULL.
- *
- * @note Failure generally means that the JACK server is not running.
- * If there was some other problem, it will be reported via the @ref
- * jack_error_callback mechanism.  Use jack_client_open() and check
- * the @a status parameter for more detailed information.
  */
 jack_client_t *jack_client_new (const char *client_name);
 
@@ -196,6 +179,18 @@
 int jack_set_process_callback (jack_client_t *client,
 			       JackProcessCallback process_callback,
 			       void *arg);
+/**
+ * Block until this JACK client should process data.
+ * 
+ * The @a status argument typically indicates the result
+ * of some recent data processing.
+ * 
+ * @param client - pointer to a JACK client structure
+ * @param status - if non-zero, calling thread should exit
+ *
+ * @return the number of frames of data to process
+ */
+jack_nframes_t jack_thread_wait (jack_client_t*, int status);
 
 /**
  * Tell JACK to call @a thread_init_callback once just after
@@ -300,11 +295,30 @@
  *
  * @return 0 on success, otherwise a non-zero error code
  */
+int jack_set_client_registration_callback (jack_client_t *,
+					   JackClientRegistrationCallback
+					   registration_callback, void *arg);
+	
+/**
+ * Tell the JACK server to call @a registration_callback whenever a
+ * port is registered or unregistered, passing @a arg as a parameter.
+ *
+ * @return 0 on success, otherwise a non-zero error code
+ */
 int jack_set_port_registration_callback (jack_client_t *,
 					 JackPortRegistrationCallback
 					 registration_callback, void *arg);
 
 /**
+ * Tell the JACK server to call @a connect_callback whenever a
+ * port is connected or disconnected, passing @a arg as a parameter.
+ *
+ * @return 0 on success, otherwise a non-zero error code
+ */
+int jack_set_port_connect_callback (jack_client_t *,
+				    JackPortConnectCallback
+				    connect_callback, void *arg);
+/**
  * Tell the JACK server to call @a graph_callback whenever the
  * processing graph is reordered, passing @a arg as a parameter.
  *
@@ -508,22 +522,6 @@
  */
 int  jack_port_untie (jack_port_t *port);
 
-/**
- * A client may call this function to prevent other objects
- * from changing the connection status of a port. The port
- * must be owned by the calling client.
- *
- * @return 0 on success, otherwise a non-zero error code
- */
-int jack_port_lock (jack_client_t *, jack_port_t *);
-
-/**
- * This allows other objects to change the connection status of a port.
- *
- * @return 0 on success, otherwise a non-zero error code
- */
-int jack_port_unlock (jack_client_t *, jack_port_t *);
-
 /** 
  * @return the time (in frames) between data being available or
  * delivered at/to a port, and the time at which it arrived at or is
@@ -557,7 +555,30 @@
 void jack_port_set_latency (jack_port_t *, jack_nframes_t);
 	
 /**
- *
+ * Request a complete recomputation of a port's total latency. This
+ * can be called by a client that has just changed the internal
+ * latency of its port using @function jack_port_set_latency
+ * and wants to ensure that all signal pathways in the graph
+ * are updated with respect to the values that will be returned
+ * by @function jack_port_get_total_latency. 
+ * 
+ * @return zero for successful execution of the request. non-zero
+ *         otherwise.
+ */
+int jack_recompute_total_latency (jack_client_t*, jack_port_t* port);
+
+/**
+ * Request a complete recomputation of all port latencies. This
+ * can be called by a client that has just changed the internal
+ * latency of its port using @function jack_port_set_latency
+ * and wants to ensure that all signal pathways in the graph
+ * are updated with respect to the values that will be returned
+ * by @function jack_port_get_total_latency. It allows a client 
+ * to change multiple port latencies without triggering a 
+ * recompute for each change.
+ * 
+ * @return zero for successful execution of the request. non-zero
+ *         otherwise.
  */
 int jack_recompute_total_latencies (jack_client_t*);
 
@@ -571,6 +592,38 @@
 int jack_port_set_name (jack_port_t *port, const char *port_name);
 
 /**
+ * Set @a alias as an alias for @a port.  May be called at any time.
+ * If the alias is longer than jack_port_name_size(), it will be truncated.
+ * 
+ * After a successful call, and until JACK exits or
+ * @function jack_port_unset_alias() is called, @alias may be
+ * used as a alternate name for the port.
+ *
+ * Ports can have up to two aliases - if both are already 
+ * set, this function will return an error.
+ *
+ * @return 0 on success, otherwise a non-zero error code.
+ */
+int jack_port_set_alias (jack_port_t *port, const char *alias);
+
+/**
+ * Remove @a alias as an alias for @a port.  May be called at any time.
+ * 
+ * After a successful call, @a alias can no longer be 
+ * used as a alternate name for the port.
+ *
+ * @return 0 on success, otherwise a non-zero error code.
+ */
+int jack_port_unset_alias (jack_port_t *port, const char *alias);
+
+/*
+ * Get any aliases known for @port.
+ *
+ * @return the number of aliases discovered for the port
+ */
+int jack_port_get_aliases (const jack_port_t *port, char* const aliases[2]);
+
+/**
  * If @ref JackPortCanMonitor is set for this @a port, turn input
  * monitoring on or off.  Otherwise, do nothing.
  */
@@ -752,6 +805,26 @@
 jack_nframes_t jack_last_frame_time (const jack_client_t *client);
 
 /**
+ * @return estimated time in microseconds of the specified frame time
+ */
+jack_time_t jack_frames_to_time(const jack_client_t *client, jack_nframes_t);
+
+/**
+ * @return estimated time in frames for the specified system time.
+ */
+jack_nframes_t jack_time_to_frames(const jack_client_t *client, jack_time_t);
+
+/**
+ * @return return JACK's current system time in microseconds,
+ *         using JACK clock source. 
+ * 
+ * The value returned is guaranteed to be monotonic, but not linear.
+ *
+ * This function is a client version of @function jack_get_microseconds().
+ */
+jack_time_t jack_get_time();
+
+/**
  * @return the current CPU load estimated by JACK.  This is a running
  * average of the time it takes to execute a full process cycle for
  * all clients as a percentage of the real time available per cycle
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/jslist.h jack/jack/jslist.h
--- jack-audio-connection-kit-0.103.0.orig/jack/jslist.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/jslist.h	2007-08-25 15:30:41.000000000 +0700
@@ -20,7 +20,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: jslist.h 574 2003-11-24 23:18:57Z node $
 */
 
 #ifndef __jack_jslist_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/memops.h jack/jack/memops.h
--- jack-audio-connection-kit-0.103.0.orig/jack/memops.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/memops.h	2007-08-25 15:30:41.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: memops.h 945 2006-05-04 15:14:45Z pbd $
 */
 
 #ifndef __jack_memops_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/messagebuffer.h jack/jack/messagebuffer.h
--- jack-audio-connection-kit-0.103.0.orig/jack/messagebuffer.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/messagebuffer.h	2007-08-25 15:30:42.000000000 +0700
@@ -23,7 +23,6 @@
  *  along with this program; if not, write to the Free Software 
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
- *  $Id: messagebuffer.h 843 2004-12-13 17:20:39Z trutkin $
  */
 
 #ifndef __jack_messagebuffer_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/midiport.h jack/jack/midiport.h
--- jack-audio-connection-kit-0.103.0.orig/jack/midiport.h	2007-01-17 07:48:46.000000000 +0700
+++ jack/jack/midiport.h	2007-08-25 15:30:43.000000000 +0700
@@ -45,12 +45,10 @@
 /* Get number of events in a port buffer.
  *
  * @param port_buffer Port buffer from which to retrieve event.
- * @param nframes Number of valid frames this cycle.
  * @return number of events inside @a port_buffer
  */
 jack_nframes_t
-jack_midi_get_event_count(void*          port_buffer,
-                        jack_nframes_t nframes);
+jack_midi_get_event_count(void*          port_buffer);
 
 
 /** Get a MIDI event from an event port buffer.
@@ -62,14 +60,12 @@
  * @param event Event structure to store retrieved event in.
  * @param port_buffer Port buffer from which to retrieve event.
  * @param event_index Index of event to retrieve.
- * @param nframes Number of valid frames this cycle.
  * @return 0 on success, ENODATA if buffer is empty.
  */
 int
 jack_midi_event_get(jack_midi_event_t *event,
                     void              *port_buffer,
-                    jack_nframes_t     event_index,
-                    jack_nframes_t     nframes);
+                    jack_nframes_t     event_index);
 
 
 /** Clear an event buffer.
@@ -79,11 +75,9 @@
  * function may not be called on an input port's buffer.
  *
  * @param port_buffer Port buffer to clear (must be an output port buffer).
- * @param nframes Number of valid frames this cycle.
  */
 void
-jack_midi_clear_buffer(void           *port_buffer,
-                       jack_nframes_t  nframes);
+jack_midi_clear_buffer(void           *port_buffer);
 
 
 /** Get the size of the largest event that can be stored by the port.
@@ -92,10 +86,9 @@
  * events already stored in the port.
  *
  * @param port_buffer Port buffer to check size of.
- * @param nframes Number of valid frames this cycle.
  */
 size_t
-jack_midi_max_event_size(void* port_buffer, jack_nframes_t nframes);
+jack_midi_max_event_size(void* port_buffer);
 
 
 /** Allocate space for an event to be written to an event port buffer.
@@ -110,15 +103,13 @@
  * @param port_buffer Buffer to write event to.
  * @param time Sample offset of event.
  * @param data_size Length of event's raw data in bytes.
- * @param nframes Number of valid frames this event.
  * @return Pointer to the beginning of the reserved event's data buffer, or
  * NULL on error (ie not enough space).
  */
 jack_midi_data_t*
 jack_midi_event_reserve(void           *port_buffer,
                         jack_nframes_t  time, 
-                        size_t          data_size,
-                        jack_nframes_t  nframes);
+                        size_t          data_size);
 
 
 /** Write an event into an event port buffer.
@@ -131,15 +122,13 @@
  * @param time Sample offset of event.
  * @param data Message data to be written.
  * @param data_size Length of @a data in bytes.
- * @param nframes Number of valid frames this event.
  * @return 0 on success, ENOBUFS if there's not enough space in buffer for event.
  */
 int
 jack_midi_event_write(void                   *port_buffer,
                       jack_nframes_t          time,
                       const jack_midi_data_t *data,
-                      size_t                  data_size,
-                      jack_nframes_t          nframes);
+                      size_t                  data_size);
 
 
 /** Get the number of events that could not be written to @a port_buffer.
@@ -148,12 +137,10 @@
  * Currently the only way this can happen is if events are lost on port mixdown.
  *
  * @param port_buffer Port to receive count for.
- * @param nframes Number of valid frames this cycle.
  * @returns Number of events that could not be written to @a port_buffer.
  */
 jack_nframes_t
-jack_midi_get_lost_event_count(void           *port_buffer,
-                               jack_nframes_t  nframes);
+jack_midi_get_lost_event_count(void           *port_buffer);
 
 
 #ifdef __cplusplus
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/pool.h jack/jack/pool.h
--- jack-audio-connection-kit-0.103.0.orig/jack/pool.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/pool.h	2007-08-25 15:30:42.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: pool.h 11 2001-11-13 04:32:31Z pbd $
 */
 
 #ifndef __jack_pool_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/port.h jack/jack/port.h
--- jack-audio-connection-kit-0.103.0.orig/jack/port.h	2007-01-17 07:48:46.000000000 +0700
+++ jack/jack/port.h	2007-08-25 15:30:43.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: port.h 998 2006-11-22 19:55:56Z joq $
 */
 
 #ifndef __jack_port_h__
@@ -99,6 +98,8 @@
     jack_port_id_t           id;	/* index into engine port array */
     enum JackPortFlags	     flags;    
     char                     name[JACK_CLIENT_NAME_SIZE+JACK_PORT_NAME_SIZE];
+    char                     alias1[JACK_CLIENT_NAME_SIZE+JACK_PORT_NAME_SIZE];
+    char                     alias2[JACK_CLIENT_NAME_SIZE+JACK_PORT_NAME_SIZE];
     jack_client_id_t         client_id;	/* who owns me */
 
     volatile jack_nframes_t  latency;
@@ -107,7 +108,7 @@
 
     char		     has_mixdown; /* port has a mixdown function */
     char                     in_use;
-    char                     locked;
+    char                     unused; /* legacy locked field */
 
 } jack_port_shared_t;
 
@@ -119,7 +120,7 @@
      * A better solution is to make jack_engine_place_buffers to be type-specific,
      * but this works.
      */
-    void (*buffer_init)(void *buffer, size_t size);
+    void (*buffer_init)(void *buffer, size_t size, jack_nframes_t);
 
     /* Function to mixdown multiple inputs to a buffer.  Can be NULL,
      * indicating that multiple input connections are not legal for
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/ringbuffer.h jack/jack/ringbuffer.h
--- jack-audio-connection-kit-0.103.0.orig/jack/ringbuffer.h	2006-05-26 09:45:21.000000000 +0700
+++ jack/jack/ringbuffer.h	2007-08-25 15:30:41.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: ringbuffer.h 729 2004-07-08 17:21:03Z joq $
 */
 
 #ifndef _RINGBUFFER_H
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/statistics.h jack/jack/statistics.h
--- jack-audio-connection-kit-0.103.0.orig/jack/statistics.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/statistics.h	2007-08-25 15:30:41.000000000 +0700
@@ -16,7 +16,6 @@
  *  Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  *  02111-1307, USA.
  *
- *  $Id: statistics.h 860 2004-12-31 23:57:21Z joq $
  */
 
 #ifndef __statistics_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/thread.h jack/jack/thread.h
--- jack-audio-connection-kit-0.103.0.orig/jack/thread.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/thread.h	2007-08-25 15:30:41.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: thread.h 948 2006-05-15 17:12:44Z pbd $
 */
 
 #ifndef __jack_thread_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/timestamps.h jack/jack/timestamps.h
--- jack-audio-connection-kit-0.103.0.orig/jack/timestamps.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/timestamps.h	2007-08-25 15:30:43.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: timestamps.h 264 2002-11-01 15:41:08Z pbd $
 */
 
 #ifndef __jack_timestamps_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/transport.h jack/jack/transport.h
--- jack-audio-connection-kit-0.103.0.orig/jack/transport.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/transport.h	2007-08-25 15:30:41.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: transport.h 951 2006-05-15 21:32:08Z pbd $
 */
 
 #ifndef __jack_transport_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/types.h jack/jack/types.h
--- jack-audio-connection-kit-0.103.0.orig/jack/types.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/types.h	2007-08-25 15:30:41.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: types.h 945 2006-05-04 15:14:45Z pbd $
 */
 
 #ifndef __jack_types_h__
@@ -82,7 +81,7 @@
  * @pre nframes == pow(2,x)
  *
  * @param nframes number of frames to process
- * @param arg pointer to a client supplied structure
+ * @param arg pointer to a client supplied data
  *
  * @return zero on success, non-zero on error
  */ 
@@ -106,7 +105,7 @@
  * Prototype for the client supplied function that is called 
  * whenever the processing graph is reordered.
  *
- * @param arg pointer to a client supplied structure
+ * @param arg pointer to a client supplied data
  *
  * @return zero on success, non-zero on error
  */ 
@@ -118,7 +117,7 @@
  *
  * @see jack_get_xrun_delayed_usecs()
  *
- * @param arg pointer to a client supplied structure
+ * @param arg pointer to a client supplied data
  *
  * @return zero on success, non-zero on error
  */ 
@@ -145,7 +144,7 @@
  * when the engine sample rate changes.
  *
  * @param nframes new engine sample rate
- * @param arg pointer to a client supplied structure
+ * @param arg pointer to a client supplied data
  *
  * @return zero on success, non-zero on error
  */ 
@@ -155,9 +154,35 @@
  * Prototype for the client supplied function that is called 
  * whenever a port is registered or unregistered.
  *
- * @param arg pointer to a client supplied structure
+ * @parm  port the ID of the port 
+ * @param arg pointer to a client supplied data
+ * @param register non-zero if the port is being registered,
+ *                     zero if the port is being unregistered
+ */ 
+typedef void (*JackPortRegistrationCallback)(jack_port_id_t port, int register, void *arg);
+
+/**
+ * Prototype for the client supplied function that is called 
+ * whenever a client is registered or unregistered.
+ *
+ * @param name a null-terminated string containing the client name 
+ * @param register non-zero if the client is being registered,
+ *                     zero if the client is being unregistered
+ * @param arg pointer to a client supplied data
+ */ 
+typedef void (*JackClientRegistrationCallback)(const char* name, int register, void *arg);
+
+/**
+ * Prototype for the client supplied function that is called 
+ * whenever a client is registered or unregistered.
+ *
+ * @param a one of two ports connected or disconnected
+ * @param b one of two ports connected or disconnected
+ * @param connect non-zero if ports were connected
+ *                    zero if ports were disconnected
+ * @param arg pointer to a client supplied data
  */ 
-typedef void (*JackPortRegistrationCallback)(jack_port_id_t port, int, void *arg);
+typedef void (*JackPortConnectCallback)(jack_port_id_t a, jack_port_id_t b, int connect, void* arg);
 
 /**
  * Prototype for the client supplied function that is called 
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/unlock.h jack/jack/unlock.h
--- jack-audio-connection-kit-0.103.0.orig/jack/unlock.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/unlock.h	2007-08-25 15:30:41.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: unlock.h 738 2004-08-22 21:39:53Z pbd $
 */
 
 #ifndef __jack_mlock_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jack/varargs.h jack/jack/varargs.h
--- jack-audio-connection-kit-0.103.0.orig/jack/varargs.h	2006-05-26 09:45:22.000000000 +0700
+++ jack/jack/varargs.h	2007-08-25 15:30:41.000000000 +0700
@@ -15,7 +15,6 @@
  *  along with this program; if not, write to the Free Software 
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
- *  $Id: varargs.h 807 2004-11-29 17:54:35Z joq $
  */
 
 #ifndef __jack_varargs_h__
diff -NPur jack-audio-connection-kit-0.103.0.orig/jackd/clientengine.c jack/jackd/clientengine.c
--- jack-audio-connection-kit-0.103.0.orig/jackd/clientengine.c	2006-08-31 11:42:11.000000000 +0700
+++ jack/jackd/clientengine.c	2007-08-25 15:30:43.000000000 +0700
@@ -19,7 +19,6 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- *  $Id: clientengine.c 985 2006-08-29 15:21:17Z paul $
  */
 
 #include <config.h>
@@ -96,7 +95,7 @@
 	/* this stops jack_deliver_event() from doing anything */
 
 	client->control->dead = TRUE;
-	
+
 	jack_client_disconnect_ports (engine, client);
 	jack_client_do_deactivate (engine, client, FALSE);
 }
@@ -202,10 +201,12 @@
 					 client->control->name,
 					 jack_client_state_name (client),
 					 client->error);
-				jack_zombify_client (engine,
-						     (jack_client_internal_t *)
-						     node->data);
-				client->error = 0;
+				if (!engine->nozombies) {
+					jack_zombify_client (engine,
+							     (jack_client_internal_t *)
+							     node->data);
+					client->error = 0;
+				}
 			}
 			
 			need_sort = TRUE;
@@ -474,8 +475,12 @@
 	client->control->xrun_arg = NULL;
 	client->control->port_register = NULL;
 	client->control->port_register_arg = NULL;
+	client->control->port_connect = NULL;
+	client->control->port_connect_arg = NULL;
 	client->control->graph_order = NULL;
 	client->control->graph_order_arg = NULL;
+	client->control->client_register = NULL;
+	client->control->client_register_arg = NULL;
 
 	jack_transport_client_new (client);
         
@@ -717,6 +722,8 @@
 		close (client_fd);
 	}
 
+	jack_client_registration_notify (engine, (const char*) client->control->name, 1);
+
 	return 0;
 }
 
@@ -856,6 +863,8 @@
 void
 jack_client_delete (jack_engine_t *engine, jack_client_internal_t *client)
 {
+	jack_client_registration_notify (engine, (const char*) client->control->name, 0);
+
 	if (jack_client_is_internal (client)) {
 
 		jack_client_unload (client);
diff -NPur jack-audio-connection-kit-0.103.0.orig/jackd/clientengine.h jack/jackd/clientengine.h
--- jack-audio-connection-kit-0.103.0.orig/jackd/clientengine.h	2006-05-26 09:45:24.000000000 +0700
+++ jack/jackd/clientengine.h	2007-08-25 15:30:43.000000000 +0700
@@ -18,7 +18,6 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- *  $Id: clientengine.h 863 2005-01-02 15:22:48Z joq $
  */
 
 static inline int 
@@ -58,3 +57,5 @@
 void	jack_intclient_unload_request (jack_engine_t *engine,
 				       jack_request_t *req);
 void	jack_remove_clients (jack_engine_t* engine);
+void    jack_client_registration_notify (jack_engine_t *engine,
+					 const char* name, int yn);
diff -NPur jack-audio-connection-kit-0.103.0.orig/jackd/engine.c jack/jackd/engine.c
--- jack-audio-connection-kit-0.103.0.orig/jackd/engine.c	2007-03-06 12:24:05.000000000 +0700
+++ jack/jackd/engine.c	2007-08-25 15:30:43.000000000 +0700
@@ -17,7 +17,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: engine.c 1011 2007-02-23 23:49:09Z paul $
 */
 
 #include <config.h>
@@ -109,6 +108,10 @@
 				jack_event_t *);
 static void jack_deliver_event_to_all (jack_engine_t *engine,
 				       jack_event_t *event);
+static void jack_notify_all_port_interested_clients (jack_engine_t *engine,
+						     jack_port_id_t a,
+						     jack_port_id_t b,
+						     int connect);
 static void jack_engine_post_process (jack_engine_t *);
 static int  jack_use_driver (jack_engine_t *engine, jack_driver_t *driver);
 static int  jack_run_cycle (jack_engine_t *engine, jack_nframes_t nframes,
@@ -124,6 +127,7 @@
 			     jack_client_internal_t *b);
 static void jack_check_acyclic (jack_engine_t* engine);
 static void jack_compute_all_port_total_latencies (jack_engine_t *engine);
+static void jack_compute_port_total_latency (jack_engine_t *engine, jack_port_shared_t*);
 
 
 static inline int 
@@ -174,7 +178,15 @@
 	if (stat (path, &statbuf)) {
 
 		if (errno == ENOENT) {
-			if (mkdir (path, 0700) < 0){
+			int mode;
+
+			if (getenv ("JACK_PROMISCUOUS_SERVER")) {
+				mode = 0777;
+			} else {
+				mode = 0700;
+			}
+
+			if (mkdir (path, mode) < 0){
 				jack_error ("cannot create %s directory (%s)\n",
 					    path, strerror (errno));
 				return -1;
@@ -325,7 +337,8 @@
 				jack_port_type_id_t ptid,
 				jack_shmsize_t one_buffer,
 				jack_shmsize_t size,
-				unsigned long nports)
+				unsigned long nports,
+				jack_nframes_t nframes)
 {
 	jack_shmsize_t offset;		/* shared memory offset */
 	jack_port_buffer_info_t *bi;
@@ -401,7 +414,7 @@
 
 		bi = pti->info;
 		for (i=0; i<nports; ++i, ++bi)
-			pfuncs->buffer_init(shm_segment + bi->offset, one_buffer);
+			pfuncs->buffer_init(shm_segment + bi->offset, one_buffer, nframes);
 	}
 
 	pthread_mutex_unlock (&pti->lock);
@@ -459,7 +472,7 @@
 		}
 	}
 
-	jack_engine_place_port_buffers (engine, ptid, one_buffer, size, nports);
+	jack_engine_place_port_buffers (engine, ptid, one_buffer, size, nports, engine->control->buffer_size);
 
 #ifdef USE_MLOCK
 	if (engine->control->real_time) {
@@ -937,6 +950,44 @@
 }
 #endif /* !JACK_USE_MACH_THREADS */
 
+void
+jack_engine_munge_backend_port_names (jack_engine_t* engine)
+{
+	int out_cnt = 1;
+	int in_cnt = 1;
+	int i;
+	char* backend_client_name = (char*) engine->driver->internal_client->control->name;
+	size_t len = strlen (backend_client_name);
+
+	for (i = 0; i < engine->port_max; i++) {
+		jack_port_shared_t* port = &engine->control->ports[i];
+
+		if (strncmp (port->name, backend_client_name, len) == 0) {
+
+			/* save the backend's own name */
+
+			char name[JACK_CLIENT_NAME_SIZE+JACK_PORT_NAME_SIZE];
+			snprintf (name, sizeof (name), "%s", engine->control->ports[i].name);
+
+			/* replace input port names, and use backend's original as an alias */
+
+			if ((port->flags & (JackPortIsPhysical|JackPortIsInput)) == (JackPortIsPhysical|JackPortIsInput)) {
+				snprintf (port->name, sizeof (port->name), "system:playback_%d", out_cnt++);
+				strcpy (port->alias1, name);
+				continue;
+			} 
+
+			/* replace output port names, and use backend's original as an alias */
+
+			if ((port->flags & (JackPortIsPhysical|JackPortIsOutput)) == (JackPortIsPhysical|JackPortIsOutput)) {
+				snprintf (port->name, sizeof (port->name), "system:capture_%d", in_cnt++);
+				strcpy (port->alias1, name);
+				continue;
+			} 
+		}
+	}
+}
+
 static jack_driver_info_t *
 jack_load_driver (jack_engine_t *engine, jack_driver_desc_t * driver_desc)
 {
@@ -1285,6 +1336,13 @@
 		req->status = 0;
 		break;
 
+	case RecomputeTotalLatency:
+		jack_lock_graph (engine);
+		jack_compute_port_total_latency (engine, &engine->control->ports[req->x.port_info.port_id]);
+		jack_unlock_graph (engine);
+		req->status = 0;
+		break;
+
 	default:
 		/* some requests are handled entirely on the client
 		 * side, by adjusting the shared memory area(s) */
@@ -1529,7 +1587,7 @@
 jack_engine_new (int realtime, int rtpriority, int do_mlock, int do_unlock,
 		 const char *server_name, int temporary, int verbose,
 		 int client_timeout, unsigned int port_max, pid_t wait_pid,
-		 jack_nframes_t frame_time_offset, JSList *drivers)
+		 jack_nframes_t frame_time_offset, int nozombies, JSList *drivers)
 {
 	jack_engine_t *engine;
 	unsigned int i;
@@ -1594,6 +1652,7 @@
 	engine->freewheeling = 0;
 	engine->feedbackcount = 0;
 	engine->wait_pid = wait_pid;
+	engine->nozombies = nozombies;
 
 	jack_engine_reset_rolling_usecs (engine);
 	engine->max_usecs = 0.0f;
@@ -1671,6 +1730,8 @@
 	for (i = 0; i < engine->port_max; i++) {
 		engine->control->ports[i].in_use = 0;
 		engine->control->ports[i].id = i;
+		engine->control->ports[i].alias1[0] = '\0';
+		engine->control->ports[i].alias2[0] = '\0';
 	}
 
 	/* allocate internal port structures so that we can keep track
@@ -2219,6 +2280,34 @@
 	jack_unlock_graph (engine);
 }
 
+static void
+jack_notify_all_port_interested_clients (jack_engine_t *engine, jack_port_id_t a, jack_port_id_t b, int connected)
+{
+	JSList *node;
+	jack_event_t event;
+
+	event.type = (connected ? PortConnected : PortDisconnected);
+	event.x.self_id = a;
+	event.y.other_id = b;
+	
+	/* GRAPH MUST BE LOCKED : see callers of jack_send_connection_notification() 
+	 */
+
+	for (node = engine->clients; node; node = jack_slist_next (node)) {
+		jack_client_internal_t* client;
+
+		client = (jack_client_internal_t*) node->data;
+
+		if (client->control->port_connect != NULL) {
+			
+			/* one of the ports belong to this client or it has a port connect callback */
+			
+			jack_deliver_event (engine, client, &event);
+			
+		} 
+	}
+}
+
 static int
 jack_deliver_event (jack_engine_t *engine, jack_client_internal_t *client,
 		    jack_event_t *event)
@@ -2603,12 +2692,23 @@
 }
 
 static void
+jack_compute_port_total_latency (jack_engine_t* engine, jack_port_shared_t* port)
+{
+	if (port->in_use) {
+		port->total_latency =
+			jack_get_port_total_latency (
+				engine, &engine->internal_ports[port->id],
+				0, !(port->flags & JackPortIsOutput));
+	}
+}
+
+static void
 jack_compute_all_port_total_latencies (jack_engine_t *engine)
 {
 	jack_port_shared_t *shared = engine->control->ports;
 	unsigned int i;
-	int toward_port;
-
+ 	int toward_port;
+ 
 	for (i = 0; i < engine->control->port_max; i++) {
 		if (shared[i].in_use) {
 			if (shared[i].flags & JackPortIsOutput) {
@@ -2914,18 +3014,6 @@
 		return -1;
 	}
 
-	if (srcport->shared->locked) {
-		jack_error ("source port %s is locked against connection"
-			    " changes", source_port);
-		return -1;
-	}
-
-	if (dstport->shared->locked) {
-		jack_error ("destination port %s is locked against connection"
-			    " changes", destination_port);
-		return -1;
-	}
-
 	if (srcport->shared->ptype_id != dstport->shared->ptype_id) {
 		jack_error ("ports used in attemped connection are not of "
 			    "the same data type");
@@ -3072,10 +3160,16 @@
 		jack_send_connection_notification (engine,
 						   srcport->shared->client_id,
 						   src_id, dst_id, TRUE);
+		
+
 		jack_send_connection_notification (engine,
 						   dstport->shared->client_id,
 						   dst_id, src_id, TRUE);
 						   
+		/* send a port connection notification just once to everyone who cares */
+
+		jack_notify_all_port_interested_clients (engine, src_id, dst_id, 1);
+
 		jack_sort_graph (engine);
 	}
 
@@ -3137,6 +3231,10 @@
 				engine, dstport->shared->client_id, dst_id,
 				src_id, FALSE);
 
+			/* send a port connection notification just once to everyone who cares */
+			
+			jack_notify_all_port_interested_clients (engine, src_id, dst_id, 0);
+
 			if (connect->dir) {
 			
 				jack_client_internal_t *src;
@@ -3374,6 +3472,8 @@
 {
 	pthread_mutex_lock (&engine->port_lock);
 	port->shared->in_use = 0;
+	port->shared->alias1[0] = '\0';
+	port->shared->alias2[0] = '\0';
 
 	if (port->buffer_info) {
 		jack_port_buffer_list_t *blist =
@@ -3396,7 +3496,7 @@
 	pthread_mutex_lock (&engine->port_lock);
 
 	for (id = 0; id < engine->port_max; id++) {
-		if (strcmp (engine->control->ports[id].name, name) == 0) {
+		if (jack_port_name_equals (&engine->control->ports[id], name)) {
 			break;
 		}
 	}
@@ -3438,12 +3538,19 @@
 						  req->x.port_info.client_id))
 	    == NULL) {
 		jack_error ("unknown client id in port registration request");
+		jack_unlock_graph (engine);
+		return -1;
+	}
+
+	if ((port = jack_get_port_by_name(engine, req->x.port_info.name)) != NULL) {
+		jack_error ("duplicate port name in port registration request");
+		jack_unlock_graph (engine);
 		return -1;
 	}
-	jack_unlock_graph (engine);
 
 	if ((port_id = jack_get_free_port (engine)) == (jack_port_id_t) -1) {
 		jack_error ("no ports available!");
+		jack_unlock_graph (engine);
 		return -1;
 	}
 
@@ -3455,7 +3562,6 @@
 	shared->flags = req->x.port_info.flags;
 	shared->latency = 0;
 	shared->monitor_requests = 0;
-	shared->locked = 0;
 
 	port = &engine->internal_ports[port_id];
 
@@ -3465,10 +3571,11 @@
 	
 	if (jack_port_assign_buffer (engine, port)) {
 		jack_error ("cannot assign buffer for port");
+		jack_port_release (engine, &engine->internal_ports[port_id]);
+		jack_unlock_graph (engine);
 		return -1;
 	}
 
-	jack_lock_graph (engine);
 	client->ports = jack_slist_prepend (client->ports, port);
 	jack_port_registration_notify (engine, port_id, TRUE);
 	jack_unlock_graph (engine);
@@ -3652,6 +3759,41 @@
 	}
 }
 
+void
+jack_client_registration_notify (jack_engine_t *engine,
+				 const char* name, int yn)
+{
+	jack_event_t event;
+	jack_client_internal_t *client;
+	JSList *node;
+
+	event.type = (yn ? ClientRegistered : ClientUnregistered);
+	snprintf (event.x.name, sizeof (event.x.name), "%s", name);
+	
+	for (node = engine->clients; node; node = jack_slist_next (node)) {
+		
+		client = (jack_client_internal_t *) node->data;
+
+		if (!client->control->active) {
+			continue;
+		}
+
+		if (strcmp ((char*) client->control->name, (char*) name) == 0) {
+			/* do not notify client of its own registration */
+			continue;
+		}
+
+		if (client->control->client_register) {
+			if (jack_deliver_event (engine, client, &event)) {
+				jack_error ("cannot send client registration"
+					    " notification to %s (%s)",
+					     client->control->name,
+					    strerror (errno));
+			}
+		}
+	}
+}
+
 int
 jack_port_assign_buffer (jack_engine_t *engine, jack_port_internal_t *port)
 {
@@ -3696,7 +3838,7 @@
 
 	for (id = 0; id < engine->port_max; id++) {
 		if (engine->control->ports[id].in_use &&
-		    strcmp (engine->control->ports[id].name, name) == 0) {
+		    jack_port_name_equals (&engine->control->ports[id], name)) {
 			return &engine->internal_ports[id];
 		}
 	}
@@ -3712,8 +3854,8 @@
 
 {
 	jack_client_internal_t *client;
-	jack_event_t event;
-
+ 	jack_event_t event;
+ 
 	if ((client = jack_client_internal_by_id (engine, client_id)) == NULL) {
 		jack_error ("no such client %" PRIu32
 			    " during connection notification", client_id);
diff -NPur jack-audio-connection-kit-0.103.0.orig/jackd/jackd.1.in jack/jackd/jackd.1.in
--- jack-audio-connection-kit-0.103.0.orig/jackd/jackd.1.in	2006-06-22 11:39:02.000000000 +0700
+++ jack/jackd/jackd.1.in	2007-08-25 15:30:43.000000000 +0700
@@ -89,6 +89,12 @@
 Set client timeout limit in milliseconds.  The default is 500 msec.
 In realtime mode the client timeout must be smaller than the watchdog timeout (5000 msec).
 .TP
+\fB\-Z, \-\-nozombies\fR
+.br
+Prevent JACK from ever kicking out clients because they were too slow.
+This cancels the effect any specified timeout value, but JACK and its clients are
+still subject to the supervision of the watchdog thread or its equivalent.
+.TP
 \fB\-u, \-\-unlock\fR
 .br
 Unlock libraries GTK+, QT, FLTK, Wine.
@@ -169,6 +175,10 @@
 a larger buffer.  If so, JACK will use the smallest possible buffer
 containing at least \fB\-\-nperiods\fR, but the playback latency does
 not increase.
+
+For USB audio devices it is recommended to use \fB\-n 3\fR. Firewire
+devices supported by FFADO (formerly Freebob) are configured with
+\fB\-n 3\fR by default.
 .TP
 \fB\-o, \-\-outchannels \fIint\fR
 .br
@@ -180,11 +190,11 @@
 .TP
 \fB\-p, \-\-period \fIint\fR
 .br
-Specify the number of frames between JACK \fBprocess()\fR calls.  The
-default is 1024.  If you need low latency, set \fB\-p\fR as low as you
-can go without seeing xruns.  A larger period size yields higher
-latency, but makes xruns less likely.  The JACK capture latency in
-seconds is \fB\-\-period\fR divided by \fB\-\-rate\fR.
+Specify the number of frames between JACK \fBprocess()\fR calls.  This
+value must be a power of 2, and the default is 1024.  If you need low 
+latency, set \fB\-p\fR as low as you can go without seeing xruns.  A larger 
+period size yields higher latency, but makes xruns less likely.  The JACK 
+capture latency in seconds is \fB\-\-period\fR divided by \fB\-\-rate\fR.
 .TP
 \fB\-r, \-\-rate \fIint\fR
 Specify the sample rate.  The default is 48000.
@@ -222,7 +232,7 @@
 Sample rate (default: 44100)
 .TP
 \fB\-p \-\-period\fR
-Frames per period (default: 128)
+Frames per period (default: 128). Must be a power of 2.
 .TP
 \fB\-n \-\-name\fR
 Driver name (default: none)
@@ -241,11 +251,11 @@
 Specify sample rate. The default value is 48000.
 .TP
 \fB\-p, \-\-period \fIint\fR
-Specify number of frames per period. The default value is 1024.
-If you need low latency, set \fB\-p\fR as low as you
-can go without seeing xruns.  A larger period size yields higher
-latency, but makes xruns less likely.  The JACK capture latency in
-seconds is \fB\-\-period\fR divided by \fB\-\-rate\fR.
+Specify the number of frames between JACK \fBprocess()\fR calls.  This
+value must be a power of 2, and the default is 1024.  If you need low 
+latency, set \fB\-p\fR as low as you can go without seeing xruns.  A larger 
+period size yields higher latency, but makes xruns less likely.  The JACK 
+capture latency in seconds is \fB\-\-period\fR divided by \fB\-\-rate\fR.
 .TP
 \fB\-w, \-\-wait \fIint\fR 
 Specify number of usecs to wait between engine processes. 
@@ -256,11 +266,11 @@
 Specify the sample rate.  The default is 48000.
 .TP
 \fB\-p, \-\-period \fIint\fR
-Specify number of frames between JACK \fBprocess()\fR calls.  The
-default is 1024.  If you need low latency, set \fB\-p\fR as low as you
-can go without seeing xruns.  A larger period size yields higher
-latency, but makes xruns less likely.  The JACK capture latency in
-seconds is \fB\-\-period\fR divided by \fB\-\-rate\fR.
+Specify the number of frames between JACK \fBprocess()\fR calls.  This
+value must be a power of 2, and the default is 1024.  If you need low 
+latency, set \fB\-p\fR as low as you can go without seeing xruns.  A larger 
+period size yields higher latency, but makes xruns less likely.  The JACK 
+capture latency in seconds is \fB\-\-period\fR divided by \fB\-\-rate\fR.
 .TP
 \fB\-n, \-\-nperiods \fIint\fR
 Specify the number of periods in the hardware buffer.  The default is
@@ -309,7 +319,7 @@
 Sample rate (default: 48000)
 .TP
 \fB\-p \-\-period\fR
-Frames per period (default: 1024)
+Frames per period (default: 1024). Must be a power of 2.
 .TP
 \fB\-n \-\-name\fR
 Driver name (default: none)
diff -NPur jack-audio-connection-kit-0.103.0.orig/jackd/jackd.c jack/jackd/jackd.c
--- jack-audio-connection-kit-0.103.0.orig/jackd/jackd.c	2007-03-06 12:24:05.000000000 +0700
+++ jack/jackd/jackd.c	2007-08-25 15:30:43.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
-    $Id: jackd.c 1010 2007-02-23 19:23:07Z paul $
 */
 
 #include <config.h>
@@ -66,6 +65,7 @@
 static unsigned int port_max = 256;
 static int do_unlock = 0;
 static jack_nframes_t frame_time_offset = 0;
+static int nozombies = 0;
 
 static void 
 do_nothing_handler (int sig)
@@ -146,7 +146,8 @@
 	if ((engine = jack_engine_new (realtime, realtime_priority, 
 				       do_mlock, do_unlock, server_name,
 				       temporary, verbose, client_timeout,
-				       port_max, getpid(), frame_time_offset, drivers)) == 0) {
+				       port_max, getpid(), frame_time_offset, 
+				       nozombies, drivers)) == 0) {
 		fprintf (stderr, "cannot create engine\n");
 		return -1;
 	}
@@ -159,6 +160,8 @@
 		goto error;
 	}
 
+	jack_engine_munge_backend_port_names (engine);
+
 	if (engine->driver->start (engine->driver) != 0) {
 		jack_error ("cannot start driver");
 		goto error;
@@ -372,6 +375,7 @@
 "             [ --clocksource OR -c [ c(ycle) | h(pet) | s(ystem) ]\n"
 "             [ --silent OR -s ]\n"
 "             [ --version OR -V ]\n"
+"             [ --nozombies OR -Z ]\n"
 "         -d backend [ ... backend args ... ]\n"
 "             The backend can be `alsa', `coreaudio', `dummy',\n"
 "                                `freebob', `oss' or `portaudio'.\n\n"
@@ -525,6 +529,7 @@
 		{ "version", 0, 0, 'V' },
 		{ "silent", 0, 0, 's' },
 		{ "clock-source", 1, 0, 'c' },
+		{ "nozombies", 0, 0, 'Z' },
 		{ 0, 0, 0, 0 }
 	};
 	int opt = 0;
@@ -619,6 +624,10 @@
 			show_version = 1;
 			break;
 
+		case 'Z':
+			nozombies = 1;
+			break;
+
 		default:
 			fprintf (stderr, "Unknown option character %c\n",
 				 optopt);
diff -NPur jack-audio-connection-kit-0.103.0.orig/jackd/md5.c jack/jackd/md5.c
--- jack-audio-connection-kit-0.103.0.orig/jackd/md5.c	2006-05-26 09:45:24.000000000 +0700
+++ jack/jackd/md5.c	2007-08-25 15:30:43.000000000 +0700
@@ -23,7 +23,6 @@
  * Written by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
  * Modified by Gray Watson <http://256.com/gray/>, 1997.
  *
- * $Id: md5.c 214 2002-05-24 19:28:45Z wingo $
  */
 
 /*
@@ -54,7 +53,6 @@
 #include "md5_loc.h"
 
 /* static	char	*rcs_id =
-   "$Id: md5.c 214 2002-05-24 19:28:45Z wingo $"; */
 
 /* version id for the library */
 /* static char *version_id = "$MD5Version: 1.0.0 November-19-1997 $"; */
diff -NPur jack-audio-connection-kit-0.103.0.orig/jackd/md5.h jack/jackd/md5.h
--- jack-audio-connection-kit-0.103.0.orig/jackd/md5.h	2006-05-26 09:45:24.000000000 +0700
+++ jack/jackd/md5.h	2007-08-25 15:30:43.000000000 +0700
@@ -20,7 +20,6 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  * 02111-1307, USA.
  *
- * $Id: md5.h 214 2002-05-24 19:28:45Z wingo $
  */
 
 /*
diff -NPur jack-audio-connection-kit-0.103.0.orig/jackd/md5_loc.h jack/jackd/md5_loc.h
--- jack-audio-connection-kit-0.103.0.orig/jackd/md5_loc.h	2006-05-26 09:45:24.000000000 +0700
+++ jack/jackd/md5_loc.h	2007-08-25 15:30:43.000000000 +0700
@@ -1,7 +1,6 @@
 /*
  * Local defines for the md5 functions.
  *
- * $Id: md5_loc.h 237 2002-06-12 14:30:12Z pbd $
  */
 
 /*
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/Makefile.am jack/libjack/Makefile.am
--- jack-audio-connection-kit-0.103.0.orig/libjack/Makefile.am	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/Makefile.am	2007-08-25 15:30:34.000000000 +0700
@@ -23,7 +23,8 @@
              time.c \
 	     timestamps.c \
 	     transclient.c \
-	     unlock.c
+	     unlock.c \
+	     simd.c
 
 lib_LTLIBRARIES	= libjack.la
 
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/client.c jack/libjack/client.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/client.c	2007-03-06 12:24:05.000000000 +0700
+++ jack/libjack/client.c	2007-08-25 15:30:34.000000000 +0700
@@ -17,7 +17,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: client.c 1010 2007-02-23 19:23:07Z paul $
 */
 
 #include <config.h>
@@ -62,15 +61,8 @@
 #include <sysdeps/pThreadUtilities.h>
 #endif
 
-#ifdef WITH_TIMESTAMPS
-#include <jack/timestamps.h>
-#endif /* WITH_TIMESTAMPS */
-
 static pthread_mutex_t client_lock;
 static pthread_cond_t  client_ready;
-#ifdef ARCH_X86
-int cpu_type = 0;
-#endif /* ARCH_X86 */
 
 #define EVENT_POLL_INDEX 0
 #define WAIT_POLL_INDEX 1
@@ -87,98 +79,7 @@
 
 #ifdef ARCH_X86
 
-static int
-have_3dnow ()
-{
-	unsigned int res = 0;
-
-#ifdef __x86_64__
-	asm volatile ("pushq %%rbx\n\t" : : : "memory");
-#else
-	asm volatile ("pushl %%ebx\n\t" : : : "memory");
-#endif
-	asm volatile (
-		"movl $0x80000000, %%eax\n\t" \
-		"cpuid\n\t" \
-		"cmpl $0x80000001, %%eax\n\t" \
-		"jl tdnow_prexit\n\t" \
-		\
-		"movl $0x80000001, %%eax\n\t" \
-		"cpuid\n\t" \
-		\
-		"xorl %%eax, %%eax\n\t" \
-		\
-		"movl $1, %%ecx\n\t" \
-		"shll $31, %%ecx\n\t" \
-		"testl %%ecx, %%edx\n\t" \
-		"jz tdnow_testexit\n\t" \
-		"movl $1, %%eax\n\t" \
-		\
-		"movl $1, %%ecx\n\t" \
-		"shll $30, %%ecx\n\t" \
-		"testl %%ecx, %%edx\n\t" \
-		"jz tdnow_testexit\n\t" \
-		"movl $2, %%eax\n\t" \
-		"jmp tdnow_testexit\n\t" \
-		\
-		"tdnow_prexit:\n\t" \
-		"xorl %%eax, %%eax\n\t" \
-		"tdnow_testexit:\n\t"
-		: "=a" (res)
-		:
-		: "ecx", "edx", "memory");
-#ifdef __x86_64__
-	asm volatile ("popq %%rbx\n\t" : : : "memory");
-#else
-	asm volatile ("popl %%ebx\n\t" : : : "memory");
-#endif
-	return res;
-}
-
-static int
-have_sse ()
-{
-	unsigned int res = 0;
-
-#ifdef __x86_64__
-	asm volatile ("pushq %%rbx\n\t" : : : "memory");
-#else
-	asm volatile ("pushl %%ebx\n\t" : : : "memory");
-#endif
-	asm volatile (
-		"movl $1, %%eax\n\t" \
-		"cpuid\n\t" \
-		\
-		"xorl %%eax, %%eax\n\t" \
-		\
-		"movl $1, %%ebx\n\t" \
-		"shll $25, %%ebx\n\t" \
-		"testl %%ebx, %%edx\n\t" \
-		"jz sse_testexit\n\t" \
-		"movl $1, %%eax\n\t" \
-		\
-		"movl $1, %%ebx\n\t" \
-		"shll $26, %%ebx\n\t" \
-		"testl %%ebx, %%edx\n\t" \
-		"jz sse_testexit\n\t" \
-		"movl $2, %%eax\n\t" \
-		\
-		"movl $1, %%ebx\n\t" \
-		"testl %%ebx, %%ecx\n\t" \
-		"jz sse_testexit\n\t" \
-		"movl $3, %%eax\n\t" \
-		\
-		"sse_testexit:\n\t"
-		: "=a" (res)
-		:
-		: "ecx", "edx", "memory");
-#ifdef __x86_64__
-	asm volatile ("popq %%rbx\n\t" : : : "memory");
-#else
-	asm volatile ("popl %%ebx\n\t" : : : "memory");
-#endif
-	return res;
-}
+int cpu_type = 0;
 
 static void
 init_cpu ()
@@ -236,8 +137,6 @@
 	memcpy (jack_tmpdir, buf, len-1);
 	jack_tmpdir[len-1] = '\0';
 	
-	fprintf (stderr, "JACK tmpdir identified as [%s]\n", jack_tmpdir);
-
 	fclose (in);
 	return 0;
 }
@@ -429,54 +328,68 @@
 jack_client_handle_port_connection (jack_client_t *client, jack_event_t *event)
 {
 	jack_port_t *control_port;
-	jack_port_t *other;
+	jack_port_t *other = 0;
 	JSList *node;
 	int need_free = FALSE;
 
-	switch (event->type) {
-	case PortConnected:
-		other = jack_port_new (client, event->y.other_id,
-				       client->engine);
-		/* jack_port_by_id_int() always returns an internal
-		 * port that does not need to be deallocated */
-		control_port = jack_port_by_id_int (client, event->x.self_id,
-						    &need_free);
-		pthread_mutex_lock (&control_port->connection_lock);
-		control_port->connections =
-			jack_slist_prepend (control_port->connections,
-					    (void *) other);
-		pthread_mutex_unlock (&control_port->connection_lock);
-		break;
+	if (client->engine->ports[event->x.self_id].client_id == client->control->id ||
+	    client->engine->ports[event->y.other_id].client_id == client->control->id) {
+
+		/* its one of ours */
+
+		switch (event->type) {
+		case PortConnected:
+			other = jack_port_new (client, event->y.other_id,
+					       client->engine);
+			/* jack_port_by_id_int() always returns an internal
+			 * port that does not need to be deallocated 
+			 */
+			control_port = jack_port_by_id_int (client, event->x.self_id,
+							    &need_free);
+			pthread_mutex_lock (&control_port->connection_lock);
+			control_port->connections =
+				jack_slist_prepend (control_port->connections,
+						    (void *) other);
+			pthread_mutex_unlock (&control_port->connection_lock);
+			break;
+			
+		case PortDisconnected:
+			/* jack_port_by_id_int() always returns an internal
+			 * port that does not need to be deallocated 
+			 */
+			control_port = jack_port_by_id_int (client, event->x.self_id,
+							    &need_free);
+			pthread_mutex_lock (&control_port->connection_lock);
+			
+			for (node = control_port->connections; node;
+			     node = jack_slist_next (node)) {
+				
+				other = (jack_port_t *) node->data;
 
-	case PortDisconnected:
-		/* jack_port_by_id_int() always returns an internal
-		 * port that does not need to be deallocated */
-		control_port = jack_port_by_id_int (client, event->x.self_id,
-						    &need_free);
-		pthread_mutex_lock (&control_port->connection_lock);
-
-		for (node = control_port->connections; node;
-		     node = jack_slist_next (node)) {
-
-			other = (jack_port_t *) node->data;
-
-			if (other->shared->id == event->y.other_id) {
-				control_port->connections =
-					jack_slist_remove_link (
-						control_port->connections,
-						node);
-				jack_slist_free_1 (node);
-				free (other);
-				break;
+				if (other->shared->id == event->y.other_id) {
+					control_port->connections =
+						jack_slist_remove_link (
+							control_port->connections,
+							node);
+					jack_slist_free_1 (node);
+					free (other);
+					break;
+				}
 			}
+			
+			pthread_mutex_unlock (&control_port->connection_lock);
+			break;
+			
+		default:
+			/* impossible */
+			break;
 		}
+	}
 
-		pthread_mutex_unlock (&control_port->connection_lock);
-		break;
-
-	default:
-		/* impossible */
-		break;
+	if (client->control->port_connect) {
+		client->control->port_connect (event->x.self_id, event->y.other_id,
+					       (event->type == PortConnected ? 1 : 0), 
+					       client->control->port_connect_arg);
 	}
 
 	return 0;
@@ -1162,8 +1075,13 @@
 
 	/* format the path name on the first call */
 	if (user_dir[0] == '\0') {
-		snprintf (user_dir, sizeof (user_dir), "%s/jack-%d",
-			  jack_tmpdir, getuid ());
+		if (getenv ("JACK_PROMISCUOUS_SERVER")) {
+			snprintf (user_dir, sizeof (user_dir), "%s/jack",
+				  jack_tmpdir);
+		} else {
+			snprintf (user_dir, sizeof (user_dir), "%s/jack-%d",
+				  jack_tmpdir, getuid ());
+		}
 	}
 
 	return user_dir;
@@ -1217,6 +1135,16 @@
 }
 
 int
+jack_recompute_total_latency (jack_client_t* client, jack_port_t* port)
+{
+	jack_request_t request;
+
+	request.type = RecomputeTotalLatency;
+	request.x.port_info.port_id = port->shared->id;
+	return jack_client_deliver_request (client, &request);
+}
+
+int
 jack_set_freewheel (jack_client_t* client, int onoff)
 {
 	jack_request_t request;
@@ -1263,89 +1191,187 @@
 	}
 }
 
-static void *
-jack_client_thread (void *arg)
+static void
+jack_client_thread_suicide (jack_client_t* client)
 {
-	jack_client_t *client = (jack_client_t *) arg;
-	jack_client_control_t *control = client->control;
-	jack_event_t event;
-	char status = 0;
-	int err = 0;
-#ifndef JACK_USE_MACH_THREADS                   
-	char c = 0;
-#endif
-
-	pthread_mutex_lock (&client_lock);
-	client->thread_ok = TRUE;
-	client->thread_id = pthread_self();
-	pthread_cond_signal (&client_ready);
-	pthread_mutex_unlock (&client_lock);
+	if (client->on_shutdown) {
+		jack_error ("zombified - calling shutdown handler");
+		client->on_shutdown (client->on_shutdown_arg);
+	} else {
+		jack_error ("jack_client_thread zombified - exiting from JACK");
+		jack_client_close (client);
+		/* Need a fix : possibly make client crash if
+		 * zombified without shutdown handler 
+		 */
+	}
 
-	client->control->pid = getpid();
-	client->control->pgrp = getpgrp();
+	pthread_exit (0);
+	/*NOTREACHED*/
+}
 
-	DEBUG ("client thread is now running");
+static int
+jack_client_process_events (jack_client_t* client)
+{
+	jack_event_t event;
+	char status = 0;
+	jack_client_control_t *control = client->control;
 
-	if (client->control->thread_init) {
-		DEBUG ("calling client thread init callback");
-		client->control->thread_init (client->control->thread_init_arg);
+	if (client->pollfd[EVENT_POLL_INDEX].revents & POLLIN) {
+		
+		DEBUG ("client receives an event, "
+		       "now reading on event fd");
+                
+		/* server has sent us an event. process the
+		 * event and reply */
+		
+		if (read (client->event_fd, &event, sizeof (event))
+		    != sizeof (event)) {
+			jack_error ("cannot read server event (%s)",
+				    strerror (errno));
+			return -1;
+		}
+		
+		status = 0;
+		
+		switch (event.type) {
+		case PortRegistered:
+			if (control->port_register) {
+				control->port_register
+					(event.x.port_id, TRUE,
+					 control->port_register_arg);
+			} 
+			break;
+			
+		case PortUnregistered:
+			if (control->port_register) {
+				control->port_register
+					(event.x.port_id, FALSE,
+					 control->port_register_arg);
+			}
+			break;
+			
+		case ClientRegistered:
+			if (control->client_register) {
+				control->client_register
+					(event.x.name, TRUE,
+					 control->client_register_arg);
+			} 
+			break;
+			
+		case ClientUnregistered:
+			if (control->client_register) {
+				control->client_register
+					(event.x.name, FALSE,
+					 control->client_register_arg);
+			}
+			break;
+			
+		case GraphReordered:
+			status = jack_handle_reorder (client, &event);
+			break;
+			
+		case PortConnected:
+		case PortDisconnected:
+			status = jack_client_handle_port_connection
+				(client, &event);
+			break;
+			
+		case BufferSizeChange:
+			jack_client_invalidate_port_buffers (client);
+			if (control->bufsize) {
+				status = control->bufsize
+					(control->nframes,
+					 control->bufsize_arg);
+			} 
+			break;
+			
+		case SampleRateChange:
+			if (control->srate) {
+				status = control->srate
+					(control->nframes,
+					 control->srate_arg);
+			}
+			break;
+			
+		case XRun:
+			if (control->xrun) {
+				status = control->xrun
+					(control->xrun_arg);
+			}
+			break;
+			
+		case AttachPortSegment:
+			jack_attach_port_segment (client, event.y.ptid);
+			break;
+			
+		case StartFreewheel:
+			jack_start_freewheel (client);
+			break;
+			
+		case StopFreewheel:
+			jack_stop_freewheel (client);
+			break;
+		}
+		
+		DEBUG ("client has dealt with the event, writing "
+		       "response on event fd");
+		
+		if (write (client->event_fd, &status, sizeof (status))
+		    != sizeof (status)) {
+			jack_error ("cannot send event response to "
+				    "engine (%s)", strerror (errno));
+			return -1;
+		}
 	}
 
-	while (err == 0) {
-	
-		if (client->engine->engine_ok == 0) {
-		     if (client->on_shutdown)
-			     client->on_shutdown (client->on_shutdown_arg);
-		     else
-			     jack_error ("engine unexpectedly shutdown; "
-					 "thread exiting\n");
-		     pthread_exit (0);
-		}
+	return 0;
+}
 
-		DEBUG ("client polling on %s", client->pollmax == 2 ? 
-		       "event_fd and graph_wait_fd..." :
-		       "event_fd only");
+static int
+jack_client_core_wait (jack_client_t* client)
+{
+	jack_client_control_t *control = client->control;
 
+	DEBUG ("client polling on %s", client->pollmax == 2 ? 
+	       "event_fd and graph_wait_fd..." :
+	       "event_fd only");
+	
+	while (1) {
 		if (poll (client->pollfd, client->pollmax, 1000) < 0) {
 			if (errno == EINTR) {
 				continue;
 			}
 			jack_error ("poll failed in client (%s)",
 				    strerror (errno));
-			status = -1;
-			break;
+			return -1;
 		}
-                
+
+		pthread_testcancel();
+
+#ifndef JACK_USE_MACH_THREADS 
+		
 		/* get an accurate timestamp on waking from poll for a
 		 * process() cycle. 
 		 */
-
-	#ifndef JACK_USE_MACH_THREADS 
+		
 		if (client->graph_wait_fd >= 0
 		    && client->pollfd[WAIT_POLL_INDEX].revents & POLLIN) {
 			control->awake_at = jack_get_microseconds();
 		}
-	
+		
 		DEBUG ("pfd[EVENT].revents = 0x%x pfd[WAIT].revents = 0x%x",
 		       client->pollfd[EVENT_POLL_INDEX].revents,
 		       client->pollfd[WAIT_POLL_INDEX].revents);
-	#endif
-	
-		pthread_testcancel();
 		
-	#ifndef JACK_USE_MACH_THREADS 
 		if (client->graph_wait_fd >= 0 &&
 		    (client->pollfd[WAIT_POLL_INDEX].revents & ~POLLIN)) {
 			
-			DEBUG ("\n\n\n\n\n\n\n\nWAITFD ERROR,"
-			       " ZOMBIE\n\n\n\n\n");
-			
 			/* our upstream "wait" connection
 			   closed, which either means that
 			   an intermediate client exited, or
 			   jackd exited, or jackd zombified
 			   us.
-
+			   
 			   we can discover the zombification
 			   via client->control->dead, but
 			   the other two possibilities are
@@ -1356,250 +1382,175 @@
 			*/
 			
 			if (client->upstream_is_jackd) {
-                                DEBUG ("WE DIE\n");
-				goto zombie;
+				DEBUG ("WE DIE\n");
+				return 0;
 			} else {
-                                DEBUG ("WE PUNT\n");
+				DEBUG ("WE PUNT\n");
 				/* don't poll on the wait fd
 				 * again until we get a
 				 * GraphReordered event.
 				 */
-				 
+				
 				client->graph_wait_fd = -1;
 				client->pollmax = 1;
 			}
 		}
-	#endif
-
-		if (client->control->dead) {
-			goto zombie;
+#endif
+		
+		if (jack_client_process_events (client)) {
+			DEBUG ("event processing failed\n");
+			return 0;
 		}
-
-		if (client->pollfd[EVENT_POLL_INDEX].revents & ~POLLIN) {
-			/* jackd shutdown */
-			goto zombie;
+		
+		if ((client->pollfd[WAIT_POLL_INDEX].revents & POLLIN)) {
+			DEBUG ("time to run process()\n");
+			break;
 		}
+	}
 
-		if (client->pollfd[EVENT_POLL_INDEX].revents & POLLIN) {
-
-			DEBUG ("client receives an event, "
-			       "now reading on event fd");
-                
-			/* server has sent us an event. process the
-			 * event and reply */
-
-			if (read (client->event_fd, &event, sizeof (event))
-			    != sizeof (event)) {
-				jack_error ("cannot read server event (%s)",
-					    strerror (errno));
-				err++;
-				break;
-			}
-
-			status = 0;
-
-			switch (event.type) {
-			case PortRegistered:
-				if (control->port_register) {
-					control->port_register
-						(event.x.port_id, TRUE,
-						 control->port_register_arg);
-				} 
-				break;
-
-			case PortUnregistered:
-				if (control->port_register) {
-					control->port_register
-						(event.x.port_id, FALSE,
-						 control->port_register_arg);
-				}
-				break;
-
-			case GraphReordered:
-				status = jack_handle_reorder (client, &event);
-				break;
-
-			case PortConnected:
-			case PortDisconnected:
-				status = jack_client_handle_port_connection
-					(client, &event);
-				break;
-
-			case BufferSizeChange:
-				jack_client_invalidate_port_buffers (client);
-				if (control->bufsize) {
-					status = control->bufsize
-						(control->nframes,
-						 control->bufsize_arg);
-				} 
-				break;
-
-			case SampleRateChange:
-				if (control->srate) {
-					status = control->srate
-						(control->nframes,
-						 control->srate_arg);
-				}
-				break;
+	if (client->control->dead || client->pollfd[EVENT_POLL_INDEX].revents & ~POLLIN) {
+		DEBUG ("client appears dead or event pollfd has error status\n");
+		return -1;
+	}
 
-			case XRun:
-				if (control->xrun) {
-					status = control->xrun
-						(control->xrun_arg);
-				}
-				break;
+	return 0;
+}
 
-			case AttachPortSegment:
-				jack_attach_port_segment (client, event.y.ptid);
-				break;
-				
-			case StartFreewheel:
-				jack_start_freewheel (client);
-				break;
-
-			case StopFreewheel:
-				jack_stop_freewheel (client);
-				break;
-			}
+static int
+jack_wake_next_client (jack_client_t* client)
+{
+	char c = 0;
 
-			DEBUG ("client has dealt with the event, writing "
-			       "response on event fd");
+	if (write (client->graph_next_fd, &c, sizeof (c))
+	    != sizeof (c)) {
+		jack_error ("cannot continue execution of the "
+			    "processing graph (%s)",
+			    strerror(errno));
+		return -1;
+	}
+	
+	DEBUG ("client sent message to next stage by %" PRIu64
+	       ", client reading on graph_wait_fd==%d", 
+	       jack_get_microseconds(), client->graph_wait_fd);
+	
+	DEBUG("reading cleanup byte from pipe %d\n", client->graph_wait_fd);
+	
+	if ((read (client->graph_wait_fd, &c, sizeof (c))
+	     != sizeof (c))) {
+		jack_error ("cannot complete execution of the "
+			    "processing graph (%s)",
+			    strerror(errno));
+		return -1;
+	}
+	
+	return 0;
+}
 
-			if (write (client->event_fd, &status, sizeof (status))
-			    != sizeof (status)) {
-				jack_error ("cannot send event response to "
-					    "engine (%s)", strerror (errno));
-				err++;
-				break;
-			}
-		}
+static jack_nframes_t 
+jack_thread_first_wait (jack_client_t* client)
+{
+	if (jack_client_core_wait (client)) {
+		return 0;
+	}
+	return client->control->nframes;
+}
 		
+jack_nframes_t
+jack_thread_wait (jack_client_t* client, int status)
+{
+	jack_client_control_t *control = client->control;
 
-#ifndef JACK_USE_MACH_THREADS 
-		if (client->pollfd[WAIT_POLL_INDEX].revents & POLLIN) {
-
-#ifdef WITH_TIMESTAMPS
-			jack_reset_timestamps ();
-#endif
-
-			DEBUG ("client %d signalled at %" PRIu64
-			       ", awake for process at %" PRIu64
-			       " (delay = %" PRIu64
-			       " usecs) (wakeup on graph_wait_fd==%d)", 
-			       getpid(),
-			       control->signalled_at, 
-			       control->awake_at, 
-			       control->awake_at - control->signalled_at,
-			       client->pollfd[WAIT_POLL_INDEX].fd);
+   /* SECTION ONE: HOUSEKEEPING/CLEANUP FROM LAST DATA PROCESSING */
 
-			control->state = Running;
+	/* housekeeping/cleanup after data processing */
 
-			/* begin preemption checking */
-			CHECK_PREEMPTION (client->engine, TRUE);
-			
-			if (control->sync_cb)
-				jack_call_sync_client (client);
+	if (status == 0 && control->timebase_cb) {
+		jack_call_timebase_master (client);
+	}
+	
+	/* end preemption checking */
+	CHECK_PREEMPTION (client->engine, FALSE);
+	
+	control->finished_at = jack_get_microseconds();
+	
+	/* wake the next client in the chain (could be the server), 
+	   and check if we were killed during the process
+	   cycle.
+	*/
+	
+	if (jack_wake_next_client (client)) {
+		DEBUG("client cannot wake next, or is dead\n");
+		return 0;
+	}
 
-			if (control->process) {
-				if (control->process (control->nframes,
-						      control->process_arg)
-				    == 0) {
-					control->state = Finished;
-				}
-			} else {
-				control->state = Finished;
-			}
+	if (status || client->control->dead || !client->engine->engine_ok) {
+		return 0;
+	}
+	
+   /* SECTION TWO: WAIT FOR NEXT DATA PROCESSING TIME */
 
-			if (control->timebase_cb)
-				jack_call_timebase_master (client);
+	if (jack_client_core_wait (client)) {
+		return 0;
+	}
 
-			/* end preemption checking */
-			CHECK_PREEMPTION (client->engine, FALSE);
+   /* SECTION THREE: START NEXT DATA PROCESSING TIME */
 
-			control->finished_at = jack_get_microseconds();
+	/* Time to do data processing */
 
-#ifdef WITH_TIMESTAMPS
-			jack_timestamp ("finished");
-#endif
-		
-#ifndef JACK_USE_MACH_THREADS 			
-			/* pass the execution token along */
+	control->state = Running;
+	
+	/* begin preemption checking */
+	CHECK_PREEMPTION (client->engine, TRUE);
+	
+	if (control->sync_cb)
+		jack_call_sync_client (client);
 
-			DEBUG ("client finished processing at %" PRIu64
-			       " (elapsed = %" PRIu64
-			       " usecs), writing on graph_next_fd==%d", 
-			       control->finished_at, 
-			       control->finished_at - control->awake_at,
-			       client->graph_next_fd);
-
-			if (write (client->graph_next_fd, &c, sizeof (c))
-			    != sizeof (c)) {
-				jack_error ("cannot continue execution of the "
-					    "processing graph (%s)",
-					    strerror(errno));
-				err++;
-				break;
-			}
+	return control->nframes;
+}
 
-			DEBUG ("client sent message to next stage by %" PRIu64
-			       ", client reading on graph_wait_fd==%d", 
-			       jack_get_microseconds(), client->graph_wait_fd);
-#endif
+static void *
+jack_client_thread (void *arg)
+{
+	jack_client_t *client = (jack_client_t *) arg;
+	jack_client_control_t *control = client->control;
 
-#ifdef WITH_TIMESTAMPS
-			jack_timestamp ("read pending byte from wait");
-#endif
-			DEBUG("reading cleanup byte from pipe\n");
+	pthread_mutex_lock (&client_lock);
+	client->thread_ok = TRUE;
+	client->thread_id = pthread_self();
+	pthread_cond_signal (&client_ready);
+	pthread_mutex_unlock (&client_lock);
 
-#ifndef JACK_USE_MACH_THREADS
-			if ((read (client->graph_wait_fd, &c, sizeof (c))
-			     != sizeof (c))) {
-				DEBUG ("WARNING: READ FAILED!");
-#if 0
-				jack_error ("cannot complete execution of the "
-				            "processing graph (%s)",
-					    strerror(errno));
-				err++;
-				break;
-#endif
-			}
-#endif
+	control->pid = getpid();
+	control->pgrp = getpgrp();
 
-			/* check if we were killed during the process
-			 * cycle (or whatever) */
-			if (client->control->dead) {
-				goto zombie;
-			}
+	DEBUG ("client thread is now running");
 
-			DEBUG("process cycle fully complete\n");
+	if (control->thread_init) {
+		DEBUG ("calling client thread init callback");
+		control->thread_init (control->thread_init_arg);
+	}
 
-#ifdef WITH_TIMESTAMPS
-			jack_timestamp ("read done");
-			jack_dump_timestamps (stdout);
-#endif			
+	/* wait for first wakeup from server */
 
+	if (jack_thread_first_wait (client) == control->nframes) {
+		/* now run till we're done */
+		if (control->process) {
+			/* run process callback, then wait... ad-infinitum */
+			while (jack_thread_wait (client, 
+						 control->process (control->nframes, 
+								   control->process_arg)) ==
+			       control->nframes)
+				;
+		} else {
+			/* no process handling but still need to process events */
+			while (jack_thread_wait (client, 0) == control->nframes)
+				;
 		}
-#endif
-
-	}
-	
-	return (void *) ((intptr_t)err);
-
-  zombie:
-	if (client->on_shutdown) {
-		jack_error ("zombified - calling shutdown handler");
-		client->on_shutdown (client->on_shutdown_arg);
-	} else {
-		jack_error ("jack_client_thread zombified - exiting from JACK");
-		jack_client_close (client);
-		/* Need a fix : possibly make client crash if
-		 * zombified without shutdown handler 
-		 */
 	}
 
-	pthread_exit (0);
+	jack_client_thread_suicide (client);
 	/*NOTREACHED*/
-	return 0;
+	return (void *) 0;
 }
 
 #ifdef JACK_USE_MACH_THREADS
@@ -1654,9 +1605,6 @@
                 
 		control->finished_at = jack_get_microseconds();
                 
-#ifdef WITH_TIMESTAMPS
-		jack_timestamp ("finished");
-#endif
 		DEBUG ("client finished processing at %Lu (elapsed = %f usecs)",
 			control->finished_at,
 			((float)(control->finished_at - control->awake_at)));
@@ -2135,6 +2083,34 @@
 }
 
 int
+jack_set_port_connect_callback(jack_client_t *client,
+			       JackPortConnectCallback callback,
+			       void *arg)
+{
+	if (client->control->active) {
+		jack_error ("You cannot set callbacks on an active client.");
+		return -1;
+	}
+	client->control->port_connect_arg = arg;
+	client->control->port_connect = callback;
+	return 0;
+}
+
+int
+jack_set_client_registration_callback(jack_client_t *client,
+				      JackClientRegistrationCallback callback,
+				      void *arg)
+{
+	if (client->control->active) {
+		jack_error ("You cannot set callbacks on an active client.");
+		return -1;
+	}
+	client->control->client_register_arg = arg;
+	client->control->client_register = callback;
+	return 0;
+}
+
+int
 jack_get_process_done_fd (jack_client_t *client)
 {
 	return client->graph_next_fd;
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/driver.c jack/libjack/driver.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/driver.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/driver.c	2007-08-25 15:30:34.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
     
-    $Id: driver.c 893 2005-04-15 21:27:15Z pbd $
 */
 
 #include <config.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/intclient.c jack/libjack/intclient.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/intclient.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/intclient.c	2007-08-25 15:30:34.000000000 +0700
@@ -16,7 +16,6 @@
  *  along with this program; if not, write to the Free Software 
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
- *  $Id: intclient.c 806 2004-11-28 00:29:46Z joq $
  */
 
 #include <config.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/messagebuffer.c jack/libjack/messagebuffer.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/messagebuffer.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/messagebuffer.c	2007-08-25 15:30:34.000000000 +0700
@@ -23,7 +23,6 @@
  *  along with this program; if not, write to the Free Software 
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  *
- *  $Id: messagebuffer.c 841 2004-12-12 16:58:39Z joq $
  */
 
 #include <unistd.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/midiport.c jack/libjack/midiport.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/midiport.c	2007-01-17 07:48:45.000000000 +0700
+++ jack/libjack/midiport.c	2007-08-25 15:30:34.000000000 +0700
@@ -28,6 +28,7 @@
 
 
 typedef struct _jack_midi_port_info_private {
+	jack_nframes_t        nframes; /**< Number of frames in buffer */
  	size_t                buffer_size; /**< Size of buffer in bytes */
 	jack_nframes_t        event_count; /**< Number of events stored in this buffer */
 	jack_nframes_t        last_write_loc; /**< Used for both writing and mixdown */
@@ -44,11 +45,13 @@
 /* jack_midi_port_functions.buffer_init */
 static void
 jack_midi_buffer_init(void  *port_buffer,
-                       size_t buffer_size)
+                       size_t buffer_size,
+		       jack_nframes_t nframes)
 {
 	jack_midi_port_info_private_t *info =
 		(jack_midi_port_info_private_t *) port_buffer;
 	/* We can also add some magic field to midi buffer to validate client calls */
+	info->nframes = nframes;
 	info->buffer_size = buffer_size;
 	info->event_count = 0;
 	info->last_write_loc = 0;
@@ -57,8 +60,7 @@
 
 
 jack_nframes_t
-jack_midi_get_event_count(void           *port_buffer,
-                          jack_nframes_t  nframes)
+jack_midi_get_event_count(void           *port_buffer)
 {
 	jack_midi_port_info_private_t *info =
 		(jack_midi_port_info_private_t *) port_buffer;
@@ -69,8 +71,7 @@
 int
 jack_midi_event_get(jack_midi_event_t *event,
                     void              *port_buffer,
-                    jack_nframes_t     event_idx,
-                    jack_nframes_t     nframes)
+                    jack_nframes_t     event_idx)
 {
 	jack_midi_port_internal_event_t *port_event;
 	jack_midi_port_info_private_t *info =
@@ -91,8 +92,7 @@
 
 
 size_t
-jack_midi_max_event_size(void           *port_buffer,
-                         jack_nframes_t  nframes)
+jack_midi_max_event_size(void           *port_buffer)
 {
 	jack_midi_port_info_private_t *info =
 		(jack_midi_port_info_private_t *) port_buffer;
@@ -116,8 +116,7 @@
 jack_midi_data_t*
 jack_midi_event_reserve(void           *port_buffer,
                         jack_nframes_t  time, 
-                        size_t          data_size,
-                        jack_nframes_t  nframes)
+                        size_t          data_size)
 {
 	jack_midi_data_t *retbuf = (jack_midi_data_t *) port_buffer;
 
@@ -128,11 +127,11 @@
 	size_t buffer_size =
 		info->buffer_size;
 	
-	if (time < 0 || time >= nframes)
- 		return NULL;
+	if (time < 0 || time >= info->nframes)
+ 		goto failed;
  
  	if (info->event_count > 0 && time < event_buffer[info->event_count-1].time)
- 		return NULL;
+ 		goto failed;
 
 	/* Check if data_size is >0 and there is enough space in the buffer for the event. */
 	if (data_size <=0 ||
@@ -140,7 +139,7 @@
 			+ ((info->event_count + 1)
 			   * sizeof(jack_midi_port_internal_event_t))
 			+ data_size > buffer_size) {
-		return NULL;
+		goto failed;
 	} else {
 		info->last_write_loc += data_size;
 		retbuf = &retbuf[buffer_size - 1 - info->last_write_loc];
@@ -151,6 +150,9 @@
 		info->event_count += 1;
 		return retbuf;
 	}
+ failed:
+ 	info->events_lost++;
+	return NULL;
 }
 
 
@@ -158,11 +160,10 @@
 jack_midi_event_write(void                   *port_buffer,
                       jack_nframes_t          time,
                       const jack_midi_data_t *data,
-                      size_t                  data_size,
-                      jack_nframes_t          nframes)
+                      size_t                  data_size)
 {
 	jack_midi_data_t *retbuf =
-		jack_midi_event_reserve(port_buffer, time, data_size, nframes);
+		jack_midi_event_reserve(port_buffer, time, data_size);
 
 	if (retbuf) {
 		memcpy(retbuf, data, data_size);
@@ -179,8 +180,7 @@
  * been reset.
  */
 void
-jack_midi_clear_buffer(void           *port_buffer,
-                       jack_nframes_t  nframes)
+jack_midi_clear_buffer(void           *port_buffer)
 {
 	jack_midi_port_info_private_t *info =
 		(jack_midi_port_info_private_t *) port_buffer;
@@ -193,14 +193,14 @@
 
 /* jack_midi_port_functions.mixdown */
 static void
-jack_midi_port_mixdown(jack_port_t    *port,
-                       jack_nframes_t  nframes)
+jack_midi_port_mixdown(jack_port_t    *port, jack_nframes_t nframes)
 {
 	JSList         *node;
 	jack_port_t    *input;
 	jack_nframes_t  num_events = 0;
 	jack_nframes_t  i          = 0;
 	int             err        = 0;
+	jack_nframes_t  lost_events = 0;
 
 	/* The next (single) event to mix in to the buffer */
 	jack_midi_port_info_private_t   *earliest_info;
@@ -211,7 +211,7 @@
 	jack_midi_port_internal_event_t *in_events; /* Corresponds to in_info */
 	jack_midi_port_info_private_t   *out_info;  /* Output 'buffer' */
 
-	jack_midi_clear_buffer(port->mix_buffer, nframes);
+	jack_midi_clear_buffer(port->mix_buffer);
 	
 	out_info = (jack_midi_port_info_private_t *) port->mix_buffer;
 
@@ -228,6 +228,7 @@
 		in_info =
 			(jack_midi_port_info_private_t *) jack_output_port_buffer(input);
 		num_events += in_info->event_count;
+		lost_events += in_info->events_lost;
 		in_info->last_write_loc = 0;
 	}
 
@@ -267,8 +268,7 @@
 				jack_port_buffer(port),
 				earliest_event->time,
 				&earliest_buffer[earliest_event->byte_offset],
-				earliest_event->size,
-				nframes);
+				earliest_event->size);
 			
 			earliest_info->last_write_loc++;
 
@@ -279,12 +279,14 @@
 		}
 	}
 	assert(out_info->event_count == num_events - out_info->events_lost);
+
+	// inherit total lost events count from all connected ports.
+	out_info->events_lost += lost_events;
 }
 
 
 jack_nframes_t
-jack_midi_get_lost_event_count(void           *port_buffer,
-                               jack_nframes_t  nframes)
+jack_midi_get_lost_event_count(void           *port_buffer)
 {
 	return ((jack_midi_port_info_private_t *) port_buffer)->events_lost;
 }
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/pool.c jack/libjack/pool.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/pool.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/pool.c	2007-08-25 15:30:34.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
     
-    $Id: pool.c 673 2004-03-25 19:31:51Z joq $
 */
 
 #include <config.h>
@@ -33,7 +32,7 @@
 {
 #ifdef HAVE_POSIX_MEMALIGN
 	void* m;
-	int	err = posix_memalign (&m, 16, bytes);
+	int	err = posix_memalign (&m, 64, bytes);
 	return (!err) ? m : 0;
 #else
 	return malloc (bytes);
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/port.c jack/libjack/port.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/port.c	2007-01-17 07:48:45.000000000 +0700
+++ jack/libjack/port.c	2007-08-25 15:30:34.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: port.c 998 2006-11-22 19:55:56Z joq $
 */
 
 #include <string.h>
@@ -38,7 +37,8 @@
 #include "local.h"
 
 static void    jack_generic_buffer_init(void *port_buffer,
-                                      size_t buffer_size);
+                                      size_t buffer_size,
+				      jack_nframes_t nframes);
 
 static void    jack_audio_port_mixdown (jack_port_t *port,
 					jack_nframes_t nframes);
@@ -96,216 +96,6 @@
 
 #ifdef ARCH_X86
 
-static void
-x86_3dnow_add2f (float *dest, const float *src, int length)
-{
-	int i, n;
-	pv2sf m64p_dest = (pv2sf) dest;
-	pv2sf m64p_src = (pv2sf) src;
-
-	n = (length >> 1);
-	for (i = 0; i < n; i++)
-	{
-		asm volatile (
-			"movq %1, %%mm0\n\t" \
-			"pfadd %2, %%mm0\n\t" \
-			"movq %%mm0, %0\n\t"
-			: "=m" (m64p_dest[i])
-			: "m0" (m64p_dest[i]),
-			  "m" (m64p_src[i])
-			: "mm0", "memory");
-	}
-	if (n & 0x1)
-	{
-		asm volatile (
-			"movd %1, %%mm0\n\t" \
-			"movd %2, %%mm1\n\t" \
-			"pfadd %%mm1, %%mm0\n\t" \
-			"movd %%mm0, %0\n\t"
-			: "=m" (dest[length - 1])
-			: "m0" (dest[length - 1]),
-			  "m" (src[length - 1])
-			: "mm0", "mm1", "memory");
-	}
-	asm volatile (
-		"femms\n\t" \
-		"sfence\n\t");
-}
-
-static void
-x86_3dnow_copyf (float *dest, const float *src, int length)
-{
-	int i, n1, n2;
-	pv2sf m64p_src = (pv2sf) src;
-	pv2sf m64p_dest = (pv2sf) dest;
-
-	n1 = (length >> 4);
-	n2 = ((length & 0xf) >> 1);
-	for (i = 0; i < n1; i++)
-	{
-		asm volatile ("movq %0, %%mm0\n\t"
-			: : "m" (*m64p_src++) : "mm0", "memory");
-		asm volatile ("movq %0, %%mm1\n\t"
-			: : "m" (*m64p_src++) : "mm1", "memory");
-		asm volatile ("movq %0, %%mm2\n\t"
-			: : "m" (*m64p_src++) : "mm2", "memory");
-		asm volatile ("movq %0, %%mm3\n\t"
-			: : "m" (*m64p_src++) : "mm3", "memory");
-		asm volatile ("movq %0, %%mm4\n\t"
-			: : "m" (*m64p_src++) : "mm4", "memory");
-		asm volatile ("movq %0, %%mm5\n\t"
-			: : "m" (*m64p_src++) : "mm5", "memory");
-		asm volatile ("movq %0, %%mm6\n\t"
-			: : "m" (*m64p_src++) : "mm6", "memory");
-		asm volatile ("movq %0, %%mm7\n\t"
-			: : "m" (*m64p_src++) : "xmm7", "memory");
-
-		asm volatile ("movq %%mm0, %0\n\t"
-			: "=m" (*m64p_dest++) : : "mm0", "memory");
-		asm volatile ("movq %%mm1, %0\n\t"
-			: "=m" (*m64p_dest++) : : "mm1", "memory");
-		asm volatile ("movq %%mm2, %0\n\t"
-			: "=m" (*m64p_dest++) : : "mm2", "memory");
-		asm volatile ("movq %%mm3, %0\n\t"
-			: "=m" (*m64p_dest++) : : "mm3", "memory");
-		asm volatile ("movq %%mm4, %0\n\t"
-			: "=m" (*m64p_dest++) : : "mm4", "memory");
-		asm volatile ("movq %%mm5, %0\n\t"
-			: "=m" (*m64p_dest++) : : "mm5", "memory");
-		asm volatile ("movq %%mm6, %0\n\t"
-			: "=m" (*m64p_dest++) : : "mm6", "memory");
-		asm volatile ("movq %%mm7, %0\n\t"
-			: "=m" (*m64p_dest++) : : "mm7", "memory");
-	}
-	for (i = 0; i < n2; i++)
-	{
-		asm volatile (
-			"movq %1, %%mm0\n\t" \
-			"movq %%mm0, %0\n\t"
-			: "=m" (*m64p_dest++)
-			: "m" (*m64p_src++)
-			: "mm0", "memory");
-	}
-	if (length & 0x1)
-	{
-		asm volatile (
-			"movd %1, %%mm0\n\t" \
-			"movd %%mm0, %0\n\t"
-			: "=m" (dest[length - 1])
-			: "m" (src[length - 1])
-			: "mm0", "memory");
-	}
-	asm volatile (
-		"femms\n\t" \
-		"sfence\n\t");
-}
-
-static void
-x86_sse_copyf (float *dest, const float *src, int length)
-{
-	int i, n1, n2, si3;
-	pv4sf m128p_src = (pv4sf) src;
-	pv4sf m128p_dest = (pv4sf) dest;
-
-	n1 = (length >> 5);
-	n2 = ((length & 0x1f) >> 2);
-	si3 = (length & ~0x3);
-	for (i = 0; i < n1; i++)
-	{
-		asm volatile ("movaps %0, %%xmm0\n\t"
-			: : "m" (*m128p_src++) : "xmm0", "memory");
-		asm volatile ("movaps %0, %%xmm1\n\t"
-			: : "m" (*m128p_src++) : "xmm1", "memory");
-		asm volatile ("movaps %0, %%xmm2\n\t"
-			: : "m" (*m128p_src++) : "xmm2", "memory");
-		asm volatile ("movaps %0, %%xmm3\n\t"
-			: : "m" (*m128p_src++) : "xmm3", "memory");
-		asm volatile ("movaps %0, %%xmm4\n\t"
-			: : "m" (*m128p_src++) : "xmm4", "memory");
-		asm volatile ("movaps %0, %%xmm5\n\t"
-			: : "m" (*m128p_src++) : "xmm5", "memory");
-		asm volatile ("movaps %0, %%xmm6\n\t"
-			: : "m" (*m128p_src++) : "xmm6", "memory");
-		asm volatile ("movaps %0, %%xmm7\n\t"
-			: : "m" (*m128p_src++) : "xmm7", "memory");
-
-		asm volatile ("movaps %%xmm0, %0\n\t"
-			: "=m" (*m128p_dest++) : : "xmm0", "memory");
-		asm volatile ("movaps %%xmm1, %0\n\t"
-			: "=m" (*m128p_dest++) : : "xmm1", "memory");
-		asm volatile ("movaps %%xmm2, %0\n\t"
-			: "=m" (*m128p_dest++) : : "xmm2", "memory");
-		asm volatile ("movaps %%xmm3, %0\n\t"
-			: "=m" (*m128p_dest++) : : "xmm3", "memory");
-		asm volatile ("movaps %%xmm4, %0\n\t"
-			: "=m" (*m128p_dest++) : : "xmm4", "memory");
-		asm volatile ("movaps %%xmm5, %0\n\t"
-			: "=m" (*m128p_dest++) : : "xmm5", "memory");
-		asm volatile ("movaps %%xmm6, %0\n\t"
-			: "=m" (*m128p_dest++) : : "xmm6", "memory");
-		asm volatile ("movaps %%xmm7, %0\n\t"
-			: "=m" (*m128p_dest++) : : "xmm7", "memory");
-	}
-	for (i = 0; i < n2; i++)
-	{
-		asm volatile (
-			"movaps %1, %%xmm0\n\t" \
-			"movaps %%xmm0, %0\n\t"
-			: "=m" (*m128p_dest++)
-			: "m" (*m128p_src++)
-			: "xmm0", "memory");
-	}
-	for (i = si3; i < length; i++)
-	{
-		asm volatile (
-			"movss %1, %%xmm0\n\t" \
-			"movss %%xmm0, %0\n\t"
-			: "=m" (dest[i])
-			: "m" (src[i])
-			: "xmm0", "memory");
-	}
-}
-
-static void
-x86_sse_add2f (float *dest, const float *src, int length)
-{
-	int i, n, si2;
-	pv4sf m128p_src = (pv4sf) src;
-	pv4sf m128p_dest = (pv4sf) dest;
-
-	if (__builtin_expect(((long) src & 0xf) || ((long) dest & 0xf), 0))
-	{
-		/*fprintf(stderr, "x86_sse_add2f(): non aligned pointers!\n");*/
-		si2 = 0;
-		goto sse_nonalign;
-	}
-	si2 = (length & ~0x3);
-	n = (length >> 2);
-	for (i = 0; i < n; i++)
-	{
-		asm volatile (
-			"movaps %1, %%xmm0\n\t" \
-			"addps %2, %%xmm0\n\t" \
-			"movaps %%xmm0, %0\n\t"
-			: "=m" (m128p_dest[i])
-			: "m0" (m128p_dest[i]),
-			  "m" (m128p_src[i])
-			: "xmm0", "memory");
-	}
-sse_nonalign:
-	for (i = si2; i < length; i++)
-	{
-		asm volatile (
-			"movss %1, %%xmm0\n\t" \
-			"addss %2, %%xmm0\n\t" \
-			"movss %%xmm0, %0\n\t"
-			: "=m" (dest[i])
-			: "m0" (dest[i]),
-			  "m" (src[i])
-			: "xmm0", "memory");
-	}
-}
-
 void jack_port_set_funcs ()
 {
 	if (ARCH_X86_HAVE_SSE2(cpu_type)) {
@@ -334,6 +124,14 @@
 
 #endif /* USE_DYNSIMD */
 
+int
+jack_port_name_equals (jack_port_shared_t* port, const char* target)
+{
+	return (strcmp (port->name, target) == 0 || 
+		strcmp (port->alias1, target) == 0 || 
+		strcmp (port->alias2, target) == 0);
+}
+		
 jack_port_functions_t *
 jack_get_port_functions(jack_port_type_id_t ptid)
 {
@@ -352,8 +150,8 @@
  * Fills buffer with zeroes. For audio ports, engine->silent_buffer relies on it.
  */
 static void
-jack_generic_buffer_init(void *buffer, size_t size)
-{
+jack_generic_buffer_init(void *buffer, size_t size, jack_nframes_t nframes)
+{ 
 	memset(buffer, 0, size);
 }
 
@@ -373,7 +171,7 @@
 	pthread_mutex_init (&port->connection_lock, NULL);
 	port->connections = 0;
 	port->tied = NULL;
-	
+
 	if (client->control->id == port->shared->client_id) {
 			
 		/* It's our port, so initialize the pointers to port
@@ -396,7 +194,7 @@
 
 	port->client_segment_base =
 		(void **) &client->port_segment[ptid].attached_at;
-	
+
 	return port;
 }
 
@@ -463,26 +261,6 @@
 	return jack_client_deliver_request (client, &req);
 }
 
-int
-jack_port_lock (jack_client_t *client, jack_port_t *port)
-{
-	if (port) {
-		port->shared->locked = 1;
-		return 0;
-	}
-	return -1;
-}
-
-int
-jack_port_unlock (jack_client_t *client, jack_port_t *port)
-{
-	if (port) {
-		port->shared->locked = 0;
-		return 0;
-	}
-	return -1;
-}
-
 /* LOCAL (in-client) connection querying only */
 
 int
@@ -509,7 +287,7 @@
 	for (node = port->connections; node; node = jack_slist_next (node)) {
 		jack_port_t *other_port = (jack_port_t *) node->data;
 		
-		if (strcmp (other_port->shared->name, portname) == 0) {
+		if (jack_port_name_equals (other_port->shared, portname)) {
 			ret = TRUE;
 			break;
 		}
@@ -542,7 +320,8 @@
 				* (jack_slist_length (port->connections) + 1));
 		for (n = 0, node = port->connections; node;
 		     node = jack_slist_next (node), ++n) {
-			ret[n] = ((jack_port_t *) node->data)->shared->name;
+			jack_port_t* other =(jack_port_t *) node->data;
+			ret[n] = other->shared->name;
 		}
 		ret[n] = NULL;
 	}
@@ -665,7 +444,7 @@
 	port = &client->engine->ports[0];
 	
 	for (i = 0; i < limit; i++) {
-		if (port[i].in_use && strcmp (port[i].name, port_name) == 0) {
+		if (port[i].in_use && jack_port_name_equals (&port[i], port_name)) {
 			return jack_port_new (client, port[i].id,
 					      client->engine);
 		}
@@ -681,7 +460,7 @@
 	jack_port_t* port;
 	for (node = client->ports_ext; node; node = jack_slist_next (node)) {
 		port = node->data;
-		if (strcmp (port->shared->name, port_name) == 0) {
+		if (jack_port_name_equals (port->shared, port_name)) {
 			/* Found port, return the cached structure. */
 			return port;
 		}
@@ -761,7 +540,7 @@
 				* sizeof (jack_default_audio_sample_t)
 				* nframes;
 		port->mix_buffer = jack_pool_alloc (buffer_size);
-		port->fptr.buffer_init (port->mix_buffer, buffer_size);
+		port->fptr.buffer_init (port->mix_buffer, buffer_size, nframes);
 	}
 	port->fptr.mixdown (port, nframes);
 	return (void *) port->mix_buffer;
@@ -787,7 +566,6 @@
 
 int
 jack_port_untie (jack_port_t *port)
-
 {
 	if (port->tied == NULL) {
 		jack_error ("port \"%s\" is not tied", port->shared->name);
@@ -889,6 +667,24 @@
 	return port->shared->name;
 }
 
+int
+jack_port_get_aliases (const jack_port_t *port, char* const aliases[2])
+{
+	int cnt = 0;
+	
+	if (port->shared->alias1[0] != '\0') {
+		snprintf (aliases[0], JACK_CLIENT_NAME_SIZE+JACK_PORT_NAME_SIZE, "%s", port->shared->alias1);
+		cnt++;
+	}
+
+	if (port->shared->alias2[0] != '\0') {
+		snprintf (aliases[1], JACK_CLIENT_NAME_SIZE+JACK_PORT_NAME_SIZE, "%s", port->shared->alias2);
+		cnt++;
+	}
+
+	return cnt;
+}
+
 const char *
 jack_port_short_name (const jack_port_t *port)
 {
@@ -931,6 +727,35 @@
 	return 0;
 }
 
+int
+jack_port_set_alias (jack_port_t *port, const char *alias)
+{
+	if (port->shared->alias1[0] == '\0') {
+		snprintf (port->shared->alias1, sizeof (port->shared->alias1), "%s", alias);
+	} else if (port->shared->alias2[0] == '\0') {
+		snprintf (port->shared->alias2, sizeof (port->shared->alias2), "%s", alias);
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+jack_port_unset_alias (jack_port_t *port, const char *alias)
+{
+	if (strcmp (port->shared->alias1, alias) == 0) {
+		port->shared->alias1[0] = '\0';
+	} else if (strcmp (port->shared->alias2, alias) == 0) {
+		port->shared->alias2[0] = '\0';
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+
 /* AUDIO PORT SUPPORT */
 
 static inline float f_max(float x, float a)
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/shm.c jack/libjack/shm.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/shm.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/shm.c	2007-08-25 15:30:34.000000000 +0700
@@ -28,7 +28,6 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
- * $Id: shm.c 945 2006-05-04 15:14:45Z pbd $
  */
 #include <config.h>
 
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/simd.c jack/libjack/simd.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/simd.c	1970-01-01 07:00:00.000000000 +0700
+++ jack/libjack/simd.c	2007-08-25 15:30:34.000000000 +0700
@@ -0,0 +1,335 @@
+/* -*- mode: c; c-file-style: "bsd"; -*- */
+/*
+    Copyright (C) 2005-2007 Jussi Laako
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2.1 of the License, or
+    (at your option) any later version.
+    
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+    
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software 
+    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+*/
+
+
+#include <config.h>
+#include <jack/intsimd.h>
+
+#ifdef USE_DYNSIMD
+
+#ifdef ARCH_X86
+
+int
+have_3dnow ()
+{
+	unsigned int res = 0;
+
+#ifdef __x86_64__
+	asm volatile ("pushq %%rbx\n\t" : : : "memory");
+#else
+	asm volatile ("pushl %%ebx\n\t" : : : "memory");
+#endif
+	asm volatile (
+		"movl $0x80000000, %%eax\n\t" \
+		"cpuid\n\t" \
+		"cmpl $0x80000001, %%eax\n\t" \
+		"jl tdnow_prexit\n\t" \
+		\
+		"movl $0x80000001, %%eax\n\t" \
+		"cpuid\n\t" \
+		\
+		"xorl %%eax, %%eax\n\t" \
+		\
+		"movl $1, %%ecx\n\t" \
+		"shll $31, %%ecx\n\t" \
+		"testl %%ecx, %%edx\n\t" \
+		"jz tdnow_testexit\n\t" \
+		"movl $1, %%eax\n\t" \
+		\
+		"movl $1, %%ecx\n\t" \
+		"shll $30, %%ecx\n\t" \
+		"testl %%ecx, %%edx\n\t" \
+		"jz tdnow_testexit\n\t" \
+		"movl $2, %%eax\n\t" \
+		"jmp tdnow_testexit\n\t" \
+		\
+		"tdnow_prexit:\n\t" \
+		"xorl %%eax, %%eax\n\t" \
+		"tdnow_testexit:\n\t"
+		: "=a" (res)
+		:
+		: "ecx", "edx", "memory");
+#ifdef __x86_64__
+	asm volatile ("popq %%rbx\n\t" : : : "memory");
+#else
+	asm volatile ("popl %%ebx\n\t" : : : "memory");
+#endif
+	return res;
+}
+
+int
+have_sse ()
+{
+	unsigned int res = 0;
+
+#ifdef __x86_64__
+	asm volatile ("pushq %%rbx\n\t" : : : "memory");
+#else
+	asm volatile ("pushl %%ebx\n\t" : : : "memory");
+#endif
+	asm volatile (
+		"movl $1, %%eax\n\t" \
+		"cpuid\n\t" \
+		\
+		"xorl %%eax, %%eax\n\t" \
+		\
+		"movl $1, %%ebx\n\t" \
+		"shll $25, %%ebx\n\t" \
+		"testl %%ebx, %%edx\n\t" \
+		"jz sse_testexit\n\t" \
+		"movl $1, %%eax\n\t" \
+		\
+		"movl $1, %%ebx\n\t" \
+		"shll $26, %%ebx\n\t" \
+		"testl %%ebx, %%edx\n\t" \
+		"jz sse_testexit\n\t" \
+		"movl $2, %%eax\n\t" \
+		\
+		"movl $1, %%ebx\n\t" \
+		"testl %%ebx, %%ecx\n\t" \
+		"jz sse_testexit\n\t" \
+		"movl $3, %%eax\n\t" \
+		\
+		"sse_testexit:\n\t"
+		: "=a" (res)
+		:
+		: "ecx", "edx", "memory");
+#ifdef __x86_64__
+	asm volatile ("popq %%rbx\n\t" : : : "memory");
+#else
+	asm volatile ("popl %%ebx\n\t" : : : "memory");
+#endif
+	return res;
+}
+
+void
+x86_3dnow_copyf (float *dest, const float *src, int length)
+{
+	int i, n1, n2;
+	pv2sf m64p_src = (pv2sf) src;
+	pv2sf m64p_dest = (pv2sf) dest;
+
+	n1 = (length >> 4);
+	n2 = ((length & 0xf) >> 1);
+	for (i = 0; i < n1; i++)
+	{
+		asm volatile ("movq %0, %%mm0\n\t"
+			: : "m" (*m64p_src++) : "mm0", "memory");
+		asm volatile ("movq %0, %%mm1\n\t"
+			: : "m" (*m64p_src++) : "mm1", "memory");
+		asm volatile ("movq %0, %%mm2\n\t"
+			: : "m" (*m64p_src++) : "mm2", "memory");
+		asm volatile ("movq %0, %%mm3\n\t"
+			: : "m" (*m64p_src++) : "mm3", "memory");
+		asm volatile ("movq %0, %%mm4\n\t"
+			: : "m" (*m64p_src++) : "mm4", "memory");
+		asm volatile ("movq %0, %%mm5\n\t"
+			: : "m" (*m64p_src++) : "mm5", "memory");
+		asm volatile ("movq %0, %%mm6\n\t"
+			: : "m" (*m64p_src++) : "mm6", "memory");
+		asm volatile ("movq %0, %%mm7\n\t"
+			: : "m" (*m64p_src++) : "xmm7", "memory");
+
+		asm volatile ("movq %%mm0, %0\n\t"
+			: "=m" (*m64p_dest++) : : "mm0", "memory");
+		asm volatile ("movq %%mm1, %0\n\t"
+			: "=m" (*m64p_dest++) : : "mm1", "memory");
+		asm volatile ("movq %%mm2, %0\n\t"
+			: "=m" (*m64p_dest++) : : "mm2", "memory");
+		asm volatile ("movq %%mm3, %0\n\t"
+			: "=m" (*m64p_dest++) : : "mm3", "memory");
+		asm volatile ("movq %%mm4, %0\n\t"
+			: "=m" (*m64p_dest++) : : "mm4", "memory");
+		asm volatile ("movq %%mm5, %0\n\t"
+			: "=m" (*m64p_dest++) : : "mm5", "memory");
+		asm volatile ("movq %%mm6, %0\n\t"
+			: "=m" (*m64p_dest++) : : "mm6", "memory");
+		asm volatile ("movq %%mm7, %0\n\t"
+			: "=m" (*m64p_dest++) : : "mm7", "memory");
+	}
+	for (i = 0; i < n2; i++)
+	{
+		asm volatile (
+			"movq %1, %%mm0\n\t" \
+			"movq %%mm0, %0\n\t"
+			: "=m" (*m64p_dest++)
+			: "m" (*m64p_src++)
+			: "mm0", "memory");
+	}
+	if (length & 0x1)
+	{
+		asm volatile (
+			"movd %1, %%mm0\n\t" \
+			"movd %%mm0, %0\n\t"
+			: "=m" (dest[length - 1])
+			: "m" (src[length - 1])
+			: "mm0", "memory");
+	}
+	asm volatile (
+		"femms\n\t" \
+		"sfence\n\t");
+}
+
+void
+x86_3dnow_add2f (float *dest, const float *src, int length)
+{
+	int i, n;
+	pv2sf m64p_dest = (pv2sf) dest;
+	pv2sf m64p_src = (pv2sf) src;
+
+	n = (length >> 1);
+	for (i = 0; i < n; i++)
+	{
+		asm volatile (
+			"movq %1, %%mm0\n\t" \
+			"pfadd %2, %%mm0\n\t" \
+			"movq %%mm0, %0\n\t"
+			: "=m" (m64p_dest[i])
+			: "m0" (m64p_dest[i]),
+			  "m" (m64p_src[i])
+			: "mm0", "memory");
+	}
+	if (n & 0x1)
+	{
+		asm volatile (
+			"movd %1, %%mm0\n\t" \
+			"movd %2, %%mm1\n\t" \
+			"pfadd %%mm1, %%mm0\n\t" \
+			"movd %%mm0, %0\n\t"
+			: "=m" (dest[length - 1])
+			: "m0" (dest[length - 1]),
+			  "m" (src[length - 1])
+			: "mm0", "mm1", "memory");
+	}
+	asm volatile (
+		"femms\n\t" \
+		"sfence\n\t");
+}
+
+void
+x86_sse_copyf (float *dest, const float *src, int length)
+{
+	int i, n1, n2, si3;
+	pv4sf m128p_src = (pv4sf) src;
+	pv4sf m128p_dest = (pv4sf) dest;
+
+	n1 = (length >> 5);
+	n2 = ((length & 0x1f) >> 2);
+	si3 = (length & ~0x3);
+	for (i = 0; i < n1; i++)
+	{
+		asm volatile ("movaps %0, %%xmm0\n\t"
+			: : "m" (*m128p_src++) : "xmm0", "memory");
+		asm volatile ("movaps %0, %%xmm1\n\t"
+			: : "m" (*m128p_src++) : "xmm1", "memory");
+		asm volatile ("movaps %0, %%xmm2\n\t"
+			: : "m" (*m128p_src++) : "xmm2", "memory");
+		asm volatile ("movaps %0, %%xmm3\n\t"
+			: : "m" (*m128p_src++) : "xmm3", "memory");
+		asm volatile ("movaps %0, %%xmm4\n\t"
+			: : "m" (*m128p_src++) : "xmm4", "memory");
+		asm volatile ("movaps %0, %%xmm5\n\t"
+			: : "m" (*m128p_src++) : "xmm5", "memory");
+		asm volatile ("movaps %0, %%xmm6\n\t"
+			: : "m" (*m128p_src++) : "xmm6", "memory");
+		asm volatile ("movaps %0, %%xmm7\n\t"
+			: : "m" (*m128p_src++) : "xmm7", "memory");
+
+		asm volatile ("movaps %%xmm0, %0\n\t"
+			: "=m" (*m128p_dest++) : : "xmm0", "memory");
+		asm volatile ("movaps %%xmm1, %0\n\t"
+			: "=m" (*m128p_dest++) : : "xmm1", "memory");
+		asm volatile ("movaps %%xmm2, %0\n\t"
+			: "=m" (*m128p_dest++) : : "xmm2", "memory");
+		asm volatile ("movaps %%xmm3, %0\n\t"
+			: "=m" (*m128p_dest++) : : "xmm3", "memory");
+		asm volatile ("movaps %%xmm4, %0\n\t"
+			: "=m" (*m128p_dest++) : : "xmm4", "memory");
+		asm volatile ("movaps %%xmm5, %0\n\t"
+			: "=m" (*m128p_dest++) : : "xmm5", "memory");
+		asm volatile ("movaps %%xmm6, %0\n\t"
+			: "=m" (*m128p_dest++) : : "xmm6", "memory");
+		asm volatile ("movaps %%xmm7, %0\n\t"
+			: "=m" (*m128p_dest++) : : "xmm7", "memory");
+	}
+	for (i = 0; i < n2; i++)
+	{
+		asm volatile (
+			"movaps %1, %%xmm0\n\t" \
+			"movaps %%xmm0, %0\n\t"
+			: "=m" (*m128p_dest++)
+			: "m" (*m128p_src++)
+			: "xmm0", "memory");
+	}
+	for (i = si3; i < length; i++)
+	{
+		asm volatile (
+			"movss %1, %%xmm0\n\t" \
+			"movss %%xmm0, %0\n\t"
+			: "=m" (dest[i])
+			: "m" (src[i])
+			: "xmm0", "memory");
+	}
+}
+
+void
+x86_sse_add2f (float *dest, const float *src, int length)
+{
+	int i, n, si2;
+	pv4sf m128p_src = (pv4sf) src;
+	pv4sf m128p_dest = (pv4sf) dest;
+
+	if (__builtin_expect(((long) src & 0xf) || ((long) dest & 0xf), 0))
+	{
+		/*fprintf(stderr, "x86_sse_add2f(): non aligned pointers!\n");*/
+		si2 = 0;
+		goto sse_nonalign;
+	}
+	si2 = (length & ~0x3);
+	n = (length >> 2);
+	for (i = 0; i < n; i++)
+	{
+		asm volatile (
+			"movaps %1, %%xmm0\n\t" \
+			"addps %2, %%xmm0\n\t" \
+			"movaps %%xmm0, %0\n\t"
+			: "=m" (m128p_dest[i])
+			: "m0" (m128p_dest[i]),
+			  "m" (m128p_src[i])
+			: "xmm0", "memory");
+	}
+sse_nonalign:
+	for (i = si2; i < length; i++)
+	{
+		asm volatile (
+			"movss %1, %%xmm0\n\t" \
+			"addss %2, %%xmm0\n\t" \
+			"movss %%xmm0, %0\n\t"
+			: "=m" (dest[i])
+			: "m0" (dest[i]),
+			  "m" (src[i])
+			: "xmm0", "memory");
+	}
+}
+
+#endif /* ARCH_X86 */
+
+#endif /* USE_DYNSIMD */
+
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/thread.c jack/libjack/thread.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/thread.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/thread.c	2007-08-25 15:30:34.000000000 +0700
@@ -18,7 +18,6 @@
   Thread creation function including workarounds for real-time scheduling
   behaviour on different glibc versions.
 
-  $Id: thread.c 948 2006-05-15 17:12:44Z pbd $
 
 */
 
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/time.c jack/libjack/time.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/time.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/time.c	2007-08-25 15:30:34.000000000 +0700
@@ -17,7 +17,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: time.c 954 2006-05-16 15:59:29Z pbd $
 */
 
 #include <config.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/timestamps.c jack/libjack/timestamps.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/timestamps.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/timestamps.c	2007-08-25 15:30:34.000000000 +0700
@@ -15,7 +15,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: timestamps.c 673 2004-03-25 19:31:51Z joq $
 */
 
 #include <stdlib.h>
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/transclient.c jack/libjack/transclient.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/transclient.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/transclient.c	2007-08-25 15:30:34.000000000 +0700
@@ -231,8 +231,14 @@
 					/ 1000000.0f) * usecs);
 }
 
+jack_time_t
+jack_get_time()
+{
+	return jack_get_microseconds();
+}
+
 jack_nframes_t
-jack_frame_time (const jack_client_t *client)
+jack_time_to_frames(const jack_client_t *client, jack_time_t now)
 {
 	jack_frame_timer_t time;
 	jack_control_t *ectl = client->engine;
@@ -240,8 +246,6 @@
 	jack_read_frame_time (client, &time);
 
 	if (time.initialized) {
-		jack_time_t now = jack_get_microseconds();
-
 #if 0
 		fprintf (stderr, "now = %Lu current wakeup = %Lu next = %Lu frames = %lu + %f => %lu\n", 
 			 now, time.current_wakeup, time.next_wakeup, time.frames,
@@ -250,17 +254,23 @@
 			 time.frames + 
 			 (long) rint (((double) (now - time.current_wakeup)/ 
 						 (time.next_wakeup - time.current_wakeup)) * ectl->buffer_size));
-#endif		
+#endif
 
 		return time.frames + 
 			(long) rint (((double) ((long long) (now - time.current_wakeup))/ 
 						((long long) (time.next_wakeup - time.current_wakeup))) * ectl->buffer_size);
-	} 
-
+	}
 	return 0;
 }
 
 jack_nframes_t
+jack_frame_time (const jack_client_t *client)
+{
+	jack_time_t now = jack_get_microseconds();
+	return jack_time_to_frames(client, now);
+}
+
+jack_nframes_t
 jack_last_frame_time (const jack_client_t *client)
 {
 	jack_frame_timer_t current;
@@ -268,6 +278,23 @@
 	return current.frames;
 }
 
+jack_time_t
+jack_frames_to_time(const jack_client_t *client, jack_nframes_t frames)
+{
+	jack_frame_timer_t time;
+	jack_control_t *ectl = client->engine;
+
+	jack_read_frame_time (client, &time);
+
+	if (time.initialized) {
+		return time.current_wakeup +
+			(long) rint (((double) ((long long) (frames - time.frames)) *
+						((long long) (time.next_wakeup - time.current_wakeup)) / ectl->buffer_size) );
+	} 
+
+	return 0;
+}
+
 jack_nframes_t
 jack_get_sample_rate (jack_client_t *client)
 {
diff -NPur jack-audio-connection-kit-0.103.0.orig/libjack/unlock.c jack/libjack/unlock.c
--- jack-audio-connection-kit-0.103.0.orig/libjack/unlock.c	2006-05-26 09:45:11.000000000 +0700
+++ jack/libjack/unlock.c	2007-08-25 15:30:34.000000000 +0700
@@ -16,7 +16,6 @@
     along with this program; if not, write to the Free Software 
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 
-    $Id: unlock.c 945 2006-05-04 15:14:45Z pbd $
 */
 
 #include <stdio.h>
