diff -rupN busybox-1.2.0/.config busybox-1.2.0solaris/.config
--- busybox-1.2.0/.config	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/.config	2009-04-21 09:19:25.466783497 +0400
@@ -0,0 +1,637 @@
+#
+# Automatically generated make config: don't edit
+#
+HAVE_DOT_CONFIG=y
+
+#
+# Busybox Settings
+#
+
+#
+# General Configuration
+#
+# CONFIG_NITPICK is not set
+# CONFIG_FEATURE_BUFFERS_USE_MALLOC is not set
+# CONFIG_FEATURE_BUFFERS_GO_ON_STACK is not set
+# CONFIG_FEATURE_BUFFERS_GO_IN_BSS is not set
+CONFIG_SHOW_USAGE=y
+# CONFIG_FEATURE_VERBOSE_USAGE is not set
+# CONFIG_FEATURE_COMPRESS_USAGE is not set
+# CONFIG_FEATURE_INSTALLER is not set
+# CONFIG_LOCALE_SUPPORT is not set
+CONFIG_GETOPT_LONG=y
+# CONFIG_FEATURE_DEVPTS is not set
+# CONFIG_FEATURE_CLEAN_UP is not set
+# CONFIG_FEATURE_SUID is not set
+# CONFIG_FEATURE_SUID_CONFIG is not set
+# CONFIG_FEATURE_SUID_CONFIG_QUIET is not set
+# CONFIG_SELINUX is not set
+CONFIG_BUSYBOX_EXEC_PATH="n"
+
+#
+# Build Options
+#
+# CONFIG_STATIC is not set
+# CONFIG_BUILD_LIBBUSYBOX is not set
+# CONFIG_FEATURE_FULL_LIBBUSYBOX is not set
+# CONFIG_FEATURE_SHARED_BUSYBOX is not set
+# CONFIG_LFS is not set
+# USING_CROSS_COMPILER is not set
+CROSS_COMPILER_PREFIX=""
+# CONFIG_BUILD_AT_ONCE is not set
+
+#
+# Debugging Options
+#
+# CONFIG_DEBUG is not set
+# CONFIG_DEBUG_PESSIMIZE is not set
+# CONFIG_NO_DEBUG_LIB is not set
+# CONFIG_DMALLOC is not set
+# CONFIG_EFENCE is not set
+CONFIG_DEBUG_YANK_SUSv2=y
+
+#
+# Installation Options
+#
+# CONFIG_INSTALL_NO_USR is not set
+CONFIG_INSTALL_APPLET_SYMLINKS=y
+# CONFIG_INSTALL_APPLET_HARDLINKS is not set
+# CONFIG_INSTALL_APPLET_DONT is not set
+PREFIX="./_install"
+
+#
+# Busybox Library Tuning
+#
+CONFIG_MD5_SIZE_VS_SPEED=2
+
+#
+# Applets
+#
+
+#
+# Archival Utilities
+#
+# CONFIG_AR is not set
+# CONFIG_FEATURE_AR_LONG_FILENAMES is not set
+CONFIG_BUNZIP2=y
+CONFIG_CPIO=y
+# CONFIG_DPKG is not set
+# CONFIG_DPKG_DEB is not set
+# CONFIG_FEATURE_DPKG_DEB_EXTRACT_ONLY is not set
+CONFIG_GUNZIP=y
+# CONFIG_FEATURE_GUNZIP_UNCOMPRESS is not set
+CONFIG_GZIP=y
+# CONFIG_RPM2CPIO is not set
+# CONFIG_RPM is not set
+CONFIG_TAR=y
+CONFIG_FEATURE_TAR_CREATE=y
+# CONFIG_FEATURE_TAR_BZIP2 is not set
+# CONFIG_FEATURE_TAR_LZMA is not set
+# CONFIG_FEATURE_TAR_FROM is not set
+CONFIG_FEATURE_TAR_GZIP=y
+# CONFIG_FEATURE_TAR_COMPRESS is not set
+# CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY is not set
+CONFIG_FEATURE_TAR_GNU_EXTENSIONS=y
+# CONFIG_FEATURE_TAR_LONG_OPTIONS is not set
+# CONFIG_UNCOMPRESS is not set
+# CONFIG_UNLZMA is not set
+# CONFIG_FEATURE_LZMA_FAST is not set
+CONFIG_UNZIP=y
+
+#
+# Common options for cpio and tar
+#
+# CONFIG_FEATURE_UNARCHIVE_TAPE is not set
+# CONFIG_FEATURE_DEB_TAR_GZ is not set
+# CONFIG_FEATURE_DEB_TAR_BZ2 is not set
+# CONFIG_FEATURE_DEB_TAR_LZMA is not set
+
+#
+# Coreutils
+#
+# CONFIG_BASENAME is not set
+# CONFIG_CAL is not set
+CONFIG_CAT=y
+# CONFIG_CATV is not set
+CONFIG_CHGRP=y
+CONFIG_CHMOD=y
+CONFIG_CHOWN=y
+CONFIG_CHROOT=y
+# CONFIG_CKSUM is not set
+# CONFIG_CMP is not set
+# CONFIG_COMM is not set
+CONFIG_CP=y
+CONFIG_CUT=y
+CONFIG_DATE=y
+CONFIG_FEATURE_DATE_ISOFMT=y
+CONFIG_DD=y
+CONFIG_FEATURE_DD_SIGNAL_HANDLING=y
+# CONFIG_FEATURE_DD_IBS_OBS is not set
+CONFIG_DF=y
+# CONFIG_DIFF is not set
+# CONFIG_FEATURE_DIFF_BINARY is not set
+# CONFIG_FEATURE_DIFF_DIR is not set
+# CONFIG_FEATURE_DIFF_MINIMAL is not set
+# CONFIG_DIRNAME is not set
+# CONFIG_DOS2UNIX is not set
+# CONFIG_UNIX2DOS is not set
+CONFIG_DU=y
+CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K=y
+CONFIG_ECHO=y
+CONFIG_FEATURE_FANCY_ECHO=y
+CONFIG_ENV=y
+# CONFIG_FEATURE_ENV_LONG_OPTIONS is not set
+# CONFIG_EXPR is not set
+# CONFIG_EXPR_MATH_SUPPORT_64 is not set
+CONFIG_FALSE=y
+# CONFIG_FOLD is not set
+CONFIG_HEAD=y
+# CONFIG_FEATURE_FANCY_HEAD is not set
+CONFIG_HOSTID=y
+CONFIG_ID=y
+# CONFIG_INSTALL is not set
+# CONFIG_FEATURE_INSTALL_LONG_OPTIONS is not set
+# CONFIG_LENGTH is not set
+# CONFIG_LN is not set
+# CONFIG_LOGNAME is not set
+CONFIG_LS=y
+CONFIG_FEATURE_LS_FILETYPES=y
+CONFIG_FEATURE_LS_FOLLOWLINKS=y
+CONFIG_FEATURE_LS_RECURSIVE=y
+CONFIG_FEATURE_LS_SORTFILES=y
+CONFIG_FEATURE_LS_TIMESTAMPS=y
+CONFIG_FEATURE_LS_USERNAME=y
+CONFIG_FEATURE_LS_COLOR=y
+# CONFIG_FEATURE_LS_COLOR_IS_DEFAULT is not set
+CONFIG_MD5SUM=y
+CONFIG_MKDIR=y
+# CONFIG_FEATURE_MKDIR_LONG_OPTIONS is not set
+# CONFIG_MKFIFO is not set
+CONFIG_MKNOD=y
+CONFIG_MOUNT=y
+CONFIG_MV=y
+# CONFIG_FEATURE_MV_LONG_OPTIONS is not set
+# CONFIG_NICE is not set
+# CONFIG_NOHUP is not set
+# CONFIG_OD is not set
+# CONFIG_PRINTENV is not set
+CONFIG_PRINTF=y
+CONFIG_PWD=y
+# CONFIG_REALPATH is not set
+CONFIG_RM=y
+# CONFIG_RMDIR is not set
+# CONFIG_SEQ is not set
+# CONFIG_SHA1SUM is not set
+CONFIG_SLEEP=y
+# CONFIG_FEATURE_FANCY_SLEEP is not set
+CONFIG_SORT=y
+CONFIG_FEATURE_SORT_BIG=y
+# CONFIG_STAT is not set
+# CONFIG_FEATURE_STAT_FORMAT is not set
+# CONFIG_STTY is not set
+# CONFIG_SUM is not set
+# CONFIG_SYNC is not set
+# CONFIG_TAIL is not set
+# CONFIG_FEATURE_FANCY_TAIL is not set
+CONFIG_TEE=y
+# CONFIG_FEATURE_TEE_USE_BLOCK_IO is not set
+CONFIG_TEST=y
+# CONFIG_FEATURE_TEST_64 is not set
+CONFIG_TOUCH=y
+CONFIG_TR=y
+# CONFIG_FEATURE_TR_CLASSES is not set
+# CONFIG_FEATURE_TR_EQUIV is not set
+CONFIG_TRUE=y
+CONFIG_TTY=y
+CONFIG_UMOUNT=y
+CONFIG_UNAME=y
+# CONFIG_UNIQ is not set
+# CONFIG_USLEEP is not set
+# CONFIG_UUDECODE is not set
+# CONFIG_UUENCODE is not set
+# CONFIG_WATCH is not set
+CONFIG_WC=y
+# CONFIG_WHO is not set
+CONFIG_WHOAMI=y
+CONFIG_YES=y
+
+#
+# Common options for cp and mv
+#
+# CONFIG_FEATURE_PRESERVE_HARDLINKS is not set
+
+#
+# Common options for ls, more and telnet
+#
+CONFIG_FEATURE_AUTOWIDTH=y
+
+#
+# Common options for df, du, ls
+#
+# CONFIG_FEATURE_HUMAN_READABLE is not set
+
+#
+# Common options for md5sum, sha1sum
+#
+# CONFIG_FEATURE_MD5_SHA1_SUM_CHECK is not set
+
+#
+# Console Utilities
+#
+# CONFIG_CHVT is not set
+CONFIG_CLEAR=y
+# CONFIG_DEALLOCVT is not set
+# CONFIG_DUMPKMAP is not set
+# CONFIG_LOADFONT is not set
+# CONFIG_LOADKMAP is not set
+# CONFIG_OPENVT is not set
+# CONFIG_RESET is not set
+# CONFIG_SETCONSOLE is not set
+# CONFIG_FEATURE_SETCONSOLE_LONG_OPTIONS is not set
+# CONFIG_SETKEYCODES is not set
+# CONFIG_SETLOGCONS is not set
+
+#
+# Debian Utilities
+#
+# CONFIG_MKTEMP is not set
+# CONFIG_PIPE_PROGRESS is not set
+# CONFIG_READLINK is not set
+# CONFIG_FEATURE_READLINK_FOLLOW is not set
+# CONFIG_RUN_PARTS is not set
+# CONFIG_FEATURE_RUN_PARTS_LONG_OPTIONS is not set
+# CONFIG_START_STOP_DAEMON is not set
+# CONFIG_FEATURE_START_STOP_DAEMON_FANCY is not set
+# CONFIG_FEATURE_START_STOP_DAEMON_LONG_OPTIONS is not set
+# CONFIG_WHICH is not set
+
+#
+# Editors
+#
+CONFIG_AWK=y
+CONFIG_FEATURE_AWK_MATH=y
+CONFIG_ED=y
+# CONFIG_PATCH is not set
+CONFIG_SED=y
+CONFIG_VI=y
+CONFIG_FEATURE_VI_COLON=y
+CONFIG_FEATURE_VI_YANKMARK=y
+CONFIG_FEATURE_VI_SEARCH=y
+CONFIG_FEATURE_VI_USE_SIGNALS=y
+CONFIG_FEATURE_VI_DOT_CMD=y
+CONFIG_FEATURE_VI_READONLY=y
+CONFIG_FEATURE_VI_SETOPTS=y
+CONFIG_FEATURE_VI_SET=y
+CONFIG_FEATURE_VI_WIN_RESIZE=y
+CONFIG_FEATURE_VI_OPTIMIZE_CURSOR=y
+
+#
+# Finding Utilities
+#
+CONFIG_FIND=y
+CONFIG_FEATURE_FIND_PRINT0=y
+CONFIG_FEATURE_FIND_MTIME=y
+CONFIG_FEATURE_FIND_MMIN=y
+CONFIG_FEATURE_FIND_PERM=y
+CONFIG_FEATURE_FIND_TYPE=y
+CONFIG_FEATURE_FIND_XDEV=y
+CONFIG_FEATURE_FIND_NEWER=y
+CONFIG_FEATURE_FIND_INUM=y
+CONFIG_FEATURE_FIND_EXEC=y
+CONFIG_GREP=y
+CONFIG_FEATURE_GREP_EGREP_ALIAS=y
+CONFIG_FEATURE_GREP_FGREP_ALIAS=y
+CONFIG_FEATURE_GREP_CONTEXT=y
+CONFIG_XARGS=y
+# CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_QUOTES is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT is not set
+# CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM is not set
+
+#
+# Init Utilities
+#
+CONFIG_INIT=y
+# CONFIG_DEBUG_INIT is not set
+# CONFIG_FEATURE_USE_INITTAB is not set
+# CONFIG_FEATURE_INIT_SCTTY is not set
+# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_FEATURE_INIT_COREDUMPS is not set
+# CONFIG_FEATURE_INITRD is not set
+CONFIG_HALT=y
+# CONFIG_MESG is not set
+
+#
+# Login/Password Management Utilities
+#
+# CONFIG_FEATURE_SHADOWPASSWDS is not set
+# CONFIG_USE_BB_SHADOW is not set
+# CONFIG_USE_BB_PWD_GRP is not set
+# CONFIG_ADDGROUP is not set
+# CONFIG_DELGROUP is not set
+# CONFIG_ADDUSER is not set
+# CONFIG_DELUSER is not set
+# CONFIG_GETTY is not set
+# CONFIG_FEATURE_UTMP is not set
+# CONFIG_FEATURE_WTMP is not set
+# CONFIG_LOGIN is not set
+# CONFIG_FEATURE_SECURETTY is not set
+# CONFIG_PASSWD is not set
+# CONFIG_SU is not set
+# CONFIG_SULOGIN is not set
+# CONFIG_VLOCK is not set
+
+#
+# Linux Ext2 FS Progs
+#
+# CONFIG_CHATTR is not set
+# CONFIG_E2FSCK is not set
+# CONFIG_FSCK is not set
+# CONFIG_LSATTR is not set
+# CONFIG_MKE2FS is not set
+# CONFIG_TUNE2FS is not set
+# CONFIG_E2LABEL is not set
+# CONFIG_FINDFS is not set
+
+#
+# Linux Module Utilities
+#
+# CONFIG_INSMOD is not set
+# CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
+# CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
+# CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
+# CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
+# CONFIG_RMMOD is not set
+# CONFIG_LSMOD is not set
+# CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT is not set
+# CONFIG_MODPROBE is not set
+# CONFIG_FEATURE_MODPROBE_MULTIPLE_OPTIONS is not set
+# CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
+# CONFIG_FEATURE_2_4_MODULES is not set
+# CONFIG_FEATURE_2_6_MODULES is not set
+# CONFIG_FEATURE_QUERY_MODULE_INTERFACE is not set
+
+#
+# Linux System Utilities
+#
+# CONFIG_DMESG is not set
+# CONFIG_FBSET is not set
+# CONFIG_FEATURE_FBSET_FANCY is not set
+# CONFIG_FEATURE_FBSET_READMODE is not set
+# CONFIG_FDFLUSH is not set
+# CONFIG_FDFORMAT is not set
+# CONFIG_FDISK is not set
+# FDISK_SUPPORT_LARGE_DISKS is not set
+# CONFIG_FEATURE_FDISK_WRITABLE is not set
+# CONFIG_FEATURE_AIX_LABEL is not set
+# CONFIG_FEATURE_SGI_LABEL is not set
+# CONFIG_FEATURE_SUN_LABEL is not set
+# CONFIG_FEATURE_OSF_LABEL is not set
+# CONFIG_FEATURE_FDISK_ADVANCED is not set
+# CONFIG_FREERAMDISK is not set
+# CONFIG_FSCK_MINIX is not set
+# CONFIG_MKFS_MINIX is not set
+# CONFIG_FEATURE_MINIX2 is not set
+# CONFIG_GETOPT is not set
+# CONFIG_HEXDUMP is not set
+# CONFIG_HWCLOCK is not set
+# CONFIG_FEATURE_HWCLOCK_LONG_OPTIONS is not set
+# CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS is not set
+# CONFIG_IPCRM is not set
+# CONFIG_IPCS is not set
+# CONFIG_LOSETUP is not set
+# CONFIG_MDEV is not set
+# CONFIG_FEATURE_MDEV_CONF is not set
+# CONFIG_FEATURE_MDEV_EXEC is not set
+# CONFIG_MKSWAP is not set
+# CONFIG_FEATURE_MKSWAP_V0 is not set
+# CONFIG_MORE is not set
+# CONFIG_FEATURE_USE_TERMIOS is not set
+# CONFIG_LINUX_MOUNT is not set
+# CONFIG_FEATURE_MOUNT_NFS is not set
+# CONFIG_PIVOT_ROOT is not set
+# CONFIG_RDATE is not set
+# CONFIG_READPROFILE is not set
+# CONFIG_SETARCH is not set
+# CONFIG_SWAPONOFF is not set
+# CONFIG_SWITCH_ROOT is not set
+# CONFIG_LINUX_UMOUNT is not set
+# CONFIG_FEATURE_UMOUNT_ALL is not set
+
+#
+# Common options for mount/umount
+#
+# CONFIG_FEATURE_MOUNT_LOOP is not set
+# CONFIG_FEATURE_MTAB_SUPPORT is not set
+
+#
+# Miscellaneous Utilities
+#
+# CONFIG_ADJTIMEX is not set
+# CONFIG_BBCONFIG is not set
+# CONFIG_CROND is not set
+# CONFIG_DEBUG_CROND_OPTION is not set
+# CONFIG_FEATURE_CROND_CALL_SENDMAIL is not set
+# CONFIG_CRONTAB is not set
+# CONFIG_DC is not set
+# CONFIG_DEVFSD is not set
+# CONFIG_DEVFSD_MODLOAD is not set
+# CONFIG_DEVFSD_FG_NP is not set
+# CONFIG_DEVFSD_VERBOSE is not set
+# CONFIG_FEATURE_DEVFS is not set
+# CONFIG_EJECT is not set
+# CONFIG_LAST is not set
+CONFIG_LESS=y
+CONFIG_FEATURE_LESS_BRACKETS=y
+CONFIG_FEATURE_LESS_FLAGS=y
+# CONFIG_FEATURE_LESS_FLAGCS is not set
+# CONFIG_FEATURE_LESS_MARKS is not set
+# CONFIG_FEATURE_LESS_REGEXP is not set
+# CONFIG_HDPARM is not set
+# CONFIG_FEATURE_HDPARM_GET_IDENTITY is not set
+# CONFIG_FEATURE_HDPARM_HDIO_SCAN_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_DRIVE_RESET is not set
+# CONFIG_FEATURE_HDPARM_HDIO_TRISTATE_HWIF is not set
+# CONFIG_FEATURE_HDPARM_HDIO_GETSET_DMA is not set
+# CONFIG_MAKEDEVS is not set
+# CONFIG_FEATURE_MAKEDEVS_LEAF is not set
+# CONFIG_FEATURE_MAKEDEVS_TABLE is not set
+# CONFIG_MOUNTPOINT is not set
+# CONFIG_MT is not set
+# CONFIG_RUNLEVEL is not set
+# CONFIG_RX is not set
+# CONFIG_STRINGS is not set
+# CONFIG_SETSID is not set
+# CONFIG_TASKSET is not set
+# CONFIG_TIME is not set
+# CONFIG_WATCHDOG is not set
+
+#
+# Networking Utilities
+#
+# CONFIG_FEATURE_IPV6 is not set
+# CONFIG_ARPING is not set
+# CONFIG_DNSD is not set
+# CONFIG_ETHER_WAKE is not set
+# CONFIG_FAKEIDENTD is not set
+# CONFIG_FTPGET is not set
+# CONFIG_FTPPUT is not set
+# CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS is not set
+CONFIG_HOSTNAME=y
+# CONFIG_HTTPD is not set
+# CONFIG_FEATURE_HTTPD_WITHOUT_INETD is not set
+# CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP is not set
+# CONFIG_FEATURE_HTTPD_SETUID is not set
+# CONFIG_FEATURE_HTTPD_BASIC_AUTH is not set
+# CONFIG_FEATURE_HTTPD_AUTH_MD5 is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES is not set
+# CONFIG_FEATURE_HTTPD_CGI is not set
+# CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR is not set
+# CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV is not set
+# CONFIG_FEATURE_HTTPD_ENCODE_URL_STR is not set
+# CONFIG_IFCONFIG is not set
+# CONFIG_FEATURE_IFCONFIG_STATUS is not set
+# CONFIG_FEATURE_IFCONFIG_SLIP is not set
+# CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ is not set
+# CONFIG_FEATURE_IFCONFIG_HW is not set
+# CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS is not set
+# CONFIG_IFUPDOWN is not set
+# CONFIG_FEATURE_IFUPDOWN_IP is not set
+# CONFIG_FEATURE_IFUPDOWN_IP_BUILTIN is not set
+# CONFIG_FEATURE_IFUPDOWN_IPV4 is not set
+# CONFIG_FEATURE_IFUPDOWN_IPV6 is not set
+# CONFIG_FEATURE_IFUPDOWN_IPX is not set
+# CONFIG_FEATURE_IFUPDOWN_MAPPING is not set
+# CONFIG_INETD is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME is not set
+# CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN is not set
+# CONFIG_FEATURE_INETD_RPC is not set
+# CONFIG_IP is not set
+# CONFIG_FEATURE_IP_ADDRESS is not set
+# CONFIG_FEATURE_IP_LINK is not set
+# CONFIG_FEATURE_IP_ROUTE is not set
+# CONFIG_FEATURE_IP_TUNNEL is not set
+# CONFIG_FEATURE_IP_SHORT_FORMS is not set
+# CONFIG_IPADDR is not set
+# CONFIG_IPLINK is not set
+# CONFIG_IPROUTE is not set
+# CONFIG_IPTUNNEL is not set
+# CONFIG_IPCALC is not set
+# CONFIG_FEATURE_IPCALC_FANCY is not set
+# CONFIG_FEATURE_IPCALC_LONG_OPTIONS is not set
+# CONFIG_NAMEIF is not set
+CONFIG_NC=y
+# CONFIG_NC_GAPING_SECURITY_HOLE is not set
+# CONFIG_NETSTAT is not set
+CONFIG_NSLOOKUP=y
+# CONFIG_PING is not set
+# CONFIG_FEATURE_FANCY_PING is not set
+# CONFIG_PING6 is not set
+# CONFIG_FEATURE_FANCY_PING6 is not set
+# CONFIG_ROUTE is not set
+CONFIG_TELNET=y
+# CONFIG_FEATURE_TELNET_TTYPE is not set
+# CONFIG_FEATURE_TELNET_AUTOLOGIN is not set
+# CONFIG_TELNETD is not set
+# CONFIG_FEATURE_TELNETD_INETD is not set
+# CONFIG_TFTP is not set
+# CONFIG_FEATURE_TFTP_GET is not set
+# CONFIG_FEATURE_TFTP_PUT is not set
+# CONFIG_FEATURE_TFTP_BLOCKSIZE is not set
+# CONFIG_DEBUG_TFTP is not set
+# CONFIG_TRACEROUTE is not set
+# CONFIG_FEATURE_TRACEROUTE_VERBOSE is not set
+# CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE is not set
+# CONFIG_FEATURE_TRACEROUTE_USE_ICMP is not set
+
+#
+# udhcp Server/Client
+#
+# CONFIG_APP_UDHCPD is not set
+# CONFIG_APP_UDHCPC is not set
+# CONFIG_APP_DUMPLEASES is not set
+# CONFIG_FEATURE_UDHCP_SYSLOG is not set
+# CONFIG_FEATURE_UDHCP_DEBUG is not set
+# CONFIG_VCONFIG is not set
+# CONFIG_WGET is not set
+# CONFIG_FEATURE_WGET_STATUSBAR is not set
+# CONFIG_FEATURE_WGET_AUTHENTICATION is not set
+# CONFIG_FEATURE_WGET_IP6_LITERAL is not set
+# CONFIG_FEATURE_WGET_LONG_OPTIONS is not set
+# CONFIG_ZCIP is not set
+
+#
+# Process Utilities
+#
+# CONFIG_FREE is not set
+# CONFIG_FUSER is not set
+CONFIG_KILL=y
+# CONFIG_KILLALL is not set
+# CONFIG_PIDOF is not set
+# CONFIG_FEATURE_PIDOF_SINGLE is not set
+# CONFIG_FEATURE_PIDOF_OMIT is not set
+CONFIG_PS=y
+# CONFIG_FEATURE_PS_WIDE is not set
+# CONFIG_RENICE is not set
+# CONFIG_BB_SYSCTL is not set
+# CONFIG_TOP is not set
+# CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE is not set
+# CONFIG_UPTIME is not set
+
+#
+# Shells
+#
+# CONFIG_FEATURE_SH_IS_ASH is not set
+CONFIG_FEATURE_SH_IS_HUSH=y
+# CONFIG_FEATURE_SH_IS_LASH is not set
+# CONFIG_FEATURE_SH_IS_MSH is not set
+# CONFIG_FEATURE_SH_IS_NONE is not set
+# CONFIG_ASH is not set
+# CONFIG_ASH_JOB_CONTROL is not set
+# CONFIG_ASH_READ_NCHARS is not set
+# CONFIG_ASH_READ_TIMEOUT is not set
+# CONFIG_ASH_ALIAS is not set
+# CONFIG_ASH_MATH_SUPPORT is not set
+# CONFIG_ASH_MATH_SUPPORT_64 is not set
+# CONFIG_ASH_GETOPTS is not set
+# CONFIG_ASH_BUILTIN_ECHO is not set
+# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_CMDCMD is not set
+# CONFIG_ASH_MAIL is not set
+# CONFIG_ASH_OPTIMIZE_FOR_SIZE is not set
+# CONFIG_ASH_RANDOM_SUPPORT is not set
+# CONFIG_ASH_EXPAND_PRMT is not set
+CONFIG_HUSH=y
+# CONFIG_LASH is not set
+# CONFIG_MSH is not set
+
+#
+# Bourne Shell Options
+#
+# CONFIG_FEATURE_SH_EXTRA_QUIET is not set
+# CONFIG_FEATURE_SH_STANDALONE_SHELL is not set
+# CONFIG_FEATURE_COMMAND_EDITING is not set
+# CONFIG_FEATURE_COMMAND_EDITING_VI is not set
+CONFIG_FEATURE_COMMAND_HISTORY=0
+# CONFIG_FEATURE_COMMAND_SAVEHISTORY is not set
+# CONFIG_FEATURE_COMMAND_TAB_COMPLETION is not set
+# CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION is not set
+# CONFIG_FEATURE_SH_FANCY_PROMPT is not set
+
+#
+# System Logging Utilities
+#
+# CONFIG_SYSLOGD is not set
+# CONFIG_FEATURE_ROTATE_LOGFILE is not set
+# CONFIG_FEATURE_REMOTE_LOG is not set
+# CONFIG_FEATURE_IPC_SYSLOG is not set
+CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE=0
+# CONFIG_LOGREAD is not set
+# CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING is not set
+# CONFIG_KLOGD is not set
+# CONFIG_LOGGER is not set
diff -rupN busybox-1.2.0/.indent.pro busybox-1.2.0solaris/.indent.pro
--- busybox-1.2.0/.indent.pro	2006-07-01 02:42:13.000000000 +0400
+++ busybox-1.2.0solaris/.indent.pro	1970-01-01 03:00:00.000000000 +0300
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -rupN busybox-1.2.0/Makefile busybox-1.2.0solaris/Makefile
--- busybox-1.2.0/Makefile	2006-07-01 02:42:13.000000000 +0400
+++ busybox-1.2.0solaris/Makefile	2009-04-21 09:19:16.140959295 +0400
@@ -8,6 +8,8 @@
 # You shouldn't have to edit anything in this file for configuration
 # purposes, try "make help" or read http://busybox.net/FAQ.html.
 
+# 21.04.2009 Alexander Eremin <eremin@milax.org> Changed some applets for solaris support 
+#
 .PHONY: dummy subdirs release distclean clean config oldconfig menuconfig \
         tags check test depend dep buildtree hosttools _all checkhelp \
         sizes bloatcheck baseline objsizes
@@ -34,7 +36,7 @@ vpath %/Config.in $(srctree)
 DIRS:=applets archival archival/libunarchive coreutils console-tools \
 	debianutils editors findutils init miscutils modutils networking \
 	networking/libiproute networking/udhcp procps loginutils shell \
-	sysklogd util-linux e2fsprogs libpwdgrp coreutils/libcoreutils libbb
+	sysklogd util-linux e2fsprogs coreutils/libcoreutils libbb
 
 SRC_DIRS:=$(patsubst %,$(top_srcdir)/%,$(DIRS))
 
@@ -253,7 +255,7 @@ hosttools:
 
 else # ifneq ($(strip $(HAVE_DOT_CONFIG)),y)
 
-all: busybox busybox.links doc
+all: busybox busybox.links 
 
 # In this section, we need .config
 -include $(top_builddir)/.config.cmd
@@ -284,7 +286,6 @@ else  # CONFIG_BUILD_AT_ONCE
 # This was the old way the binary was built.
 libbusybox-obj:=archival/libunarchive/libunarchive.a \
 	networking/libiproute/libiproute.a \
-	libpwdgrp/libpwdgrp.a \
 	coreutils/libcoreutils/libcoreutils.a \
 	libbb/libbb.a
 libbusybox-obj:=$(patsubst %,$(top_builddir)/%,$(libbusybox-obj))
diff -rupN busybox-1.2.0/Rules.mak busybox-1.2.0solaris/Rules.mak
--- busybox-1.2.0/Rules.mak	2006-07-01 02:42:13.000000000 +0400
+++ busybox-1.2.0solaris/Rules.mak	2009-04-20 16:16:13.284583049 +0400
@@ -60,8 +60,8 @@ ARFLAGS=cru
 
 # gcc centric. Perhaps fiddle with findstring gcc,$(CC) for the rest
 # get the CC MAJOR/MINOR version
-CC_MAJOR:=$(shell printf "%02d" $(shell echo __GNUC__ | $(CC) -E -xc - | tail -n 1))
-CC_MINOR:=$(shell printf "%02d" $(shell echo __GNUC_MINOR__ | $(CC) -E -xc - | tail -n 1))
+CC_MAJOR:=$(shell printf "%02d" $(shell echo __GNUC__ | $(CC) -E -xc - | tail -1))
+CC_MINOR:=$(shell printf "%02d" $(shell echo __GNUC_MINOR__ | $(CC) -E -xc - | tail -1))
 
 #--------------------------------------------------------
 export VERSION BUILDTIME HOSTCC HOSTCFLAGS CROSS CC AR AS LD NM STRIP CPP
@@ -315,7 +315,7 @@ endif
 
 OBJECTS:=$(APPLET_SOURCES:.c=.o) busybox.o usage.o applets.o
 CFLAGS  += $(CHECKED_CFLAGS) $(CROSS_CFLAGS)
-LDFLAGS += $(CHECKED_LDFLAGS)
+LDFLAGS += $(CHECKED_LDFLAGS) -lsocket -lnsl -lresolv -lpam -lbsm -lcontract -lscf -lproject
 
 ifdef BB_INIT_SCRIPT
     CFLAGS += -DINIT_SCRIPT='"$(BB_INIT_SCRIPT)"'
diff -rupN busybox-1.2.0/applets/busybox.mkll busybox-1.2.0solaris/applets/busybox.mkll
--- busybox-1.2.0/applets/busybox.mkll	2006-07-01 02:42:12.000000000 +0400
+++ busybox-1.2.0solaris/applets/busybox.mkll	2009-04-18 09:32:28.985158691 +0400
@@ -7,13 +7,13 @@
 
 # Maintainer: Larry Doolittle <ldoolitt@recycle.lbl.gov>
 
-export LC_ALL=POSIX
-export LC_CTYPE=POSIX
+#export LC_ALL=POSIX
+#export LC_CTYPE=POSIX
 
 CONFIG_H=${1:-include/bb_config.h}
 APPLETS_H=${2:-include/applets.h}
 $HOSTCC -E -DMAKE_LINKS -include $CONFIG_H $APPLETS_H |
-  awk '/^[ \t]*LINK/{
+  gawk '/^[ \t]*LINK/{
 	dir=substr($2,8)
 	gsub("_","/",dir)
 	if(dir=="/ROOT") dir=""
diff -rupN busybox-1.2.0/coreutils/Config.in busybox-1.2.0solaris/coreutils/Config.in
--- busybox-1.2.0/coreutils/Config.in	2006-07-01 02:42:07.000000000 +0400
+++ busybox-1.2.0solaris/coreutils/Config.in	2009-04-20 11:26:38.183889195 +0400
@@ -424,6 +424,12 @@ config CONFIG_MKNOD
 	  mknod is used to create FIFOs or block/character special
 	  files with the specified names.
 
+config CONFIG_MOUNT
+	bool "mount"
+	default n
+	help
+	  mount is used to mount filesystems.
+
 config CONFIG_MV
 	bool "mv"
 	default n
@@ -659,6 +665,12 @@ config CONFIG_TTY
 	  tty is used to print the name of the current terminal to
 	  standard output.
 
+config CONFIG_UMOUNT
+	bool "umount"
+	default n
+	help
+	  umount is used to umount filesystems.
+
 config CONFIG_UNAME
 	bool "uname"
 	default n
diff -rupN busybox-1.2.0/coreutils/Makefile.in busybox-1.2.0solaris/coreutils/Makefile.in
--- busybox-1.2.0/coreutils/Makefile.in	2006-07-01 02:42:07.000000000 +0400
+++ busybox-1.2.0solaris/coreutils/Makefile.in	2009-04-20 11:26:05.311131296 +0400
@@ -48,6 +48,7 @@ COREUTILS-$(CONFIG_MD5SUM)    += md5_sha
 COREUTILS-$(CONFIG_MKDIR)     += mkdir.o
 COREUTILS-$(CONFIG_MKFIFO)    += mkfifo.o
 COREUTILS-$(CONFIG_MKNOD)     += mknod.o
+COREUTILS-$(CONFIG_MOUNT)     += mount.o
 COREUTILS-$(CONFIG_MV)        += mv.o
 COREUTILS-$(CONFIG_NICE)      += nice.o
 COREUTILS-$(CONFIG_NOHUP)     += nohup.o
@@ -73,6 +74,7 @@ COREUTILS-$(CONFIG_TOUCH)     += touch.o
 COREUTILS-$(CONFIG_TR)        += tr.o
 COREUTILS-$(CONFIG_TRUE)      += true.o
 COREUTILS-$(CONFIG_TTY)       += tty.o
+COREUTILS-$(CONFIG_UMOUNT)     += umount.o
 COREUTILS-$(CONFIG_UNAME)     += uname.o
 COREUTILS-$(CONFIG_UNIQ)      += uniq.o
 COREUTILS-$(CONFIG_USLEEP)    += usleep.o
@@ -93,10 +95,12 @@ endif
 COREUTILS_SRC-y:=$(patsubst %.o,$(srcdir)/%.c,$(COREUTILS-y))
 COREUTILS_SRC-a:=$(wildcard $(srcdir)/*.c)
 APPLET_SRC-y+=$(COREUTILS_SRC-y)
-APPLET_SRC-a+=$(COREUTILS_SRC-a)
+APPLET_SRC-a+=$(COREUTILS_SRC-a) 
 
-$(COREUTILS_DIR)$(COREUTILS_AR): $(patsubst %,$(COREUTILS_DIR)%, $(COREUTILS-y))
+$(COREUTILS_DIR)$(COREUTILS_AR): $(patsubst %,$(COREUTILS_DIR)%, $(COREUTILS-y)) 
 	$(do_ar)
 
-$(COREUTILS_DIR)%.o: $(srcdir)/%.c
-	$(compile.c)
+$(COREUTILS_DIR)%.o: $(srcdir)/%.c 
+	$(compile.c) 
+
+#$(COREUTILS_DIR)/deffs.c $(COREUTILS_DIR)/fslib.c
diff -rupN busybox-1.2.0/coreutils/deffs.c busybox-1.2.0solaris/coreutils/deffs.c
--- busybox-1.2.0/coreutils/deffs.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/coreutils/deffs.c	2009-04-20 11:11:45.916832182 +0400
@@ -0,0 +1,74 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/* Copyright (c) 1984, 1986, 1987, 1988, 1989, 1990, 1991, 1997 SMI	*/
+/* All Rights Reserved							*/
+
+#include	<stdio.h>
+#include        <deflt.h>
+#include        <string.h>
+
+#define	LOCAL		"/etc/default/fs"
+#define	REMOTE		"/etc/dfs/fstypes"
+
+/*
+ * This is used to figure out the default file system type if "-F FStype"
+ * is not specified with the file system command and no entry in the
+ * /etc/vfstab matches the specified special.
+ * If the first character of the "special" is a "/" (eg, "/dev/dsk/c0d1s2"),
+ * returns the default local filesystem type.
+ * Otherwise (eg, "server:/path/name" or "resource"), returns the default
+ * remote filesystem type.
+ */
+char	*
+default_fstype(char *special)
+{
+	char	*deffs;
+	static	char	buf[BUFSIZ];
+	FILE	*fp;
+
+	if (*special == '/') {
+		if (defopen(LOCAL) != 0)
+			return ("ufs");
+		else {
+			if ((deffs = defread("LOCAL=")) == NULL) {
+				defopen(NULL);	/* close default file */
+				return ("ufs");
+			} else {
+				defopen(NULL);	/* close default file */
+				return (deffs);
+			}
+		}
+	} else {
+		if ((fp = fopen(REMOTE, "r")) == NULL)
+			return ("nfs");
+		else {
+			if (fgets(buf, sizeof (buf), fp) == NULL) {
+				fclose(fp);
+				return ("nfs");
+			} else {
+				deffs = strtok(buf, " \t\n");
+				fclose(fp);
+				return (deffs);
+			}
+		}
+	}
+}
diff -rupN busybox-1.2.0/coreutils/df.c busybox-1.2.0solaris/coreutils/df.c
--- busybox-1.2.0/coreutils/df.c	2006-07-01 02:42:07.000000000 +0400
+++ busybox-1.2.0solaris/coreutils/df.c	2009-04-20 12:51:11.541323092 +0400
@@ -1,149 +1,1784 @@
-/* vi: set sw=4 ts=4: */
 /*
- * Mini df implementation for busybox
+ * CDDL HEADER START
  *
- * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
- * based on original code by (I think) Bruce Perens <bruce@pixar.com>.
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
  *
- * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
  */
+/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
+/*	  All Rights Reserved  	*/
 
-/* BB_AUDIT SUSv3 _NOT_ compliant -- options -P and -t missing.  Also blocksize. */
-/* http://www.opengroup.org/onlinepubs/007904975/utilities/df.html */
 
-/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
- *
- * Size reduction.  Removed floating point dependency.  Added error checking
- * on output.  Output stats on 0-sized filesystems if specifically listed on
- * the command line.  Properly round *-blocks, Used, and Available quantities.
+/*
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
  */
 
+#include <dlfcn.h>
 #include <stdio.h>
-#include <stdlib.h>
+#include <stdarg.h>
 #include <string.h>
+#include <locale.h>
+#include <libintl.h>
+#include <stdlib.h>
+#include <ftw.h>
+#include <errno.h>
+#include <sys/types.h>
 #include <unistd.h>
-#include <mntent.h>
-#include <sys/vfs.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/param.h>
+#include <sys/mnttab.h>
+#include <sys/mntent.h>
+#include <sys/vfstab.h>
+#include <sys/wait.h>
+#include <sys/mkdev.h>
+#include <sys/int_limits.h>
+#include <sys/zone.h>
+#include <libzfs.h>
+
+#include "deffs.c"
+#include "fslib.c"
+#include "fslib.h"
+
 #include "busybox.h"
 
-#ifndef CONFIG_FEATURE_HUMAN_READABLE
-static long kscale(long b, long bs)
+extern char *default_fstype(char *);
+
+/*
+ * General notice:
+ * String pointers in this code may point to statically allocated memory
+ * or dynamically allocated memory. Furthermore, a dynamically allocated
+ * string may be pointed to by more than one pointer. This does not pose
+ * a problem because malloc'ed memory is never free'd (so we don't need
+ * to remember which pointers point to malloc'ed memory).
+ */
+
+/*
+ * TRANSLATION_NOTE
+ * Only strings passed as arguments to the TRANSLATE macro need to
+ * be translated.
+ */
+
+#ifndef MNTTYPE_LOFS
+#define	MNTTYPE_LOFS		"lofs"
+#endif
+
+#define	EQ(s1, s2)		(strcmp(s1, s2) == 0)
+#define	NEW(type)		xmalloc(sizeof (type))
+#define	CLEAR(var)		(void) memset(&(var), 0, sizeof (var))
+#define	MAX(a, b)		((a) > (b) ? (a) : (b))
+#define	MAX3(a, b, c)		MAX(a, MAX(b, c))
+#define	TRANSLATE(s)		new_string(s)
+
+#define	MAX_OPTIONS		36
+#define	N_FSTYPES		20
+#define	MOUNT_TABLE_ENTRIES	40	/* initial allocation */
+#define	MSGBUF_SIZE		1024
+#define	LINEBUF_SIZE		256	/* either input or output lines */
+
+#define	BLOCK_SIZE		512	/* when reporting in terms of blocks */
+
+#define	DEVNM_CMD		"devnm"
+#define	FS_LIBPATH		"/usr/lib/fs/"
+#define	MOUNT_TAB		"/etc/mnttab"
+#define	VFS_TAB			"/etc/vfstab"
+#define	REMOTE_FS		"/etc/dfs/fstypes"
+
+#define	NUL			'\0'
+
+/*
+ * Formatting constants
+ */
+#define	IBCS2_FILESYSTEM_WIDTH	15	/* Truncate to match ISC/SCO */
+#define	IBCS2_MOUNT_POINT_WIDTH	10	/* Truncate to match ISC/SCO */
+#define	FILESYSTEM_WIDTH	20
+#define	MOUNT_POINT_WIDTH	19
+#define	SPECIAL_DEVICE_WIDTH	18
+#define	FSTYPE_WIDTH		8
+#define	BLOCK_WIDTH		8
+#define	NFILES_WIDTH		8
+#define	KBYTE_WIDTH		7
+#define	AVAILABLE_WIDTH		6
+#define	SCALED_WIDTH		6
+#define	CAPACITY_WIDTH		9
+#define	BSIZE_WIDTH		6
+#define	FRAGSIZE_WIDTH		7
+#define	FSID_WIDTH		7
+#define	FLAG_WIDTH		8
+#define	NAMELEN_WIDTH		7
+#define	MNT_SPEC_WIDTH		MOUNT_POINT_WIDTH + SPECIAL_DEVICE_WIDTH + 2
+
+/*
+ * Flags for the errmsg() function
+ */
+#define	ERR_NOFLAGS		0x0
+#define	ERR_NONAME		0x1	/* don't include the program name */
+					/* as a prefix */
+#define	ERR_FATAL		0x2	/* call exit after printing the */
+					/* message */
+#define	ERR_PERROR		0x4	/* append an errno explanation to */
+					/* the message */
+#define	ERR_USAGE		0x8	/* print the usage line after the */
+					/* message */
+
+#define	NUMBER_WIDTH		40
+
+/*
+ * A numbuf_t is used when converting a number to a string representation
+ */
+typedef char numbuf_t[ NUMBER_WIDTH ];
+
+/*
+ * We use bool_int instead of int to make clear which variables are
+ * supposed to be boolean
+ */
+typedef int bool_int;
+
+struct mtab_entry {
+	bool_int	mte_dev_is_valid;
+	dev_t		mte_dev;
+	bool_int	mte_ignore;	/* the "ignore" option was set */
+	struct extmnttab	*mte_mount;
+};
+
+
+struct df_request {
+	bool_int		dfr_valid;
+	char			*dfr_cmd_arg;	/* what the user specified */
+	struct mtab_entry	*dfr_mte;
+	char			*dfr_fstype;
+	int			dfr_index;	/* to make qsort stable	*/
+};
+
+#define	DFR_MOUNT_POINT(dfrp)	(dfrp)->dfr_mte->mte_mount->mnt_mountp
+#define	DFR_SPECIAL(dfrp)	(dfrp)->dfr_mte->mte_mount->mnt_special
+#define	DFR_FSTYPE(dfrp)	(dfrp)->dfr_mte->mte_mount->mnt_fstype
+#define	DFR_ISMOUNTEDFS(dfrp)	((dfrp)->dfr_mte != NULL)
+
+#define	DFRP(p)			((struct df_request *)(p))
+
+typedef void (*output_func)(struct df_request *, struct statvfs64 *);
+
+struct df_output {
+	output_func	dfo_func;	/* function that will do the output */
+	int		dfo_flags;
+};
+
+/*
+ * Output flags
+ */
+#define	DFO_NOFLAGS	0x0
+#define	DFO_HEADER	0x1		/* output preceded by header */
+#define	DFO_STATVFS	0x2		/* must do a statvfs64(2) */
+
+
+static char	*program_name;
+static char	df_options[MAX_OPTIONS] = "-";
+static size_t	df_options_len = 1;
+static char	*o_option_arg;			/* arg to the -o option */
+static char	*FSType;
+static char	*remote_fstypes[N_FSTYPES+1];	/* allocate an extra one */
+						/* to use as a terminator */
+
+/*
+ * The following three variables support an in-memory copy of the mount table
+ * to speedup searches.
+ */
+static struct mtab_entry	*mount_table;	/* array of mtab_entry's */
+static size_t			mount_table_entries;
+static size_t			mount_table_allocated_entries;
+
+static bool_int		F_option;
+static bool_int		V_option;
+static bool_int		P_option;	/* Added for XCU4 compliance */
+static bool_int		Z_option;
+static bool_int		v_option;
+#ifdef	_iBCS2
+char			*sysv3_set;
+#endif /* _iBCS2 */
+static bool_int		a_option;
+static bool_int		h_option;
+static bool_int		k_option;
+static bool_int		n_option;
+static bool_int		o_option;
+
+static bool_int		tty_output;
+static bool_int		use_scaling;
+static int		scale;
+
+static void do_devnm(int, char **);
+static void do_df(int, char **)	__NORETURN;
+static void parse_options(int, char **);
+static char *basename(char *);
+
+static libzfs_handle_t *(*_libzfs_init)(boolean_t);
+static zfs_handle_t *(*_zfs_open)(libzfs_handle_t *, const char *, int);
+static void (*_zfs_close)(zfs_handle_t *);
+static uint64_t (*_zfs_prop_get_int)(zfs_handle_t *, zfs_prop_t);
+static libzfs_handle_t *g_zfs;
+
+/*
+ * Dynamically check for libzfs, in case the user hasn't installed the SUNWzfs
+ * packages.  A basic utility such as df shouldn't depend on optional
+ * filesystems.
+ */
+static boolean_t
+load_libzfs(void)
 {
-	return ( b * (long long) bs + KILOBYTE/2 ) / KILOBYTE;
+	void *hdl;
+
+	if (_libzfs_init != NULL)
+		return (g_zfs != NULL);
+
+	if ((hdl = dlopen("libzfs.so", RTLD_LAZY)) != NULL) {
+		_libzfs_init = (libzfs_handle_t *(*)(boolean_t))dlsym(hdl,
+		    "libzfs_init");
+		_zfs_open = (zfs_handle_t *(*)())dlsym(hdl, "zfs_open");
+		_zfs_close = (void (*)())dlsym(hdl, "zfs_close");
+		_zfs_prop_get_int = (uint64_t (*)())
+		    dlsym(hdl, "zfs_prop_get_int");
+
+		if (_libzfs_init != NULL) {
+			assert(_zfs_open != NULL);
+			assert(_zfs_close != NULL);
+			assert(_zfs_prop_get_int != NULL);
+
+			g_zfs = _libzfs_init(B_FALSE);
+		}
+	}
+
+	return (g_zfs != NULL);
 }
-#endif
 
-int df_main(int argc, char **argv)
+int
+df_main(int argc, char *argv[])
 {
-	long blocks_used;
-	long blocks_percent_used;
-#ifdef CONFIG_FEATURE_HUMAN_READABLE
-	unsigned long df_disp_hr = KILOBYTE;
+	(void) setlocale(LC_ALL, "");
+
+#if !defined(TEXT_DOMAIN)		/* Should be defined by cc -D */
+#define	TEXT_DOMAIN "SYS_TEST"
 #endif
-	int status = EXIT_SUCCESS;
-	unsigned long opt;
-	FILE *mount_table;
-	struct mntent *mount_entry;
-	struct statfs s;
-	static const char hdr_1k[] = "1k-blocks"; /* default display is kilobytes */
-	const char *disp_units_hdr = hdr_1k;
-
-#ifdef CONFIG_FEATURE_HUMAN_READABLE
-	bb_opt_complementally = "h-km:k-hm:m-hk";
-	opt = bb_getopt_ulflags(argc, argv, "hmk");
-	if(opt & 1) {
-				df_disp_hr = 0;
-				disp_units_hdr = "     Size";
-	}
-	if(opt & 2) {
-				df_disp_hr = MEGABYTE;
-				disp_units_hdr = "1M-blocks";
+	(void) textdomain(TEXT_DOMAIN);
+
+	program_name = basename(argv[0]);
+
+#ifdef	_iBCS2
+	sysv3_set = getenv("SYSV3");
+#endif	/* _iBCS2 */
+
+	if (EQ(program_name, DEVNM_CMD))
+		do_devnm(argc, argv);
+
+	parse_options(argc, argv);
+
+	/*
+	 * The k_option implies SunOS 4.x compatibility: when the special
+	 * device name is too long the line will be split except when the
+	 * output has been redirected.
+	 * This is also valid for the -h option.
+	 */
+
+	if (use_scaling || k_option || P_option || v_option)
+		tty_output = isatty(1);
+
+	do_df(argc - optind, &argv[optind]);
+	/* NOTREACHED */
+}
+
+
+/*
+ * Prints an error message to stderr.
+ */
+/* VARARGS2 */
+static void
+errmsg(int flags, char *fmt, ...)
+{
+	char buf[MSGBUF_SIZE];
+	va_list ap;
+	int cc;
+	int offset;
+
+	if (flags & ERR_NONAME)
+		offset = 0;
+	else
+		offset = sprintf(buf, "%s: ", program_name);
+
+	va_start(ap, fmt);
+	cc = vsprintf(&buf[offset], fmt, ap);
+	offset += cc;
+	va_end(ap);
+
+	if (flags & ERR_PERROR) {
+		if (buf[offset-1] != ' ')
+			(void) strcat(buf, " ");
+		(void) strcat(buf, strerror(errno));
 	}
-#else
-	opt = bb_getopt_ulflags(argc, argv, "k");
-#endif
+	(void) fprintf(stderr, "%s\n", buf);
+	if (flags & ERR_USAGE)
+	bb_show_usage();
+	if (flags & ERR_FATAL)
+		exit(1);
+}
+
+static char *
+new_string(char *s)
+{
+	char *p = NULL;
+
+	if (s) {
+		p = strdup(s);
+		if (p)
+			return (p);
+		errmsg(ERR_FATAL, "out of memory");
+		/* NOTREACHED */
+	}
+	return (p);
+}
+
+/*
+ * fopen the specified file for reading but terminate if the fopen fails
+ */
+static FILE *
+xfopen(char *file)
+{
+	FILE *fp = fopen(file, "r");
+
+	if (fp == NULL)
+		errmsg(ERR_FATAL + ERR_PERROR, "failed to open %s:", file);
+	return (fp);
+}
+
+
+/*
+ * Read remote file system types from REMOTE_FS into the
+ * remote_fstypes array.
+ */
+static void
+init_remote_fs(void)
+{
+	FILE	*fp;
+	char	line_buf[LINEBUF_SIZE];
+	size_t	fstype_index = 0;
+
+	if ((fp = fopen(REMOTE_FS, "r")) == NULL) {
+		errmsg(ERR_NOFLAGS,
+		    "Warning: can't open %s, ignored", REMOTE_FS);
+		return;
+	}
+
+	while (fgets(line_buf, sizeof (line_buf), fp) != NULL) {
+		char buf[LINEBUF_SIZE];
+
+		(void) sscanf(line_buf, "%s", buf);
+		remote_fstypes[fstype_index++] = new_string(buf);
+
+		if (fstype_index == N_FSTYPES)
+			break;
+	}
+	(void) fclose(fp);
+}
 
-	bb_printf("Filesystem%11s%-15sUsed Available Use%% Mounted on\n",
-			  "", disp_units_hdr);
 
-	mount_table = NULL;
-	argv += optind;
-	if (optind >= argc) {
-		if (!(mount_table = setmntent(bb_path_mtab_file, "r"))) {
-			bb_perror_msg_and_die(bb_path_mtab_file);
+/*
+ * Returns TRUE if fstype is a remote file system type;
+ * otherwise, returns FALSE.
+ */
+static int
+is_remote_fs(char *fstype)
+{
+	char **p;
+	static bool_int remote_fs_initialized;
+
+	if (! remote_fs_initialized) {
+		init_remote_fs();
+		remote_fs_initialized = TRUE;
+	}
+
+	for (p = remote_fstypes; *p; p++)
+		if (EQ(fstype, *p))
+			return (TRUE);
+	return (FALSE);
+}
+
+
+static char *
+basename(char *s)
+{
+	char *p = strrchr(s, '/');
+
+	return (p ? p+1 : s);
+}
+
+
+/*
+ * Create a new "struct extmnttab" and make sure that its fields point
+ * to malloc'ed memory
+ */
+static struct extmnttab *
+mntdup(struct extmnttab *old)
+{
+	struct extmnttab *new = NEW(struct extmnttab);
+
+	new->mnt_special = new_string(old->mnt_special);
+	new->mnt_mountp  = new_string(old->mnt_mountp);
+	new->mnt_fstype  = new_string(old->mnt_fstype);
+	new->mnt_mntopts = new_string(old->mnt_mntopts);
+	new->mnt_time    = new_string(old->mnt_time);
+	new->mnt_major   = old->mnt_major;
+	new->mnt_minor   = old->mnt_minor;
+	return (new);
+}
+
+
+static void
+mtab_error(char *mtab_file, int status)
+{
+	if (status == MNT_TOOLONG)
+		errmsg(ERR_NOFLAGS, "a line in %s exceeds %d characters",
+		    mtab_file, MNT_LINE_MAX);
+	else if (status == MNT_TOOMANY)
+		errmsg(ERR_NOFLAGS,
+		    "a line in %s has too many fields", mtab_file);
+	else if (status == MNT_TOOFEW)
+		errmsg(ERR_NOFLAGS,
+		    "a line in %s has too few fields", mtab_file);
+	else
+		errmsg(ERR_NOFLAGS,
+		    "error while reading %s: %d", mtab_file, status);
+	exit(1);
+	/* NOTREACHED */
+}
+
+
+/*
+ * Read the mount table from the specified file.
+ * We keep the table in memory for faster lookups.
+ */
+static void
+mtab_read_file(void)
+{
+	char		*mtab_file = MOUNT_TAB;
+	FILE		*fp;
+	struct extmnttab	mtab;
+	int		status;
+
+	fp = xfopen(mtab_file);
+
+	resetmnttab(fp);
+	mount_table_allocated_entries = MOUNT_TABLE_ENTRIES;
+	mount_table_entries = 0;
+	mount_table = xmalloc(
+	    mount_table_allocated_entries * sizeof (struct mtab_entry));
+
+	while ((status = getextmntent(fp, &mtab, sizeof (struct extmnttab)))
+	    == 0) {
+		struct mtab_entry *mtep;
+
+		if (mount_table_entries == mount_table_allocated_entries) {
+			mount_table_allocated_entries += MOUNT_TABLE_ENTRIES;
+			mount_table = xrealloc(mount_table,
+			    mount_table_allocated_entries *
+			    sizeof (struct mtab_entry));
+		}
+		mtep = &mount_table[mount_table_entries++];
+		mtep->mte_mount = mntdup(&mtab);
+		mtep->mte_dev_is_valid = FALSE;
+		mtep->mte_ignore = (hasmntopt((struct mnttab *)&mtab,
+		    MNTOPT_IGNORE) != NULL);
+	}
+
+	(void) fclose(fp);
+
+	if (status == -1)			/* reached EOF */
+		return;
+	mtab_error(mtab_file, status);
+	/* NOTREACHED */
+}
+
+
+/*
+ * We use this macro when we want to record the option for the purpose of
+ * passing it to the FS-specific df
+ */
+#define	SET_OPTION(opt)		opt##_option = TRUE, \
+				df_options[df_options_len++] = arg
+
+static void
+parse_options(int argc, char *argv[])
+{
+	int arg;
+
+	opterr = 0;	/* getopt shouldn't complain about unknown options */
+
+	while ((arg = getopt(argc, argv, "F:o:ahkVnvZ")) != EOF) {
+		if (arg == 'F') {
+			if (F_option)
+				errmsg(ERR_FATAL + ERR_USAGE,
+				    "more than one FSType specified");
+			F_option = 1;
+			FSType = optarg;
+		} else if (arg == 'V' && ! V_option) {
+			V_option = TRUE;
+		} else if (arg == 'v' && ! v_option) {
+			v_option = TRUE;
+		} else if (arg == 'a' && ! a_option) {
+			SET_OPTION(a);
+		} else if (arg == 'h') {
+			use_scaling = TRUE;
+			scale = 1024;
+		} else if (arg == 'k' && ! k_option) {
+			SET_OPTION(k);
+		} else if (arg == 'n' && ! n_option) {
+			SET_OPTION(n);
+		} else if (arg == 'o') {
+			if (o_option)
+				errmsg(ERR_FATAL + ERR_USAGE,
+				"the -o option can only be specified once");
+			o_option = TRUE;
+			o_option_arg = optarg;
+		} else if (arg == 'Z') {
+			SET_OPTION(Z);
+		} else if (arg == '?') {
+			errmsg(ERR_USAGE, "unknown option: %c", optopt);
 		}
 	}
 
-	do {
-		const char *device;
-		const char *mount_point;
+	/*
+	 * Option sanity checks
+	 */
+	if (n_option && o_option)
+		errmsg(ERR_FATAL, "-o and -n options are incompatible");
+	if (use_scaling && o_option)
+		errmsg(ERR_FATAL, "-o and -h options are incompatible");
+}
+
+
+
+/*
+ * Check if the user-specified argument is a resource name.
+ * A resource name is whatever is placed in the mnt_special field of
+ * struct mnttab. In the case of NFS, a resource name has the form
+ * hostname:pathname
+ * We try to find an exact match between the user-specified argument
+ * and the mnt_special field of a mount table entry.
+ * We also use the heuristic of removing the basename from the user-specified
+ * argument and repeating the test until we get a match. This works
+ * fine for NFS but may fail for other remote file system types. However,
+ * it is guaranteed that the function will not fail if the user specifies
+ * the exact resource name.
+ * If successful, this function sets the 'dfr_mte' field of '*dfrp'
+ */
+static void
+resource_mount_entry(struct df_request *dfrp)
+{
+	char *name;
+
+	/*
+	 * We need our own copy since we will modify the string
+	 */
+	name = new_string(dfrp->dfr_cmd_arg);
 
-		if (mount_table) {
-			if (!(mount_entry = getmntent(mount_table))) {
-				endmntent(mount_table);
+	for (;;) {
+		char *p;
+		int i;
+
+		/*
+		 * Compare against all known mount points.
+		 * We start from the most recent mount, which is at the
+		 * end of the array.
+		 */
+		for (i = mount_table_entries - 1; i >= 0; i--) {
+			struct mtab_entry *mtep = &mount_table[i];
+
+			if (EQ(name, mtep->mte_mount->mnt_special)) {
+				dfrp->dfr_mte = mtep;
 				break;
 			}
-		} else {
-			if (!(mount_point = *argv++)) {
+		}
+
+		/*
+		 * Remove the last component of the pathname.
+		 * If there is no such component, this is not a resource name.
+		 */
+		p = strrchr(name, '/');
+		if (p == NULL)
+			break;
+		*p = NUL;
+	}
+}
+
+
+
+/*
+ * Try to match the command line argument which is a block special device
+ * with the special device of one of the mounted file systems.
+ * If one is found, set the appropriate field of 'dfrp' to the mount
+ * table entry.
+ */
+static void
+bdev_mount_entry(struct df_request *dfrp)
+{
+	int i;
+	char *special = dfrp->dfr_cmd_arg;
+
+	/*
+	 * Compare against all known mount points.
+	 * We start from the most recent mount, which is at the
+	 * end of the array.
+	 */
+	for (i = mount_table_entries - 1; i >= 0; i--) {
+		struct mtab_entry *mtep = &mount_table[i];
+
+		if (EQ(special, mtep->mte_mount->mnt_special)) {
+			dfrp->dfr_mte = mtep;
+			break;
+		}
+	}
+}
+
+static struct mtab_entry *
+devid_matches(int i, dev_t devno)
+{
+	struct mtab_entry	*mtep = &mount_table[i];
+	struct extmnttab	*mtp = mtep->mte_mount;
+	/* int	len = strlen(mtp->mnt_mountp); */
+
+	if (EQ(mtp->mnt_fstype, MNTTYPE_SWAP))
+		return (NULL);
+	/*
+	 * check if device numbers match. If there is a cached device number
+	 * in the mtab_entry, use it, otherwise get the device number
+	 * either from the mnttab entry or by stat'ing the mount point.
+	 */
+	if (! mtep->mte_dev_is_valid) {
+		struct stat64 st;
+		dev_t dev = NODEV;
+
+		dev = makedev(mtp->mnt_major, mtp->mnt_minor);
+		if (dev == 0)
+			dev = NODEV;
+		if (dev == NODEV) {
+			if (stat64(mtp->mnt_mountp, &st) == -1) {
+				return (NULL);
+			} else {
+				dev = st.st_dev;
+			}
+		}
+		mtep->mte_dev = dev;
+		mtep->mte_dev_is_valid = TRUE;
+	}
+	if (mtep->mte_dev == devno) {
+		return (mtep);
+	}
+	return (NULL);
+}
+
+/*
+ * Find the mount point under which the user-specified path resides
+ * and set the 'dfr_mte' field of '*dfrp' to point to the mount table entry.
+ */
+static void
+path_mount_entry(struct df_request *dfrp, dev_t devno)
+{
+	char			dirpath[MAXPATHLEN];
+	char			*dir = dfrp->dfr_cmd_arg;
+	struct mtab_entry	*match, *tmatch;
+	int i;
+
+	/*
+	 * Expand the given path to get a canonical version (i.e. an absolute
+	 * path without symbolic links).
+	 */
+	if (realpath(dir, dirpath) == NULL) {
+		errmsg(ERR_PERROR, "cannot canonicalize %s:", dir);
+		return;
+	}
+	/*
+	 * If the mnt point is lofs, search from the top of entries from
+	 * /etc/mnttab and return the first entry that matches the devid
+	 * For non-lofs mount points, return the first entry from the bottom
+	 * of the entries in /etc/mnttab that matches on the devid field
+	 */
+	match = NULL;
+	if (dfrp->dfr_fstype && EQ(dfrp->dfr_fstype, MNTTYPE_LOFS)) {
+		for (i = 0; i < mount_table_entries; i++) {
+			if (match = devid_matches(i, devno))
 				break;
+		}
+	} else {
+		for (i = mount_table_entries - 1; i >= 0; i--) {
+			if (tmatch = devid_matches(i, devno)) {
+				/*
+				 * If executing in a zone, there might be lofs
+				 * mounts for which the real mount point is
+				 * invisible; accept the "best fit" for this
+				 * devid.
+				 */
+				match = tmatch;
+				if (!EQ(match->mte_mount->mnt_fstype,
+				    MNTTYPE_LOFS)) {
+					break;
+				}
 			}
-			if (!(mount_entry = find_mount_point(mount_point, bb_path_mtab_file))) {
-				bb_error_msg("%s: can't find mount point.", mount_point);
-			SET_ERROR:
-				status = EXIT_FAILURE;
+		}
+	}
+	if (! match) {
+		errmsg(ERR_NOFLAGS,
+		    "Could not find mount point for %s", dir);
+		return;
+	}
+	dfrp->dfr_mte = match;
+}
+
+/*
+ * Execute a single FS-specific df command for all given requests
+ * Return 0 if successful, 1 otherwise.
+ */
+static int
+run_fs_specific_df(struct df_request request_list[], int entries)
+{
+	int	i;
+	int	argv_index;
+	char	**argv;
+	size_t	size;
+	pid_t	pid;
+	int	status;
+	char	cmd_path[MAXPATHLEN];
+	char	*fstype;
+
+	if (entries == 0)
+		return (0);
+
+	fstype = request_list[0].dfr_fstype;
+
+	if (F_option && ! EQ(FSType, fstype))
+		return (0);
+
+	(void) sprintf(cmd_path, "%s%s/df", FS_LIBPATH, fstype);
+	/*
+	 * Argv entries:
+	 *		1 for the path
+	 *		2 for -o <options>
+	 *		1 for the generic options that we propagate
+	 *		1 for the terminating NULL pointer
+	 *		n for the number of user-specified arguments
+	 */
+	size = (5 + entries) * sizeof (char *);
+	argv = xmalloc(size);
+	(void) memset(argv, 0, size);
+
+	argv[0] = cmd_path;
+	argv_index = 1;
+	if (o_option) {
+		argv[argv_index++] = "-o";
+		argv[argv_index++] = o_option_arg;
+	}
+
+	/*
+	 * Check if we need to propagate any generic options
+	 */
+	if (df_options_len > 1)
+		argv[argv_index++] = df_options;
+
+	/*
+	 * If there is a user-specified path, we pass that to the
+	 * FS-specific df. Otherwise, we are guaranteed to have a mount
+	 * point, since a request without a user path implies that
+	 * we are reporting only on mounted file systems.
+	 */
+	for (i = 0; i < entries; i++) {
+		struct df_request *dfrp = &request_list[i];
+
+		argv[argv_index++] = (dfrp->dfr_cmd_arg == NULL)
+		    ? DFR_MOUNT_POINT(dfrp)
+		    : dfrp->dfr_cmd_arg;
+	}
+
+	if (V_option) {
+		for (i = 0; i < argv_index-1; i++)
+			(void) printf("%s ", argv[i]);
+		(void) printf("%s\n", argv[i]);
+		return (0);
+	}
+
+	pid = fork();
+
+	if (pid == -1) {
+		errmsg(ERR_PERROR, "cannot fork process:");
+		return (1);
+	} else if (pid == 0) {
+		(void) execv(cmd_path, argv);
+		if (errno == ENOENT)
+			errmsg(ERR_NOFLAGS,
+			    "operation not applicable for FSType %s",
+			    fstype);
+		else
+			errmsg(ERR_PERROR, "cannot execute %s:", cmd_path);
+		exit(2);
+	}
+
+	/*
+	 * Reap the child
+	 */
+	for (;;) {
+		pid_t wpid = waitpid(pid, &status, 0);
+
+		if (wpid == -1)
+			if (errno == EINTR)
 				continue;
+			else {
+				errmsg(ERR_PERROR, "waitpid error:");
+				return (1);
 			}
-		}
+		else
+			break;
+	}
+
+	return ((WIFEXITED(status) && WEXITSTATUS(status) == 0) ? 0 : 1);
+}
+
 
-		device = mount_entry->mnt_fsname;
-		mount_point = mount_entry->mnt_dir;
 
-		if (statfs(mount_point, &s) != 0) {
-			bb_perror_msg("%s", mount_point);
-			goto SET_ERROR;
+/*
+ * Remove from the request list all requests that do not apply.
+ * Notice that the subsequent processing of the requests depends on
+ * the sanity checking performed by this function.
+ */
+static int
+prune_list(struct df_request request_list[],
+		size_t n_requests,
+		size_t *valid_requests)
+{
+	size_t	i;
+	size_t	n_valid = 0;
+	int	errors = 0;
+
+	for (i = 0; i < n_requests; i++) {
+		struct df_request *dfrp = &request_list[i];
+
+		/*
+		 * Skip file systems that are not mounted if either the
+		 * -l or -n options were specified. If none of these options
+		 * are present, the appropriate FS-specific df will be invoked.
+		 */
+		if (! DFR_ISMOUNTEDFS(dfrp)) {
+			if (n_option) {
+				errmsg(ERR_NOFLAGS,
+				    "%s option incompatible with unmounted "
+				    "special device (%s)",
+				     "-n", dfrp->dfr_cmd_arg);
+				dfrp->dfr_valid = FALSE;
+				errors++;
+			}
+			else
+				n_valid++;
+			continue;
 		}
 
-		if ((s.f_blocks > 0) || !mount_table){
-			blocks_used = s.f_blocks - s.f_bfree;
-			blocks_percent_used = 0;
-			if (blocks_used + s.f_bavail) {
-				blocks_percent_used = (((long long) blocks_used) * 100
-									   + (blocks_used + s.f_bavail)/2
-									   ) / (blocks_used + s.f_bavail);
+		/*
+		 * Check for inconsistency between the argument of -F and
+		 * the actual file system type.
+		 * If there is an inconsistency and the user specified a
+		 * path, this is an error since we are asked to interpret
+		 * the path using the wrong file system type. If there is
+		 * no path associated with this request, we quietly ignore it.
+		 */
+		if (F_option && ! EQ(dfrp->dfr_fstype, FSType)) {
+			dfrp->dfr_valid = FALSE;
+			if (dfrp->dfr_cmd_arg != NULL) {
+				errmsg(ERR_NOFLAGS,
+				"Warning: %s mounted as a %s file system",
+				    dfrp->dfr_cmd_arg, dfrp->dfr_fstype);
+				errors++;
 			}
+			continue;
+		}
+
+		/*
+		 * Skip file systems mounted as "ignore" unless the -a option
+		 * is present, or the user explicitly specified them on
+		 * the command line.
+		 */
+		if (dfrp->dfr_mte->mte_ignore &&
+		    ! (a_option || dfrp->dfr_cmd_arg)) {
+			dfrp->dfr_valid = FALSE;
+			continue;
+		}
+
+		n_valid++;
+	}
+	*valid_requests = n_valid;
+	return (errors);
+}
+
+
+/*
+ * Print the appropriate header for the requested output format.
+ * Options are checked in order of their precedence.
+ */
+static void
+print_header(void)
+{
+	if (use_scaling) { /* this comes from the -h option */
+		int arg = 'h';
+
+		(void) printf("%-*s %*s %*s %*s %-*s %s\n",
+		    FILESYSTEM_WIDTH, TRANSLATE("Filesystem"),
+		    SCALED_WIDTH, TRANSLATE("size"),
+		    SCALED_WIDTH, TRANSLATE("used"),
+		    AVAILABLE_WIDTH, TRANSLATE("avail"),
+		    CAPACITY_WIDTH, TRANSLATE("capacity"),
+		    TRANSLATE("Mounted on"));
+		SET_OPTION(h);
+		return;
+	}
+	if (k_option) {
+		int arg = 'h';
+
+		(void) printf("%-*s %*s %*s %*s %-*s %s\n",
+		    FILESYSTEM_WIDTH, TRANSLATE("Filesystem"),
+		    KBYTE_WIDTH, TRANSLATE("kbytes"),
+		    KBYTE_WIDTH, TRANSLATE("used"),
+		    KBYTE_WIDTH, TRANSLATE("avail"),
+		    CAPACITY_WIDTH, TRANSLATE("capacity"),
+		    TRANSLATE("Mounted on"));
+		SET_OPTION(h);
+		return;
+	}
+	/* Added for XCU4 compliance */
+	if (P_option) {
+		int arg = 'h';
+
+		(void) printf("%-*s %*s %*s %*s %-*s %s\n",
+		    FILESYSTEM_WIDTH, TRANSLATE("Filesystem"),
+		    KBYTE_WIDTH, TRANSLATE("512-blocks"),
+		    KBYTE_WIDTH, TRANSLATE("Used"),
+		    KBYTE_WIDTH, TRANSLATE("Available"),
+		    CAPACITY_WIDTH, TRANSLATE("Capacity"),
+		    TRANSLATE("Mounted on"));
+
+		SET_OPTION(h);
+		return;
+	}
+	/* End XCU4 */
+	if (v_option) {
+		(void) printf("%-*s %-*s %*s %*s %*s %-*s\n",
+		    IBCS2_MOUNT_POINT_WIDTH, TRANSLATE("Mount Dir"),
+		    IBCS2_FILESYSTEM_WIDTH, TRANSLATE("Filesystem"),
+		    BLOCK_WIDTH, TRANSLATE("blocks"),
+		    BLOCK_WIDTH, TRANSLATE("used"),
+		    BLOCK_WIDTH, TRANSLATE("free"),
+		    CAPACITY_WIDTH, TRANSLATE(" %used"));
+		return;
+	}
+	
+}
+
+
+/*
+ * Convert an unsigned long long to a string representation and place the
+ * result in the caller-supplied buffer.
+ * The given number is in units of "unit_from" size, but the
+ * converted number will be in units of "unit_to" size. The unit sizes
+ * must be powers of 2.
+ * The value "(unsigned long long)-1" is a special case and is always
+ * converted to "-1".
+ * Returns a pointer to the caller-supplied buffer.
+ */
+static char *
+number_to_string(
+			char *buf,		/* put the result here */
+			unsigned long long number, /* convert this number */
+			int unit_from,		/* from units of this size */
+			int unit_to)		/* to units of this size */
+{
+	if ((long long)number == (long long)-1)
+		(void) strcpy(buf, "-1");
+	else {
+		if (unit_from == unit_to)
+			(void) sprintf(buf, "%llu", number);
+		else if (unit_from < unit_to)
+			(void) sprintf(buf, "%llu",
+			    number / (unsigned long long)(unit_to / unit_from));
+		else
+			(void) sprintf(buf, "%llu",
+			    number * (unsigned long long)(unit_from / unit_to));
+	}
+	return (buf);
+}
+
+/*
+ * Convert an unsigned long long to a string representation and place the
+ * result in the caller-supplied buffer.
+ * The given number is in units of "unit_from" size,
+ * this will first be converted to a number in 1024 or 1000 byte size,
+ * depending on the scaling factor.
+ * Then the number is scaled down until it is small enough to be in a good
+ * human readable format i.e. in the range 0 thru scale-1.
+ * If it's smaller than 10 there's room enough to provide one decimal place.
+ * The value "(unsigned long long)-1" is a special case and is always
+ * converted to "-1".
+ * Returns a pointer to the caller-supplied buffer.
+ */
+static char *
+number_to_scaled_string(
+			numbuf_t buf,		/* put the result here */
+			unsigned long long number, /* convert this number */
+			int unit_from,
+			int scale)
+{
+	unsigned long long save = 0;
+	char *M = "KMGTPE"; /* Measurement: kilo, mega, giga, tera, peta, exa */
+	char *uom = M;    /* unit of measurement, initially 'K' (=M[0]) */
+
+	if ((long long)number == (long long)-1) {
+		(void) strcpy(buf, "-1");
+		return (buf);
+	}
+
+	/*
+	 * Convert number from unit_from to given scale (1024 or 1000).
+	 * This means multiply number by unit_from and divide by scale.
+	 *
+	 * Would like to multiply by unit_from and then divide by scale,
+	 * but if the first multiplication would overflow, then need to
+	 * divide by scale and then multiply by unit_from.
+	 */
+	if (number > (UINT64_MAX / (unsigned long long)unit_from)) {
+		number = (number / (unsigned long long)scale) *
+		    (unsigned long long)unit_from;
+	} else {
+		number = (number * (unsigned long long)unit_from) /
+		    (unsigned long long)scale;
+	}
+
+	/*
+	 * Now we have number as a count of scale units.
+	 * Stop scaling when we reached exa bytes, then something is
+	 * probably wrong with our number.
+	 */
+
+	while ((number >= scale) && (*uom != 'E')) {
+		uom++; /* next unit of measurement */
+		save = number;
+		number = (number + (scale / 2)) / scale;
+	}
+	/* check if we should output a decimal place after the point */
+	if (save && ((save / scale) < 10)) {
+		/* sprintf() will round for us */
+		float fnum = (float)save / scale;
+		(void) sprintf(buf, "%2.1f%c", fnum, *uom);
+	} else {
+		(void) sprintf(buf, "%4llu%c", number, *uom);
+	}
+	return (buf);
+}
+
+/*
+ * The statvfs() implementation allows us to return only two values, the total
+ * number of blocks and the number of blocks free.  The equation 'used = total -
+ * free' will not work for ZFS filesystems, due to the nature of pooled storage.
+ * We choose to return values in the statvfs structure that will produce correct
+ * results for 'used' and 'available', but not 'total'.  This function will open
+ * the underlying ZFS dataset if necessary and get the real value.
+ */
+static void
+adjust_total_blocks(struct df_request *dfrp, fsblkcnt64_t *total,
+    uint64_t blocksize)
+{
+	char *dataset, *slash;
+	boolean_t first = TRUE;
+	uint64_t quota = 0;
+
+	if (strcmp(DFR_FSTYPE(dfrp), MNTTYPE_ZFS) != 0 || !load_libzfs())
+		return;
+
+	/*
+	 * We want to get the total size for this filesystem as bounded by any
+	 * quotas. In order to do this, we start at the current filesystem and
+	 * work upwards looking for the smallest quota.  When we reach the
+	 * pool itself, the quota is the amount used plus the amount
+	 * available.
+	 */
+	if ((dataset = strdup(DFR_SPECIAL(dfrp))) == NULL)
+		return;
+
+	slash = dataset + strlen(dataset);
+	while (slash != NULL) {
+		zfs_handle_t *zhp;
+		uint64_t this_quota;
+
+		*slash = '\0';
+
+		zhp = _zfs_open(g_zfs, dataset, ZFS_TYPE_DATASET);
+		if (zhp == NULL)
+			break;
+
+		/* true at first iteration of loop */
+		if (first) {
+			quota = _zfs_prop_get_int(zhp, ZFS_PROP_REFQUOTA);
+			if (quota == 0)
+				quota = UINT64_MAX;
+			first = FALSE;
+		}
+
+		this_quota = _zfs_prop_get_int(zhp, ZFS_PROP_QUOTA);
+		if (this_quota && this_quota < quota)
+			quota = this_quota;
+
+		/* true at last iteration of loop */
+		if ((slash = strrchr(dataset, '/')) == NULL) {
+			uint64_t size;
+
+			size = _zfs_prop_get_int(zhp, ZFS_PROP_USED) +
+			    _zfs_prop_get_int(zhp, ZFS_PROP_AVAILABLE);
+			if (size < quota)
+				quota = size;
+		}
+
+		_zfs_close(zhp);
+	}
+
+	*total = quota / blocksize;
+	free(dataset);
+}
+
+static void
+k_output(struct df_request *dfrp, struct statvfs64 *fsp)
+{
+	fsblkcnt64_t total_blocks		= fsp->f_blocks;
+	fsblkcnt64_t	free_blocks		= fsp->f_bfree;
+	fsblkcnt64_t	available_blocks	= fsp->f_bavail;
+	fsblkcnt64_t	used_blocks;
+	char 		*file_system		= DFR_SPECIAL(dfrp);
+	numbuf_t	total_blocks_buf;
+	numbuf_t	used_blocks_buf;
+	numbuf_t	available_blocks_buf;
+	char 		capacity_buf[LINEBUF_SIZE];
+
+	/*
+	 * If the free block count is -1, don't trust anything but the total
+	 * number of blocks.
+	 */
+	if (free_blocks == (fsblkcnt64_t)-1) {
+		used_blocks = (fsblkcnt64_t)-1;
+		(void) strcpy(capacity_buf, "  100%");
+	} else {
+		fsblkcnt64_t reserved_blocks = free_blocks - available_blocks;
+
+		used_blocks	= total_blocks - free_blocks;
+
+		/*
+		 * The capacity estimation is bogus when available_blocks is 0
+		 * and the super-user has allocated more space. The reason
+		 * is that reserved_blocks is inaccurate in that case, because
+		 * when the super-user allocates space, free_blocks is updated
+		 * but available_blocks is not (since it can't drop below 0).
+		 *
+		 * XCU4 and POSIX.2 require that any fractional result of the
+		 * capacity estimation be rounded to the next highest integer,
+		 * hence the addition of 0.5.
+		 */
+		(void) sprintf(capacity_buf, "%5.0f%%",
+		    (total_blocks == 0) ? 0.0 :
+		    ((double)used_blocks /
+		    (double)(total_blocks - reserved_blocks))
+		    * 100.0 + 0.5);
+	}
+
+	/*
+	 * The available_blocks can be less than 0 on a 4.x file system.
+	 * Reset it to 0 in order to avoid printing negative numbers.
+	 */
+	if ((long long)available_blocks < (long long)0)
+		available_blocks = (fsblkcnt64_t)0;
+	/*
+	 * Print long special device names (usually NFS mounts) in a line
+	 * by themselves when the output is directed to a terminal.
+	 */
+	if (tty_output && strlen(file_system) > (size_t)FILESYSTEM_WIDTH) {
+		(void) printf("%s\n", file_system);
+		file_system = "";
+	}
+
+	adjust_total_blocks(dfrp, &total_blocks, fsp->f_frsize);
+
+	if (use_scaling) { /* comes from the -h option */
+	(void) printf("%-*s %*s %*s %*s %-*s %-s\n",
+	    FILESYSTEM_WIDTH, file_system,
+	    SCALED_WIDTH, number_to_scaled_string(total_blocks_buf,
+	    total_blocks, fsp->f_frsize, scale),
+	    SCALED_WIDTH, number_to_scaled_string(used_blocks_buf,
+	    used_blocks, fsp->f_frsize, scale),
+	    AVAILABLE_WIDTH, number_to_scaled_string(available_blocks_buf,
+	    available_blocks, fsp->f_frsize, scale),
+	    CAPACITY_WIDTH, capacity_buf,
+	    DFR_MOUNT_POINT(dfrp));
+		return;
+	}
+
+	if (v_option) {
+	(void) printf("%-*.*s %-*.*s %*lld %*lld %*lld %-.*s\n",
+	    IBCS2_MOUNT_POINT_WIDTH, IBCS2_MOUNT_POINT_WIDTH,
+	    DFR_MOUNT_POINT(dfrp),
+	    IBCS2_FILESYSTEM_WIDTH, IBCS2_FILESYSTEM_WIDTH, file_system,
+	    BLOCK_WIDTH, total_blocks,
+	    BLOCK_WIDTH, used_blocks,
+	    BLOCK_WIDTH, available_blocks,
+	    CAPACITY_WIDTH,	capacity_buf);
+		return;
+	}
+
+	if (P_option && !k_option) {
+	(void) printf("%-*s %*s %*s %*s %-*s %-s\n",
+	    FILESYSTEM_WIDTH, file_system,
+	    KBYTE_WIDTH, number_to_string(total_blocks_buf,
+	    total_blocks, fsp->f_frsize, 512),
+	    KBYTE_WIDTH, number_to_string(used_blocks_buf,
+	    used_blocks, fsp->f_frsize, 512),
+	    KBYTE_WIDTH, number_to_string(available_blocks_buf,
+	    available_blocks, fsp->f_frsize, 512),
+	    CAPACITY_WIDTH, capacity_buf,
+	    DFR_MOUNT_POINT(dfrp));
+	} else {
+	(void) printf("%-*s %*s %*s %*s %-*s %-s\n",
+	    FILESYSTEM_WIDTH, file_system,
+	    KBYTE_WIDTH, number_to_string(total_blocks_buf,
+	    total_blocks, fsp->f_frsize, 1024),
+	    KBYTE_WIDTH, number_to_string(used_blocks_buf,
+	    used_blocks, fsp->f_frsize, 1024),
+	    KBYTE_WIDTH, number_to_string(available_blocks_buf,
+	    available_blocks, fsp->f_frsize, 1024),
+	    CAPACITY_WIDTH,	capacity_buf,
+	    DFR_MOUNT_POINT(dfrp));
+	}
+}
+
+/*
+ * The following is for internationalization support.
+ */
+static bool_int strings_initialized;
+static char 	*files_str;
+static char	*blocks_str;
+static char	*total_str;
+static char	*kilobytes_str;
+
+static void
+strings_init(void)
+{
+	total_str = TRANSLATE("total");
+#ifdef	_iBCS2
+	/* ISC/SCO print i-nodes instead of files */
+	if (sysv3_set)
+		files_str = TRANSLATE("i-nodes");
+	else
+#endif	/* _iBCS2 */
+		files_str = TRANSLATE("files");
+	blocks_str = TRANSLATE("blocks");
+	kilobytes_str = TRANSLATE("kilobytes");
+	strings_initialized = TRUE;
+}
+
+#define	STRINGS_INIT()		if (!strings_initialized) strings_init()
+
+
+/* ARGSUSED */
+static void
+n_output(struct df_request *dfrp, struct statvfs64 *fsp)
+{
+	(void) printf("%-*s: %-*s\n",
+	    MOUNT_POINT_WIDTH, DFR_MOUNT_POINT(dfrp),
+	    FSTYPE_WIDTH, dfrp->dfr_fstype);
+}
+
+
+static void
+default_output(struct df_request *dfrp, struct statvfs64 *fsp)
+{
+	numbuf_t free_blocks_buf;
+	numbuf_t free_files_buf;
 
-			if (strcmp(device, "rootfs") == 0) {
+	STRINGS_INIT();
+
+	(void) printf("%-*s(%-*s):%*s %s %*s %s\n",
+	    MOUNT_POINT_WIDTH, DFR_MOUNT_POINT(dfrp),
+	    SPECIAL_DEVICE_WIDTH, DFR_SPECIAL(dfrp),
+	    BLOCK_WIDTH, number_to_string(free_blocks_buf,
+	    fsp->f_bfree, fsp->f_frsize, 512),
+	    blocks_str,
+	    NFILES_WIDTH, number_to_string(free_files_buf,
+	    fsp->f_ffree, 1, 1),
+	    files_str);
+}
+
+
+/* ARGSUSED */
+static void
+V_output(struct df_request *dfrp, struct statvfs64 *fsp)
+{
+	char temp_buf[LINEBUF_SIZE];
+
+	if (df_options_len > 1)
+		(void) strcat(strcpy(temp_buf, df_options), " ");
+	else
+		temp_buf[0] = NUL;
+
+	(void) printf("%s -F %s %s%s\n",
+	    program_name, dfrp->dfr_fstype, temp_buf,
+	    dfrp->dfr_cmd_arg ? dfrp->dfr_cmd_arg: DFR_SPECIAL(dfrp));
+}
+
+
+/*
+ * This function is used to sort the array of df_requests according to fstype
+ */
+static int
+df_reqcomp(const void *p1, const void *p2)
+{
+	int v = strcmp(DFRP(p1)->dfr_fstype, DFRP(p2)->dfr_fstype);
+
+	if (v != 0)
+		return (v);
+	else
+		return (DFRP(p1)->dfr_index - DFRP(p2)->dfr_index);
+}
+
+
+static void
+vfs_error(char *file, int status)
+{
+	if (status == VFS_TOOLONG)
+		errmsg(ERR_NOFLAGS, "a line in %s exceeds %d characters",
+		    file, MNT_LINE_MAX);
+	else if (status == VFS_TOOMANY)
+		errmsg(ERR_NOFLAGS, "a line in %s has too many fields", file);
+	else if (status == VFS_TOOFEW)
+		errmsg(ERR_NOFLAGS, "a line in %s has too few fields", file);
+	else
+		errmsg(ERR_NOFLAGS, "error while reading %s: %d", file, status);
+}
+
+
+/*
+ * Try to determine the fstype for the specified block device.
+ * Return in order of decreasing preference:
+ *	file system type from vfstab
+ *	file system type as specified by -F option
+ *	default file system type
+ */
+static char *
+find_fstype(char *special)
+{
+	struct vfstab	vtab;
+	FILE		*fp;
+	int		status;
+	char		*vfstab_file = VFS_TAB;
+
+	fp = xfopen(vfstab_file);
+	status = getvfsspec(fp, &vtab, special);
+	(void) fclose(fp);
+	if (status > 0)
+		vfs_error(vfstab_file, status);
+
+	if (status == 0) {
+		if (F_option && ! EQ(FSType, vtab.vfs_fstype))
+			errmsg(ERR_NOFLAGS,
+			"warning: %s is of type %s", special, vtab.vfs_fstype);
+		return (new_string(vtab.vfs_fstype));
+	}
+	else
+		return (F_option ? FSType : default_fstype(special));
+}
+
+/*
+ * When this function returns, the following fields are filled for all
+ * valid entries in the requests[] array:
+ *		dfr_mte		(if the file system is mounted)
+ *		dfr_fstype
+ *		dfr_index
+ *
+ * The function returns the number of errors that occurred while building
+ * the request list.
+ */
+static int
+create_request_list(
+			int argc,
+			char *argv[],
+			struct df_request *requests_p[],
+			size_t *request_count)
+{
+	struct df_request	*requests;
+	struct df_request	*dfrp;
+	size_t			size;
+	size_t 			i;
+	size_t 			request_index = 0;
+	size_t			max_requests;
+	int			errors = 0;
+
+	/*
+	 * If no args, use the mounted file systems, otherwise use the
+	 * user-specified arguments.
+	 */
+	if (argc == 0) {
+		mtab_read_file();
+		max_requests = mount_table_entries;
+	} else
+		max_requests = argc;
+
+	size = max_requests * sizeof (struct df_request);
+	requests = xmalloc(size);
+	(void) memset(requests, 0, size);
+
+	if (argc == 0) {
+		/*
+		 * If -Z wasn't specified, we skip mounts in other
+		 * zones.  This obviously is a noop in a non-global
+		 * zone.
+		 */
+		boolean_t showall = (getzoneid() != GLOBAL_ZONEID) || Z_option;
+		struct zone_summary *zsp;
+
+		if (!showall) {
+			zsp = fs_get_zone_summaries();
+			if (zsp == NULL)
+				errmsg(ERR_FATAL,
+				    "unable to retrieve list of zones");
+		}
+	
+		for (i = 0; i < mount_table_entries; i++) {
+			struct extmnttab *mtp = mount_table[i].mte_mount;
+
+			if (EQ(mtp->mnt_fstype, MNTTYPE_SWAP))
 				continue;
-			} else if (strcmp(device, "/dev/root") == 0) {
-				/* Adjusts device to be the real root device,
-				* or leaves device alone if it can't find it */
-				if ((device = find_block_device("/")) == NULL) {
-					goto SET_ERROR;
+
+			if (!showall) {
+				if (fs_mount_in_other_zone(zsp,
+				    mtp->mnt_mountp))
+					continue;
+			}
+	
+			dfrp = &requests[request_index++];
+			dfrp->dfr_mte		= &mount_table[i];
+			dfrp->dfr_fstype	= mtp->mnt_fstype;
+			dfrp->dfr_index		= i;
+			dfrp->dfr_valid		= TRUE;
+		}
+	} else {
+		struct stat64 *arg_stat; /* array of stat structures	*/
+		bool_int *valid_stat;	/* which structures are valid	*/
+
+		arg_stat = xmalloc(argc * sizeof (struct stat64));
+		valid_stat = xmalloc(argc * sizeof (bool_int));
+
+		/*
+		 * Obtain stat64 information for each argument before
+		 * constructing the list of mounted file systems. By
+		 * touching all these places we force the automounter
+		 * to establish any mounts required to access the arguments,
+		 * so that the corresponding mount table entries will exist
+		 * when we look for them.
+		 * It is still possible that the automounter may timeout
+		 * mounts between the time we read the mount table and the
+		 * time we process the request. Even in that case, when
+		 * we issue the statvfs64(2) for the mount point, the file
+		 * system will be mounted again. The only problem will
+		 * occur if the automounter maps change in the meantime
+		 * and the mount point is eliminated.
+		 */
+		for (i = 0; i < argc; i++)
+			valid_stat[i] = (stat64(argv[i], &arg_stat[i]) == 0);
+
+		mtab_read_file();
+
+		for (i = 0; i < argc; i++) {
+			char *arg = argv[i];
+
+			dfrp = &requests[request_index];
+
+			dfrp->dfr_index = request_index;
+			dfrp->dfr_cmd_arg = arg;
+
+			if (valid_stat[i]) {
+				if (S_ISBLK(arg_stat[i].st_mode)) {
+					bdev_mount_entry(dfrp);
+					dfrp->dfr_valid = TRUE;
+				} else if (S_ISDIR(arg_stat[i].st_mode) ||
+				    S_ISREG(arg_stat[i].st_mode) ||
+				    S_ISFIFO(arg_stat[i].st_mode)) {
+					path_mount_entry(dfrp,
+					    arg_stat[i].st_dev);
+					if (! DFR_ISMOUNTEDFS(dfrp)) {
+						errors++;
+						continue;
+					}
+					dfrp->dfr_valid = TRUE;
 				}
+			} else {
+				resource_mount_entry(dfrp);
+				dfrp->dfr_valid = DFR_ISMOUNTEDFS(dfrp);
 			}
 
-#ifdef CONFIG_FEATURE_HUMAN_READABLE
-			bb_printf("%-20s %9s ", device,
-					  make_human_readable_str(s.f_blocks, s.f_bsize, df_disp_hr));
-
-			bb_printf("%9s ",
-					  make_human_readable_str( (s.f_blocks - s.f_bfree),
-											  s.f_bsize, df_disp_hr));
-
-			bb_printf("%9s %3ld%% %s\n",
-					  make_human_readable_str(s.f_bavail, s.f_bsize, df_disp_hr),
-					  blocks_percent_used, mount_point);
-#else
-			bb_printf("%-20s %9ld %9ld %9ld %3ld%% %s\n",
-					  device,
-					  kscale(s.f_blocks, s.f_bsize),
-					  kscale(s.f_blocks-s.f_bfree, s.f_bsize),
-					  kscale(s.f_bavail, s.f_bsize),
-					  blocks_percent_used, mount_point);
-#endif
+			/*
+			 * If we haven't managed to verify that the request
+			 * is valid, we must have gotten a bad argument.
+			 */
+			if (!dfrp->dfr_valid) {
+				errmsg(ERR_NOFLAGS,
+				    "(%-10s) not a block device, directory or "
+				    "mounted resource", arg);
+				errors++;
+				continue;
+			}
+
+			/*
+			 * Determine the file system type.
+			 */
+			if (DFR_ISMOUNTEDFS(dfrp))
+				dfrp->dfr_fstype =
+				    dfrp->dfr_mte->mte_mount->mnt_fstype;
+			else
+				dfrp->dfr_fstype =
+				    find_fstype(dfrp->dfr_cmd_arg);
+
+			request_index++;
 		}
+	}
+	*requests_p = requests;
+	*request_count = request_index;
+	return (errors);
+}
+
+
+/*
+ * Select the appropriate function and flags to use for output.
+ * Notice that using both -e and -b options produces a different form of
+ * output than either of those two options alone; this is the behavior of
+ * the SVR4 df.
+ */
+static struct df_output *
+select_output(void)
+{
+	static struct df_output dfo;
+
+	/*
+	 * The order of checking options follows the option precedence
+	 * rules as they are listed in the man page.
+	 */
+	if (use_scaling) { /* comes from the -h option */
+		dfo.dfo_func = k_output;
+		dfo.dfo_flags = DFO_HEADER + DFO_STATVFS;
+	} else if (V_option) {
+		dfo.dfo_func = V_output;
+		dfo.dfo_flags = DFO_NOFLAGS;
+	} else if (k_option || P_option || v_option) {
+		dfo.dfo_func = k_output;
+		dfo.dfo_flags = DFO_HEADER + DFO_STATVFS;
+	} else if (n_option) {
+		dfo.dfo_func = n_output;
+		dfo.dfo_flags = DFO_NOFLAGS;
+	} else {
+		dfo.dfo_func = default_output;
+		dfo.dfo_flags = DFO_STATVFS;
+	}
+	return (&dfo);
+}
+
+
+/*
+ * The (argc,argv) pair contains all the non-option arguments
+ */
+static void
+do_df(int argc, char *argv[])
+{
+	size_t			i;
+	struct df_request	*requests;		/* array of requests */
+	size_t			n_requests;
+	struct df_request	*dfrp;
+	int			errors;
+
+	errors = create_request_list(argc, argv, &requests, &n_requests);
+
+	if (n_requests == 0)
+		exit(errors);
+
+	/*
+	 * If we are going to run the FSType-specific df command,
+	 * rearrange the requests so that we can issue a single command
+	 * per file system type.
+	 */
+	if (o_option) {
+		size_t j;
+
+		/*
+		 * qsort is not a stable sorting method (i.e. requests of
+		 * the same file system type may be swapped, and hence appear
+		 * in the output in a different order from the one in which
+		 * they were listed in the command line). In order to force
+		 * stability, we use the dfr_index field which is unique
+		 * for each request.
+		 */
+		qsort(requests,
+		    n_requests, sizeof (struct df_request), df_reqcomp);
+		for (i = 0; i < n_requests; i = j) {
+			char *fstype = requests[i].dfr_fstype;
+
+			for (j = i+1; j < n_requests; j++)
+				if (! EQ(fstype, requests[j].dfr_fstype))
+					break;
+
+			/*
+			 * At this point, requests in the range [i,j) are
+			 * of the same type.
+			 *
+			 * If the -F option was used, and the user specified
+			 * arguments, the filesystem types must match
+			 *
+			 * XXX: the alternative of doing this check here is to
+			 * 	invoke prune_list, but then we have to
+			 *	modify this code to ignore invalid requests.
+			 */
+			if (F_option && ! EQ(fstype, FSType)) {
+				size_t k;
+
+				for (k = i; k < j; k++) {
+					dfrp = &requests[k];
+					if (dfrp->dfr_cmd_arg != NULL) {
+						errmsg(ERR_NOFLAGS,
+						    "Warning: %s mounted as a "
+						    "%s file system",
+						    dfrp->dfr_cmd_arg,
+						    dfrp->dfr_fstype);
+						errors++;
+					}
+				}
+			} else
+				errors += run_fs_specific_df(&requests[i], j-i);
+		}
+	} else {
+		size_t valid_requests;
+
+		/*
+		 * We have to prune the request list to avoid printing a header
+		 * if there are no valid requests
+		 */
+		errors += prune_list(requests, n_requests, &valid_requests);
+
+		if (valid_requests) {
+			struct df_output *dfop = select_output();
 
-	} while (1);
+			/* indicates if we already printed out a header line */
+			int printed_header = 0;
 
-	bb_fflush_stdout_and_exit(status);
+			for (i = 0; i < n_requests; i++) {
+				dfrp = &requests[i];
+				if (! dfrp->dfr_valid)
+					continue;
+
+				/*
+				 * If we don't have a mount point,
+				 * this must be a block device.
+				 */
+				if (DFR_ISMOUNTEDFS(dfrp)) {
+					struct statvfs64 stvfs;
+
+					if ((dfop->dfo_flags & DFO_STATVFS) &&
+					    statvfs64(DFR_MOUNT_POINT(dfrp),
+					    &stvfs) == -1) {
+						errmsg(ERR_PERROR,
+						    "cannot statvfs %s:",
+						    DFR_MOUNT_POINT(dfrp));
+						errors++;
+						continue;
+					}
+					if ((!printed_header) &&
+					    (dfop->dfo_flags & DFO_HEADER)) {
+						print_header();
+						printed_header = 1;
+					}
+
+					(*dfop->dfo_func)(dfrp, &stvfs);
+				} else {
+					/*
+					 *  -h option only works for
+					 *  mounted filesystems
+					 */
+					if (use_scaling) {
+						errmsg(ERR_NOFLAGS,
+		"-h option incompatible with unmounted special device (%s)",
+						    dfrp->dfr_cmd_arg);
+						errors++;
+						continue;
+					}
+					errors += run_fs_specific_df(dfrp, 1);
+				}
+			}
+		}
+	}
+	exit(errors);
+}
+
+
+/*
+ * The rest of this file implements the devnm command
+ */
+
+static char *
+find_dev_name(char *file, dev_t dev)
+{
+	struct df_request dfreq;
+
+	dfreq.dfr_cmd_arg = file;
+	dfreq.dfr_fstype = 0;
+	dfreq.dfr_mte = NULL;
+	path_mount_entry(&dfreq, dev);
+	return (DFR_ISMOUNTEDFS(&dfreq) ? DFR_SPECIAL(&dfreq) : NULL);
+}
+
+
+static void
+do_devnm(int argc, char *argv[])
+{
+	int arg;
+	int errors = 0;
+	char *dev_name;
+
+	if (argc == 1)
+		errmsg(ERR_NONAME, "Usage: %s name ...", DEVNM_CMD);
+
+	mtab_read_file();
+
+	for (arg = 1; arg < argc; arg++) {
+		char *file = argv[arg];
+		struct stat64 st;
+
+		if (stat64(file, &st) == -1) {
+			errmsg(ERR_PERROR, "%s: ", file);
+			errors++;
+			continue;
+		}
+
+		if (! is_remote_fs(st.st_fstype) &&
+		    ! EQ(st.st_fstype, MNTTYPE_TMPFS) &&
+		    (dev_name = find_dev_name(file, st.st_dev)))
+			(void) printf("%s %s\n", dev_name, file);
+		else
+			errmsg(ERR_NOFLAGS,
+			    "%s not found", file);
+	}
+	exit(errors);
+	/* NOTREACHED */
 }
diff -rupN busybox-1.2.0/coreutils/fslib.c busybox-1.2.0solaris/coreutils/fslib.c
--- busybox-1.2.0/coreutils/fslib.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/coreutils/fslib.c	2009-04-20 12:01:39.469899112 +0400
@@ -0,0 +1,557 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+#include	<stdio.h>
+#include	<stdarg.h>
+#include	<stdlib.h>
+#include	<unistd.h>
+#include	<libintl.h>
+#include	<string.h>
+#include	<fcntl.h>
+#include	<errno.h>
+#include	<syslog.h>
+#include	<alloca.h>
+#include	<sys/vfstab.h>
+#include	<sys/mnttab.h>
+#include	<sys/mntent.h>
+#include	<sys/mount.h>
+#include	<sys/filio.h>
+#include	<sys/fs/ufs_filio.h>
+#include	<sys/stat.h>
+#include	<sys/param.h>
+#include	<zone.h>
+#include	<signal.h>
+#include	<strings.h>
+#include	"fslib.h"
+
+/* LINTLIBRARY */
+
+#define	BUFLEN		256
+
+#define	TIME_MAX 16
+
+/*
+ * Reads all of the entries from the in-kernel mnttab, and returns the
+ * linked list of the entries.
+ */
+mntlist_t *
+fsgetmntlist(void)
+{
+	FILE *mfp;
+	mntlist_t *mntl;
+	char buf[BUFLEN];
+
+	if ((mfp = fopen(MNTTAB, "r")) == NULL) {
+		(void) snprintf(buf, BUFLEN, "fsgetmntlist: fopen %s", MNTTAB);
+		perror(buf);
+		return (NULL);
+	}
+
+	mntl = fsmkmntlist(mfp);
+
+	(void) fclose(mfp);
+	return (mntl);
+}
+
+
+static struct extmnttab zmnttab = { 0 };
+
+struct extmnttab *
+fsdupmnttab(struct extmnttab *mnt)
+{
+	struct extmnttab *new;
+
+	new = (struct extmnttab *)malloc(sizeof (*new));
+	if (new == NULL)
+		goto alloc_failed;
+
+	*new = zmnttab;
+	/*
+	 * Allocate an extra byte for the mountpoint
+	 * name in case a space needs to be added.
+	 */
+	new->mnt_mountp = (char *)malloc(strlen(mnt->mnt_mountp) + 2);
+	if (new->mnt_mountp == NULL)
+		goto alloc_failed;
+	(void) strcpy(new->mnt_mountp, mnt->mnt_mountp);
+
+	if ((new->mnt_special = strdup(mnt->mnt_special)) == NULL)
+		goto alloc_failed;
+
+	if ((new->mnt_fstype = strdup(mnt->mnt_fstype)) == NULL)
+		goto alloc_failed;
+
+	if (mnt->mnt_mntopts != NULL)
+		if ((new->mnt_mntopts = strdup(mnt->mnt_mntopts)) == NULL)
+			goto alloc_failed;
+
+	if (mnt->mnt_time != NULL)
+		if ((new->mnt_time = strdup(mnt->mnt_time)) == NULL)
+			goto alloc_failed;
+
+	new->mnt_major = mnt->mnt_major;
+	new->mnt_minor = mnt->mnt_minor;
+	return (new);
+
+alloc_failed:
+	(void) fprintf(stderr, "fsdupmnttab: Out of memory\n");
+	fsfreemnttab(new);
+	return (NULL);
+}
+
+/*
+ * Free a single mnttab structure
+ */
+void
+fsfreemnttab(struct extmnttab *mnt)
+{
+
+	if (mnt) {
+		if (mnt->mnt_special)
+			free(mnt->mnt_special);
+		if (mnt->mnt_mountp)
+			free(mnt->mnt_mountp);
+		if (mnt->mnt_fstype)
+			free(mnt->mnt_fstype);
+		if (mnt->mnt_mntopts)
+			free(mnt->mnt_mntopts);
+		if (mnt->mnt_time)
+			free(mnt->mnt_time);
+		free(mnt);
+	}
+}
+
+void
+fsfreemntlist(mntlist_t *mntl)
+{
+	mntlist_t *mntl_tmp;
+
+	while (mntl) {
+		fsfreemnttab(mntl->mntl_mnt);
+		mntl_tmp = mntl;
+		mntl = mntl->mntl_next;
+		free(mntl_tmp);
+	}
+}
+
+/*
+ * Read the mnttab file and return it as a list of mnttab structs.
+ * Returns NULL if there was a memory failure.
+ */
+mntlist_t *
+fsmkmntlist(FILE *mfp)
+{
+	struct extmnttab 	mnt;
+	mntlist_t 	*mhead, *mtail;
+	int 		ret;
+
+	mhead = mtail = NULL;
+
+	resetmnttab(mfp);
+	while ((ret = getextmntent(mfp, &mnt, sizeof (struct extmnttab)))
+	    != -1) {
+		mntlist_t	*mp;
+
+		if (ret != 0)		/* bad entry */
+			continue;
+
+		mp = (mntlist_t *)malloc(sizeof (*mp));
+		if (mp == NULL)
+			goto alloc_failed;
+		if (mhead == NULL)
+			mhead = mp;
+		else
+			mtail->mntl_next = mp;
+		mtail = mp;
+		mp->mntl_next = NULL;
+		mp->mntl_flags = 0;
+		if ((mp->mntl_mnt = fsdupmnttab(&mnt)) == NULL)
+			goto alloc_failed;
+	}
+	return (mhead);
+
+alloc_failed:
+	fsfreemntlist(mhead);
+	return (NULL);
+}
+
+/*
+ * Return the last entry that matches mntin's special
+ * device and/or mountpt.
+ * Helps to be robust here, so we check for NULL pointers.
+ */
+mntlist_t *
+fsgetmlast(mntlist_t *ml, struct mnttab *mntin)
+{
+	mntlist_t 	*delete = NULL;
+
+	for (; ml; ml = ml->mntl_next) {
+		if (mntin->mnt_mountp && mntin->mnt_special) {
+			/*
+			 * match if and only if both are equal.
+			 */
+			if ((strcmp(ml->mntl_mnt->mnt_mountp,
+			    mntin->mnt_mountp) == 0) &&
+			    (strcmp(ml->mntl_mnt->mnt_special,
+			    mntin->mnt_special) == 0))
+				delete = ml;
+		} else if (mntin->mnt_mountp) {
+			if (strcmp(ml->mntl_mnt->mnt_mountp,
+			    mntin->mnt_mountp) == 0)
+				delete = ml;
+		} else if (mntin->mnt_special) {
+			if (strcmp(ml->mntl_mnt->mnt_special,
+			    mntin->mnt_special) == 0)
+				delete = ml;
+		}
+	}
+	return (delete);
+}
+
+
+/*
+ * Returns the mountlevel of the pathname in cp.  As examples,
+ * / => 1, /bin => 2, /bin/ => 2, ////bin////ls => 3, sdf => 0, etc...
+ */
+int
+fsgetmlevel(char *cp)
+{
+	int	mlevel;
+	char	*cp1;
+
+	if (cp == NULL || *cp == NULL || *cp != '/')
+		return (0);	/* this should never happen */
+
+	mlevel = 1;			/* root (/) is the minimal case */
+
+	for (cp1 = cp + 1; *cp1; cp++, cp1++)
+		if (*cp == '/' && *cp1 != '/')	/* "///" counts as 1 */
+			mlevel++;
+
+	return (mlevel);
+}
+
+/*
+ * Returns non-zero if string s is a member of the strings in ps.
+ */
+int
+fsstrinlist(const char *s, const char **ps)
+{
+	const char *cp;
+	cp = *ps;
+	while (cp) {
+		if (strcmp(s, cp) == 0)
+			return (1);
+		ps++;
+		cp = *ps;
+	}
+	return (0);
+}
+
+static char *empty_opt_vector[] = {
+	NULL
+};
+/*
+ * Compare the mount options that were requested by the caller to
+ * the options actually supported by the file system.  If any requested
+ * options are not supported, print a warning message.
+ *
+ * WARNING: this function modifies the string pointed to by
+ *	the requested_opts argument.
+ *
+ * Arguments:
+ *	requested_opts - the string containing the requested options.
+ *	actual_opts - the string returned by mount(2), which lists the
+ *		options actually supported.  It is normal for this
+ *		string to contain more options than the requested options.
+ *		(The actual options may contain the default options, which
+ *		may not have been included in the requested options.)
+ *	special - device being mounted (only used in error messages).
+ *	mountp - mount point (only used in error messages).
+ */
+void
+cmp_requested_to_actual_options(char *requested_opts, char *actual_opts,
+	char *special, char *mountp)
+{
+	char	*option_ptr, *actopt, *equalptr;
+	int	found;
+	char	*actual_opt_hold, *bufp;
+
+	if (requested_opts == NULL)
+		return;
+
+	bufp = alloca(strlen(actual_opts) + 1);
+
+	while (*requested_opts != '\0') {
+		(void) getsubopt(&requested_opts, empty_opt_vector,
+		    &option_ptr);
+
+		/*
+		 * Truncate any "=<value>" string from the end of
+		 * the option.
+		 */
+		if ((equalptr = strchr(option_ptr, '=')) != NULL)
+			*equalptr = '\0';
+
+		if (*option_ptr == '\0')
+			continue;
+
+		/*
+		 * Whilst we don't need this option to perform a lofi
+		 * mount, let's not be mendacious enough to complain
+		 * about it.
+		 */
+		if (strcmp(option_ptr, "loop") == 0)
+			continue;
+
+		/*
+		 * Search for the requested option in the list of options
+		 * actually supported.
+		 */
+		found = 0;
+
+		/*
+		 * Need to use a copy of actual_opts because getsubopt
+		 * is destructive and we need to scan the actual_opts
+		 * string more than once.
+		 *
+		 * We also need to reset actual_opt_hold to the
+		 * beginning of the buffer because getsubopt changes
+		 * actual_opt_hold (the pointer).
+		 */
+		actual_opt_hold = bufp;
+		if (actual_opts != NULL)
+			(void) strcpy(actual_opt_hold, actual_opts);
+		else
+			*actual_opt_hold = '\0';
+
+		while (*actual_opt_hold != '\0') {
+			(void) getsubopt(&actual_opt_hold, empty_opt_vector,
+			    &actopt);
+
+			/* Truncate the "=<value>", if any. */
+			if ((equalptr = strchr(actopt, '=')) != NULL)
+				*equalptr = '\0';
+
+			if ((strcmp(option_ptr, actopt)) == 0) {
+				found = 1;
+				break;
+			}
+		}
+
+		if (found == 0) {
+			/*
+			 * That we're ignoring the option is always
+			 * truthful; the old message that the option
+			 * was unknown is often not correct.
+			 */
+			(void) fprintf(stderr, 
+			    "mount: %s on %s - WARNING ignoring option "
+			    "\"%s\"\n", special, mountp, option_ptr);
+		}
+	}
+}
+/*
+ * FUNCTION:	fsgetmaxphys(int *, int *)
+ *
+ * INPUT:	int *maxphys - a pointer to an integer that will hold
+ *			the value for the system maxphys value.
+ *		int *error - 0 means completed successfully
+ *			     otherwise this indicates the errno value.
+ *
+ * RETURNS:	int	- 0 if maxphys not found
+ *			- 1 if maxphys is found
+ */
+int
+fsgetmaxphys(int *maxphys, int *error) {
+
+	int	gotit = 0;
+	int	fp = open("/", O_RDONLY);
+
+	*error = 0;
+
+	/*
+	 * For some reason cannot open root as read only. Need a valid file
+	 * descriptor to call the ufs private ioctl. If this open failes,
+	 * just assume we cannot get maxphys in this case.
+	 */
+	if (fp == -1) {
+		return (gotit);
+	}
+
+	if (ioctl(fp, _FIOGETMAXPHYS, maxphys) == -1) {
+		*error = errno;
+		(void) close(fp);
+		return (gotit);
+	}
+
+	(void) close(fp);
+	gotit = 1;
+	return (gotit);
+
+}
+
+/*
+ * The below is limited support for zone-aware commands.
+ */
+struct zone_summary {
+	zoneid_t	zoneid;
+	char		rootpath[MAXPATHLEN];
+	size_t		rootpathlen;
+};
+
+struct zone_summary *
+fs_get_zone_summaries(void)
+{
+	uint_t numzones = 0, oldnumzones = 0;
+	uint_t i, j;
+	zoneid_t *ids = NULL;
+	struct zone_summary *summaries;
+	zoneid_t myzoneid = getzoneid();
+
+	for (;;) {
+		if (zone_list(ids, &numzones) < 0) {
+			perror("unable to retrieve list of zones");
+			if (ids != NULL)
+				free(ids);
+			return (NULL);
+		}
+		if (numzones <= oldnumzones)
+			break;
+		if (ids != NULL)
+			free(ids);
+		ids = malloc(numzones * sizeof (*ids));
+		if (ids == NULL) {
+			perror("malloc failed");
+			return (NULL);
+		}
+		oldnumzones = numzones;
+	}
+
+	summaries = malloc((numzones + 1) * sizeof (*summaries));
+	if (summaries == NULL) {
+		free(ids);
+		perror("malloc failed");
+		return (NULL);
+	}
+
+
+	for (i = 0, j = 0; i < numzones; i++) {
+		ssize_t len;
+
+		if (ids[i] == myzoneid)
+			continue;
+		len = zone_getattr(ids[i], ZONE_ATTR_ROOT,
+		    summaries[j].rootpath, sizeof (summaries[j].rootpath));
+		if (len < 0) {
+			/*
+			 * Zone must have gone away. Skip.
+			 */
+			continue;
+		}
+		/*
+		 * Adding a trailing '/' to the zone's rootpath allows us to
+		 * use strncmp() to see if a given path resides within that
+		 * zone.
+		 *
+		 * As an example, if the zone's rootpath is "/foo/root",
+		 * "/foo/root/usr" resides within the zone, while
+		 * "/foo/rootpath" doesn't.
+		 */
+		(void) strlcat(summaries[j].rootpath, "/",
+		    sizeof (summaries[j].rootpath));
+		summaries[j].rootpathlen = len;
+		summaries[j].zoneid = ids[i];
+		j++;
+	}
+	summaries[j].zoneid = -1;
+	free(ids);
+	return (summaries);
+}
+
+static zoneid_t
+fs_find_zone(const struct zone_summary *summaries, const char *mntpt)
+{
+	uint_t i;
+
+	for (i = 0; summaries[i].zoneid != -1; i++) {
+		if (strncmp(mntpt, summaries[i].rootpath,
+		    summaries[i].rootpathlen) == 0)
+			return (summaries[i].zoneid);
+	}
+	/*
+	 * (-1) is the special token we return to the caller if the mount
+	 * wasn't found in any other mounts on the system.  This means it's
+	 * only visible to our zone.
+	 *
+	 * Odd choice of constant, I know, but it beats calling getzoneid() a
+	 * million times.
+	 */
+	return (-1);
+}
+
+boolean_t
+fs_mount_in_other_zone(const struct zone_summary *summaries, const char *mntpt)
+{
+	return (fs_find_zone(summaries, mntpt) != -1);
+}
+
+/*
+ * List of standard options.
+ */
+static const char *stdopts[] = {
+	MNTOPT_RO,			MNTOPT_RW,
+	MNTOPT_SUID,			MNTOPT_NOSUID,
+	MNTOPT_DEVICES,			MNTOPT_NODEVICES,
+	MNTOPT_SETUID,			MNTOPT_NOSETUID,
+	MNTOPT_NBMAND,			MNTOPT_NONBMAND,
+	MNTOPT_EXEC,			MNTOPT_NOEXEC,
+};
+
+#define	NSTDOPT		(sizeof (stdopts) / sizeof (stdopts[0]))
+
+static int
+optindx(const char *opt)
+{
+	int i;
+
+	for (i = 0; i < NSTDOPT; i++) {
+		if (strcmp(opt, stdopts[i]) == 0)
+			return (i);
+	}
+	return (-1);
+}
+
+/*
+ * INPUT:	filesystem option not recognized by the fs specific option
+ *		parsing code.
+ * OUTPUT:	True if and only if the option is one of the standard VFS
+ *		layer options.
+ */
+boolean_t
+fsisstdopt(const char *opt)
+{
+	return (optindx(opt) != -1);
+}
diff -rupN busybox-1.2.0/coreutils/fslib.h busybox-1.2.0solaris/coreutils/fslib.h
--- busybox-1.2.0/coreutils/fslib.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/coreutils/fslib.h	2009-04-20 11:33:38.268566286 +0400
@@ -0,0 +1,91 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+#ifndef	_FSLIB_H
+#define	_FSLIB_H
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#include	<sys/mnttab.h>
+
+/*
+ * This structure is used to build a list of
+ * mnttab structures from /etc/mnttab.
+ */
+typedef struct mntlist {
+	int		mntl_flags;
+	uint_t		mntl_dev;
+	struct extmnttab *mntl_mnt;
+	struct mntlist	*mntl_next;
+} mntlist_t;
+
+/*
+ * Bits for mntl_flags.
+ */
+#define	MNTL_UNMOUNT	0x01	/* unmount this entry */
+#define	MNTL_DIRECT	0x02	/* direct mount entry */
+
+/*
+ * Routines available in fslib.c:
+ */
+void			fsfreemnttab(struct extmnttab *);
+struct extmnttab 	*fsdupmnttab(struct extmnttab *);
+void			fsfreemntlist(mntlist_t *);
+
+mntlist_t	*fsmkmntlist(FILE *);
+mntlist_t	*fsgetmntlist(void);
+mntlist_t	*fsgetmlast(mntlist_t *, struct mnttab *);
+void	cmp_requested_to_actual_options(char *, char *, char *, char *);
+
+int	fsgetmlevel(char *);
+int	fsstrinlist(const char *, const char **);
+int	fsgetmaxphys(int *, int *);
+
+boolean_t 	fsisstdopt(const char *);
+
+/*
+ * Routines for determining which zone a mount resides in.
+ */
+struct zone_summary;
+
+struct		zone_summary *fs_get_zone_summaries(void);
+boolean_t	fs_mount_in_other_zone(const struct zone_summary *,
+    const char *);
+
+#undef MIN
+#undef MAX
+#define	MIN(a, b)	((a) < (b) ? (a) : (b))
+#define	MAX(a, b)	((a) > (b) ? (a) : (b))
+
+#define	MAXLINE		2048
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _FSLIB_H */
diff -rupN busybox-1.2.0/coreutils/mount.c busybox-1.2.0solaris/coreutils/mount.c
--- busybox-1.2.0/coreutils/mount.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/coreutils/mount.c	2009-04-20 13:00:57.481387074 +0400
@@ -0,0 +1,1620 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
+/*	  All Rights Reserved  	*/
+
+
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+#include	<stdio.h>
+#include	<stdio_ext.h>
+#include 	<limits.h>
+#include 	<fcntl.h>
+#include 	<unistd.h>
+#include	<stdlib.h>
+#include	<string.h>
+#include	<stdarg.h>
+#include	<sys/types.h>
+#include	<sys/stat.h>
+#include	<sys/statvfs.h>
+#include	<errno.h>
+#include	<sys/mnttab.h>
+#include	<sys/mntent.h>
+#include	<sys/mount.h>
+#include	<sys/vfstab.h>
+#include	<sys/param.h>
+#include	<sys/wait.h>
+#include	<sys/signal.h>
+#include	<sys/resource.h>
+#include	<stropts.h>
+#include	<sys/conf.h>
+#include	<locale.h>
+#include	"fslib.h"
+
+#include	"busybox.h"
+
+#define	VFS_PATH	"/usr/lib/fs"
+#define	ALT_PATH	"/etc/fs"
+#define	REMOTE		"/etc/dfs/fstypes"
+
+#define	ARGV_MAX	16
+#define	TIME_MAX	50
+#define	FSTYPE_MAX	8
+#define	REMOTE_MAX	64
+
+#define	OLD	0
+#define	NEW	1
+
+#define	READONLY	0
+#define	READWRITE	1
+#define	SUID 		2
+#define	NOSUID		3
+#define	SETUID 		4
+#define	NOSETUID	5
+#define	DEVICES		6
+#define	NODEVICES	7
+
+#define	FORMAT	"%a %b %e %H:%M:%S %Y\n"	/* date time format */
+				/* a - abbreviated weekday name */
+				/* b - abbreviated month name */
+				/* e - day of month */
+				/* H - hour */
+				/* M - minute */
+				/* S - second */
+				/* Y - Year */
+				/* n - newline */
+
+/*
+ * The fs-local method understands this exit code to mean that one or
+ * more failures occurred and that all the failures were of attempted
+ * lofs mounts.
+ */
+#define	ALL_LOFS_FAILURES	111
+
+extern int	optind;
+extern char	*optarg;
+
+extern char	*flags(char *, int);
+extern char	*remote(char *, FILE *);
+extern char	*default_fstype(char *);
+
+char	*myopts[] = {
+	MNTOPT_RO,
+	MNTOPT_RW,
+	MNTOPT_SUID,
+	MNTOPT_NOSUID,
+	MNTOPT_SETUID,
+	MNTOPT_NOSETUID,
+	MNTOPT_DEVICES,
+	MNTOPT_NODEVICES,
+	NULL
+};
+
+static char	*myname;		/* point to argv[0] */
+
+/*
+ * Set the limit to double the number of characters a user should be allowed to
+ * type in one line.
+ * This should cover the different shells, which don't use POSIX_MAX_INPUT,
+ * and should cover the case where a long option string can be in
+ * the /etc/vfstab file.
+ */
+char	mntflags[(_POSIX_MAX_INPUT+1) * 2];
+
+char	realdir[MAXPATHLEN];	/* buffer for realpath() calls */
+char	*vfstab = VFSTAB;
+char	*mnttab = MNTTAB;
+char	*specific_opts;		/* holds specific mount options */
+char	*generic_opts;		/* holds generic mount options */
+static int	maxrun;
+static int	nrun;
+static int	failcnt;		/* total count of failures */
+static int	lofscnt;		/* presence of lofs prohibits parallel */
+				/* mounting */
+static int	lofsfail;		/* count of failures of lofs mounts */
+static int	exitcode;
+static int	aflg, cflg, fflg, Fflg, oflg, pflg, rflg, vflg, Vflg, mflg, Oflg,
+	dashflg, questflg, qflg;
+
+/*
+ * Currently, mounting cachefs instances simultaneously uncovers various
+ * problems.  For the short term, we serialize cachefs activity while we fix
+ * these cachefs bugs.
+ */
+#define	CACHEFS_BUG
+#ifdef	CACHEFS_BUG
+static int	cachefs_running;	/* parallel cachefs not supported yet */
+#endif
+
+/*
+ * Each vfsent_t describes a vfstab entry.  It is used to manage and cleanup
+ * each child that performs the particular mount for the entry.
+ */
+
+typedef struct vfsent {
+	struct vfstab	v;		/* the vfstab entry */
+	char		*rpath;		/* resolved pathname so far */
+	int		mlevel;		/* how deep is this mount point */
+	int		order;		/* vfstab serial order of this vfs */
+	int		flag;
+	pid_t		pid;		/* the pid of this mount process */
+	int		exitcode;	/* process's exitcode */
+#define	RDPIPE		0
+#define	WRPIPE		1
+	int		sopipe[2];	/* pipe attached to child's stdout */
+	int		sepipe[2];	/* pipe attached to child's stderr */
+	struct vfsent	*next;		/* used when in linked list */
+} vfsent_t;
+
+#define	VRPFAILED	0x01		/* most recent realpath failed on */
+					/* this mount point */
+#define	VNOTMOUNTED	0x02		/* mount point could not be mounted */
+
+vfsent_t	*vfsll, *vfslltail;	/* head and tail of the global */
+					/* linked list of vfstab entries */
+vfsent_t	**vfsarray;		/* global array of vfsent_t's */
+int		vfsarraysize;		/* length of the list */
+
+/*
+ * This structure is used to build a linked list of
+ * mnttab structures from /etc/mnttab.
+ */
+typedef struct mountent {
+	struct extmnttab	*ment;
+	int		flag;
+	struct mountent	*next;
+} mountent_t;
+
+#define	MSORTED		0x1
+
+static vfsent_t **make_vfsarray(char **, int);
+static vfsent_t	*new_vfsent(struct vfstab *, int);
+static vfsent_t *getvfsall(char *, int);
+
+static void	doexec(char *, char **);
+static void	nomem();
+static void	cleanup(int);
+static char	*setrpath(vfsent_t *);
+static int	dowait();
+static int	setup_iopipe(vfsent_t *);
+static void	setup_output(vfsent_t *);
+static void	doio(vfsent_t *);
+static void	do_mounts();
+static int	parmount(char **, int, char *);
+static int	mlevelcmp(const void *, const void *);
+static int	check_fields(char *, char *);
+static int	cleanupkid(pid_t, int);
+static void	print_mnttab(int, int);
+static void	vfserror(int, char *);
+static void	mnterror(int);
+static int	ignore(char *);
+
+/*
+ * This is /usr/sbin/mount: the generic command that in turn
+ * execs the appropriate /usr/lib/fs/{fstype}/mount.
+ * The -F flag and argument are NOT passed.
+ * If the usr file system is not mounted a duplicate copy
+ * can be found in /sbin and this version execs the
+ * appropriate /etc/fs/{fstype}/mount
+ *
+ * If the -F fstype, special or directory are missing,
+ * /etc/vfstab is searched to fill in the missing arguments.
+ *
+ * -V will print the built command on the stdout.
+ * It isn't passed either.
+ */
+int
+mount_main(int argc, char *argv[])
+{
+	char	*special,	/* argument of special/resource */
+	    *mountp,		/* argument of mount directory */
+	    *fstype,		/* wherein the fstype name is filled */
+	    *newargv[ARGV_MAX],	/* arg list for specific command */
+	    *farg = NULL, *Farg = NULL;
+	int	ii, ret, cc, fscnt;
+	struct stat64	stbuf;
+	struct vfstab	vget, vref;
+	mode_t mode;
+	FILE	*fd;
+
+	(void) setlocale(LC_ALL, "");
+
+#if !defined(TEXT_DOMAIN)
+#define	TEXT_DOMAIN "SYS_TEST"
+#endif
+	(void) textdomain(TEXT_DOMAIN);
+
+	myname = strrchr(argv[0], '/');
+	if (myname)
+		myname++;
+	else
+		myname = argv[0];
+	if (myname == 0) myname = "path unknown";
+
+	/* Process the args.  */
+
+	while ((cc = getopt(argc, argv, "?ac:f:F:mno:pqrvVO")) != -1)
+		switch (cc) {
+			case 'a':
+				aflg++;
+				break;
+			case 'c':
+				cflg++;
+				break;
+			case 'f':
+				fflg++;
+				farg = optarg;
+				break;
+			case 'F':
+				Fflg++;
+				Farg = optarg;
+				break;
+			case 'm':
+				mflg++;
+				break; /* do not update /etc/mnttab */
+			case 'o':
+				oflg++;
+				if ((specific_opts = strdup(optarg)) == NULL)
+					nomem();
+				break; /* fstype dependent options */
+			case 'O':
+				Oflg++;
+				break;
+			case 'p':
+				pflg++;
+				break;
+			case 'q':
+				qflg++;
+				break;
+			case 'r':
+				rflg++;
+				generic_opts = "ro";
+				break;
+			case 'v':
+				vflg++;
+				break;
+			case 'V':
+				Vflg++;
+				break;
+			case '?':
+				questflg++;
+				break;
+		}
+
+	/* copy '--' to specific */
+	if (strcmp(argv[optind-1], "--") == 0)
+		dashflg++;
+
+	/* option checking */
+	/* more than two args not allowed if !aflg */
+	if (!aflg && (argc - optind > 2))
+		bb_show_usage();
+
+	/* pv mututally exclusive */
+	if (pflg + vflg + aflg > 1) {
+		fprintf(stderr, 
+		    "%s: -a, -p, and -v are mutually exclusive\n",
+		    myname);
+		bb_show_usage();
+	}
+
+	/*
+	 * Can't have overlaying mounts on the same mount point during
+	 * a parallel mount.
+	 */
+	if (aflg && Oflg) {
+		fprintf(stderr, 
+		    "%s: -a and -O are mutually exclusive\n", myname);
+		bb_show_usage();
+	}
+
+	/* dfF mutually exclusive */
+	if (fflg + Fflg > 1) {
+		fprintf(stderr, 
+		    "%s: More than one FSType specified\n", myname);
+		bb_show_usage();
+	}
+
+	/* no arguments, only allow p,v,V or [F]? */
+	if (!aflg && optind == argc) {
+		if (cflg || fflg || mflg || oflg || rflg || qflg)
+			bb_show_usage();
+
+		if (Fflg && !questflg)
+			bb_show_usage();
+
+		if (questflg) {
+			if (Fflg) {
+				newargv[2] = "-?";
+				newargv[3] = NULL;
+				doexec(Farg, newargv);
+			}
+			bb_show_usage();
+		}
+	}
+
+	if (questflg)
+		bb_show_usage();
+
+	/* one or two args, allow any but p,v */
+	if (optind != argc && (pflg || vflg)) {
+		fprintf(stderr,
+    "%s: Cannot use -p and -v with arguments\n", myname);
+		bb_show_usage();
+	}
+
+
+	/* if only reporting mnttab, generic prints mnttab and exits */
+	if (!aflg && optind == argc) {
+		if (Vflg) {
+			printf("%s", myname);
+			if (pflg)
+				printf(" -p");
+			if (vflg)
+				printf(" -v");
+			printf("\n");
+			exit(0);
+		}
+
+		print_mnttab(vflg, pflg);
+		exit(0);
+	}
+
+	/*
+	 * Get filesystem type here.  If "-F FStype" is specified, use
+	 * that fs type.  Otherwise, determine the fs type from /etc/vfstab
+	 * if the entry exists.  Otherwise, determine the local or remote
+	 * fs type from /etc/default/df or /etc/dfs/fstypes respectively.
+	 */
+	if (fflg) {
+		if ((strcmp(farg, "S51K") != 0) &&
+		    (strcmp(farg, "S52K") != 0)) {
+			fstype = farg;
+		}
+		else
+			fstype = "ufs";
+	} else /* if (Fflg) */
+		fstype = Farg;
+
+	fscnt = argc - optind;
+	if (aflg && (fscnt != 1))
+		exit(parmount(argv + optind, fscnt, fstype));
+
+	/*
+	 * Then don't bother with the parallel over head.  Everything
+	 * from this point is simple/normal single execution.
+	 */
+	aflg = 0;
+
+	/* get special and/or mount-point from arg(s) */
+	if (fscnt == 2)
+		special = argv[optind++];
+	else
+		special = NULL;
+	if (optind < argc)
+		mountp = argv[optind++];
+	else
+		mountp = NULL;
+
+	/* lookup only if we need to */
+	if (fstype == NULL || specific_opts == NULL || special == NULL ||
+	    mountp == NULL) {
+		if ((fd = fopen(vfstab, "r")) == NULL) {
+			if (fstype == NULL || special == NULL ||
+			    mountp == NULL) {
+				fprintf(stderr, 
+				    "%s: Cannot open %s\n",
+				    myname, vfstab);
+				exit(1);
+			} else {
+				/*
+				 * No vfstab, but we know what we want
+				 * to mount.
+				 */
+				goto out;
+			}
+		}
+		vfsnull(&vref);
+		vref.vfs_special = special;
+		vref.vfs_mountp = mountp;
+		vref.vfs_fstype = fstype;
+
+		/* get a vfstab entry matching mountp or special */
+		while ((ret = getvfsany(fd, &vget, &vref)) > 0)
+			vfserror(ret, vget.vfs_special);
+
+		/* if no entry and there was only one argument */
+		/* then the argument could be the special */
+		/* and not mount point as we thought earlier */
+		if (ret == -1 && special == NULL) {
+			rewind(fd);
+			special = vref.vfs_special = mountp;
+			mountp = vref.vfs_mountp = NULL;
+			/* skip erroneous lines; they were reported above */
+			while ((ret = getvfsany(fd, &vget, &vref)) > 0)
+				;
+		}
+
+		fclose(fd);
+
+		if (ret == 0) {
+			if (fstype == NULL)
+				fstype = vget.vfs_fstype;
+			if (special == NULL)
+				special = vget.vfs_special;
+			if (mountp == NULL)
+				mountp = vget.vfs_mountp;
+			if (oflg == 0 && vget.vfs_mntopts) {
+				oflg++;
+				specific_opts = vget.vfs_mntopts;
+			}
+		} else if (special == NULL) {
+			if (stat64(mountp, &stbuf) == -1) {
+				fprintf(stderr, "%s: cannot stat %s\n",
+				    myname, mountp);
+				exit(2);
+			}
+			if (((mode = (stbuf.st_mode & S_IFMT)) == S_IFBLK) ||
+			    (mode == S_IFCHR)) {
+				fprintf(stderr,
+    "%s: mount point cannot be determined\n",
+				    myname);
+				exit(1);
+			} else
+				{
+				fprintf(stderr,
+    "%s: special cannot be determined\n",
+				    myname);
+				exit(1);
+			}
+		} else if (fstype == NULL)
+			fstype = default_fstype(special);
+	}
+
+out:
+	if (check_fields(fstype, mountp))
+		exit(1);
+
+	if (realpath(mountp, realdir) == NULL) {
+		(void) fprintf(stderr, "mount: ");
+		perror(mountp);
+		exit(1);
+	}
+
+	if ((mountp = strdup(realdir)) == NULL)
+		nomem();
+
+	/* create the new arg list, and end the list with a null pointer */
+	ii = 2;
+	if (cflg)
+		newargv[ii++] = "-c";
+	if (mflg)
+		newargv[ii++] = "-m";
+	/*
+	 * The q option needs to go before the -o option as some
+	 * filesystems complain during first pass option parsing.
+	 */
+	if (qflg)
+		newargv[ii++] = "-q";
+	if (oflg) {
+		newargv[ii++] = "-o";
+		newargv[ii++] = specific_opts;
+	}
+	if (Oflg)
+		newargv[ii++] = "-O";
+	if (rflg)
+		newargv[ii++] = "-r";
+	if (dashflg)
+		newargv[ii++] = "--";
+	newargv[ii++] = special;
+	newargv[ii++] = mountp;
+	newargv[ii] = NULL;
+
+	doexec(fstype, newargv);
+	return (0);
+}
+
+/*
+ * Get rid of "dev=[hex string]" clause, if any.  It's not legal
+ * when printing in vfstab format.
+ */
+void
+elide_dev(char *mntopts)
+{
+	char *dev, *other;
+
+	if (mntopts != NULL) {
+		dev = strstr(mntopts, "dev=");
+		if (dev != NULL) {
+			other = strpbrk(dev, ",");
+			if (other == NULL) {
+				/* last option */
+				if (dev != mntopts) {
+					*--dev = '\0';
+				} else {
+					*dev = '\0';
+				}
+			} else {
+				/* first or intermediate option */
+				memmove(dev, other+1, strlen(other+1)+1);
+			}
+		}
+	}
+}
+
+void
+print_mnttab(int vflg, int pflg)
+{
+	FILE	*fd;
+	FILE	*rfp;			/* this will be NULL if fopen fails */
+	int	ret;
+	char	time_buf[TIME_MAX];	/* array to hold date and time */
+	struct extmnttab	mget;
+	time_t	ltime;
+
+	if ((fd = fopen(mnttab, "r")) == NULL) {
+		fprintf(stderr, "%s: Cannot open mnttab\n", myname);
+		exit(1);
+	}
+	rfp = fopen(REMOTE, "r");
+	while ((ret = getextmntent(fd, &mget, sizeof (struct extmnttab)))
+	    == 0) {
+		if (ignore(mget.mnt_mntopts))
+			continue;
+		if (mget.mnt_special && mget.mnt_mountp &&
+		    mget.mnt_fstype && mget.mnt_time) {
+			ltime = atol(mget.mnt_time);
+			cftime(time_buf, FORMAT, &ltime);
+			if (pflg) {
+				elide_dev(mget.mnt_mntopts);
+				printf("%s - %s %s - no %s\n",
+				    mget.mnt_special,
+				    mget.mnt_mountp,
+				    mget.mnt_fstype,
+				    mget.mnt_mntopts != NULL ?
+				    mget.mnt_mntopts : "-");
+			} else if (vflg) {
+				printf("%s on %s type %s %s%s on %s",
+				    mget.mnt_special,
+				    mget.mnt_mountp,
+				    mget.mnt_fstype,
+				    remote(mget.mnt_fstype, rfp),
+				    flags(mget.mnt_mntopts, NEW),
+				    time_buf);
+			} else
+				printf("%s on %s %s%s on %s",
+				    mget.mnt_mountp,
+				    mget.mnt_special,
+				    remote(mget.mnt_fstype, rfp),
+				    flags(mget.mnt_mntopts, OLD),
+				    time_buf);
+		}
+	}
+	if (ret > 0)
+		mnterror(ret);
+}
+
+char	*
+flags(char *mntopts, int flag)
+{
+	char	opts[sizeof (mntflags)];
+	char	*value;
+	int	rdwr = 1;
+	int	suid = 1;
+	int	devices = 1;
+	int	setuid = 1;
+
+	if (mntopts == NULL || *mntopts == '\0')
+		return ("read/write/setuid/devices");
+
+	strcpy(opts, "");
+	while (*mntopts != '\0')  {
+		switch (getsubopt(&mntopts, myopts, &value)) {
+		case READONLY:
+			rdwr = 0;
+			break;
+		case READWRITE:
+			rdwr = 1;
+			break;
+		case SUID:
+			suid = 1;
+			break;
+		case NOSUID:
+			suid = 0;
+			break;
+		case SETUID:
+			setuid = 1;
+			break;
+		case NOSETUID:
+			setuid = 0;
+			break;
+		case DEVICES:
+			devices = 1;
+			break;
+		case NODEVICES:
+			devices = 0;
+			break;
+		default:
+			/* cat '/' separator to mntflags */
+			if (*opts != '\0' && value != NULL)
+				strcat(opts, "/");
+			strcat(opts, value);
+			break;
+		}
+	}
+
+	strcpy(mntflags, "");
+	if (rdwr)
+		strcat(mntflags, "read/write");
+	else if (flag == OLD)
+		strcat(mntflags, "read only");
+	else
+		strcat(mntflags, "read-only");
+	if (suid) {
+		if (setuid)
+			strcat(mntflags, "/setuid");
+		else
+			strcat(mntflags, "/nosetuid");
+		if (devices)
+			strcat(mntflags, "/devices");
+		else
+			strcat(mntflags, "/nodevices");
+	} else {
+		strcat(mntflags, "/nosetuid/nodevices");
+	}
+	if (*opts != '\0') {
+		strcat(mntflags, "/");
+		strcat(mntflags, opts);
+	}
+
+	/*
+	 * The assumed assertion
+	 * 	assert (strlen(mntflags) < sizeof mntflags);
+	 * is valid at this point in the code. Note that a call to "assert"
+	 * is not appropriate in production code since it halts the program.
+	 */
+	return (mntflags);
+}
+
+char	*
+remote(char *fstype, FILE *rfp)
+{
+	char	buf[BUFSIZ];
+	char	*fs;
+	extern char *strtok();
+
+	if (rfp == NULL || fstype == NULL ||
+	    strlen(fstype) > (size_t)FSTYPE_MAX)
+		return ("");	/* not a remote */
+	rewind(rfp);
+	while (fgets(buf, sizeof (buf), rfp) != NULL) {
+		fs = strtok(buf, " \t\n");
+		if (strcmp(fstype, fs) == 0)
+			return ("remote/");	/* is a remote fs */
+	}
+	return ("");	/* not a remote */
+}
+
+
+void
+vfserror(int flag, char *special)
+{
+	if (special == NULL)
+		special = "<null>";
+	switch (flag) {
+	case VFS_TOOLONG:
+		fprintf(stderr,
+    "%s: Warning: Line in vfstab for \"%s\" exceeds %d characters\n",
+		    myname, special, VFS_LINE_MAX-1);
+		break;
+	case VFS_TOOFEW:
+		fprintf(stderr,
+    "%s: Warning: Line for \"%s\" in vfstab has too few entries\n",
+		    myname, special);
+		break;
+	case VFS_TOOMANY:
+		fprintf(stderr,
+    "%s: Warning: Line for \"%s\" in vfstab has too many entries\n",
+		    myname, special);
+		break;
+	default:
+		fprintf(stderr, 
+		    "%s: Warning: Error in line for \"%s\" in vfstab\n",
+		    myname, special);
+	}
+}
+
+void
+mnterror(int flag)
+{
+	switch (flag) {
+	case MNT_TOOLONG:
+		fprintf(stderr,
+		    "%s: Line in mnttab exceeds %d characters\n",
+		    myname, MNT_LINE_MAX-2);
+		break;
+	case MNT_TOOFEW:
+		fprintf(stderr,
+		    "%s: Line in mnttab has too few entries\n",
+		    myname);
+		break;
+	case MNT_TOOMANY:
+		fprintf(stderr,
+		    "%s: Line in mnttab has too many entries\n",
+		    myname);
+		break;
+	}
+	exit(1);
+}
+
+void
+doexec(char *fstype, char *newargv[])
+{
+	char	full_path[PATH_MAX];
+	char	alter_path[PATH_MAX];
+	char	*vfs_path = VFS_PATH;
+	char	*alt_path = ALT_PATH;
+	int	i;
+	int	smbfs;
+
+	/*
+	 * Special case smbfs file system.
+	 * Execute command in profile if possible.
+	 */
+	smbfs = strcmp(fstype, "smbfs") == 0;
+
+	/* build the full pathname of the fstype dependent command. */
+	sprintf(full_path, "%s/%s/%s", vfs_path, fstype, myname);
+	sprintf(alter_path, "%s/%s/%s", alt_path, fstype, myname);
+	newargv[1] = myname;
+
+	if (Vflg) {
+		printf("%s -F %s", newargv[1], fstype);
+		for (i = 2; newargv[i]; i++)
+			printf(" %s", newargv[i]);
+		printf("\n");
+		fflush(stdout);
+		exit(0);
+	}
+
+	/*
+	 * Try to exec the fstype dependent portion of the mount.
+	 * See if the directory is there before trying to exec dependent
+	 * portion.  This is only useful for eliminating the
+	 * '..mount: not found' message when '/usr' is mounted
+	 */
+	if (access(full_path, 0) == 0) {
+		if (smbfs) {
+			/*
+			 * Run mount_smbfs(1m) with pfexec so that we can
+			 * add sys_mount privilege, (via exec_attr, etc.)
+			 * allowing normal users to mount on any directory
+			 * they own.
+			 */
+			newargv[0] = "pfexec";
+			newargv[1] = full_path;
+			execv("/usr/bin/pfexec", &newargv[0]);
+			newargv[1] = myname;
+		}
+		execv(full_path, &newargv[1]);
+		if (errno == EACCES) {
+			fprintf(stderr,
+			"%s: Cannot execute %s - permission denied\n",
+			    myname, full_path);
+		}
+		if (errno == ENOEXEC) {
+			newargv[0] = "sh";
+			newargv[1] = full_path;
+			execv("/sbin/sh", &newargv[0]);
+		}
+	}
+	if (smbfs) {
+		newargv[0] = "pfexec";
+		newargv[1] = alter_path;
+		execv("/usr/bin/pfexec", &newargv[0]);
+		newargv[1] = myname;
+	}
+	execv(alter_path, &newargv[1]);
+	if (errno == EACCES) {
+		fprintf(stderr, 
+		    "%s: Cannot execute %s - permission denied\n",
+		    myname, alter_path);
+		exit(1);
+	}
+	if (errno == ENOEXEC) {
+		newargv[0] = "sh";
+		newargv[1] = alter_path;
+		execv("/sbin/sh", &newargv[0]);
+	}
+	fprintf(stderr,
+	    "%s: Operation not applicable to FSType %s\n",
+	    myname, fstype);
+	exit(1);
+}
+
+char *mntopts[] = { MNTOPT_IGNORE, NULL };
+#define	IGNORE    0
+
+/*
+ * Return 1 if "ignore" appears in the options string
+ */
+int
+ignore(char *opts)
+{
+	char *value;
+	char *saveptr, *my_opts;
+	int rval = 0;
+
+	if (opts == NULL || *opts == NULL)
+		return (0);
+
+	/*
+	 * we make a copy of the option string to pass to getsubopt(),
+	 * because getsubopt() modifies the string.  We also save
+	 * the original pointer returned by strdup, because getsubopt
+	 * changes the pointer passed into it.  If strdup fails (unlikely),
+	 * we act as if the "ignore" option isn't set rather than fail.
+	 */
+
+	if ((saveptr = my_opts = strdup(opts)) == NULL)
+		nomem();
+
+	while (*my_opts != '\0') {
+		if (getsubopt(&my_opts, mntopts, &value) == IGNORE)
+			rval = 1;
+	}
+
+	free(saveptr);
+
+	return (rval);
+}
+
+/*
+ * Perform the parallel version of mount.  If count == 0, mount all
+ * vfstab filesystems with the automnt field == "yes".  Use fstype if
+ * supplied.  If mntlist supplied, then attempt to only mount those.
+ */
+
+int
+parmount(char **mntlist, int count, char *fstype)
+{
+	int 		maxfd =	OPEN_MAX;
+	struct 		rlimit rl;
+	vfsent_t	**vl, *vp;
+
+	/*
+	 * Process scaling.  After running a series
+	 * of tests based on the number of simultaneous processes and
+	 * processors available, optimum performance was achieved near or
+	 * at (PROCN * 2).
+	 */
+	if ((maxrun = sysconf(_SC_NPROCESSORS_ONLN)) == -1)
+		maxrun = 4;
+	else
+		maxrun = maxrun * 2 + 1;
+
+	if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
+		rl.rlim_cur = rl.rlim_max;
+		if (setrlimit(RLIMIT_NOFILE, &rl) == 0)
+			maxfd = (int)rl.rlim_cur;
+	}
+	(void) enable_extended_FILE_stdio(-1, -1);
+
+	/*
+	 * The parent needs to maintain 3 of its own fd's, plus 2 for
+	 * each child (the stdout and stderr pipes).
+	 */
+	maxfd = (maxfd / 2) - 6;	/* 6 takes care of temporary  */
+					/* periods of open fds */
+	if (maxfd < maxrun)
+		maxrun = maxfd;
+	if (maxrun < 4)
+		maxrun = 4;		/* sanity check */
+
+	if (count == 0)
+		mntlist = NULL;		/* used as a flag later */
+	else
+		fstype = NULL;		/* mount points supplied: */
+					/* ignore fstype */
+	/*
+	 * Read the whole vfstab into a linked list for quick processing.
+	 * On average, this is the most efficient way to collect and
+	 * manipulate the vfstab data.
+	 */
+	vfsll = getvfsall(fstype, mntlist == NULL);
+
+	/*
+	 * Make an array out of the vfs linked list for sorting purposes.
+	 */
+	if (vfsll == NULL ||
+	    (vfsarray = make_vfsarray(mntlist, count)) == NULL) {
+		if (mntlist == NULL)	/* not an error - just none found */
+			return (0);
+
+		fprintf(stderr, "%s: No valid entries found in %s\n",
+		    myname, vfstab);
+		return (1);
+	}
+
+	/*
+	 * Sort the entries based on their resolved path names
+	 *
+	 * If an lofs is encountered, then the original order of the vfstab
+	 * file needs to be maintained until we are done mounting lofs's.
+	 */
+	if (!lofscnt)
+		qsort((void *)vfsarray, vfsarraysize, sizeof (vfsent_t *),
+		    mlevelcmp);
+
+	/*
+	 * Shrink the vfsll linked list down to the new list.  This will
+	 * speed up the pid search in cleanupkid() later.
+	 */
+	vfsll = vfsarray[0];
+	for (vl = vfsarray; vp = *vl; )
+		vp->next = *++vl;
+
+	/*
+	 * Try to handle interrupts in a reasonable way.
+	 */
+	sigset(SIGHUP, cleanup);
+	sigset(SIGQUIT, cleanup);
+	sigset(SIGINT, cleanup);
+
+	do_mounts();		/* do the mounts */
+
+	if (failcnt > 0 && failcnt == lofsfail)
+		return (ALL_LOFS_FAILURES);
+
+	return (exitcode);
+}
+
+/*
+ * Read all vstab (fp) entries into memory if fstype == NULL.
+ * If fstype is specified, than read all those that match it.
+ *
+ * Returns a linked list.
+ */
+vfsent_t *
+getvfsall(char *fstype, int takeall)
+{
+	vfsent_t	*vhead, *vtail;
+	struct vfstab 	vget;
+	FILE		*fp;
+	int		cnt = 0, ret;
+
+	if ((fp = fopen(vfstab, "r")) == NULL) {
+		fprintf(stderr, "%s: Cannot open %s\n",
+		    myname, vfstab);
+		exit(1);
+	}
+
+	vhead = vtail = NULL;
+
+	while ((ret = getvfsent(fp, &vget)) != -1) {
+		vfsent_t *vp;
+
+		if (ret > 0) {
+			vfserror(ret, vget.vfs_mountp);
+			continue;
+		}
+
+		/*
+		 * If mount points were not specified, then we ignore
+		 * entries that aren't marked "yes".
+		 */
+		if (takeall &&
+		    (vget.vfs_automnt == NULL ||
+		    strcmp(vget.vfs_automnt, "yes")))
+			continue;
+
+		if (fstype && vget.vfs_fstype &&
+		    strcmp(fstype, vget.vfs_fstype))
+			continue;
+
+		if (vget.vfs_mountp == NULL ||
+		    (vget.vfs_fstype && (strcmp(vget.vfs_fstype, "swap") == 0)))
+			continue;
+
+		if (check_fields(vget.vfs_fstype, vget.vfs_mountp)) {
+			exitcode = 1;
+			continue;
+		}
+
+		vp = new_vfsent(&vget, cnt);	/* create new vfs entry */
+		if (vhead == NULL)
+			vhead = vp;
+		else
+			vtail->next = vp;
+		vtail = vp;
+		cnt++;
+	}
+	fclose(fp);
+	if (vtail == NULL) {
+		vfsarraysize = 0;
+		vfslltail = NULL;
+		return (NULL);
+	}
+	vtail->next = NULL;
+	vfslltail = vtail;	/* save it in the global variable */
+	vfsarraysize = cnt;
+	return (vhead);
+}
+
+
+/*
+ * Returns an array of vfsent_t's based on vfsll & mntlist.
+ */
+vfsent_t **
+make_vfsarray(char **mntlist, int count)
+{
+	vfsent_t 	*vp, *vmark, *vpprev, **vpp;
+	int		ndx, found;
+
+	if (vfsll == NULL)
+		return (NULL);
+
+	if (count > 0)
+		vfsarraysize = count;
+
+	vpp = (vfsent_t **)malloc(sizeof (*vpp) * (vfsarraysize + 1));
+	if (vpp == NULL)
+		nomem();
+
+	if (mntlist == NULL) {
+		/*
+		 * No mount list specified: take all vfstab mount points.
+		 */
+		for (ndx = 0, vp = vfsll; vp; vp = vp->next) {
+			(void) setrpath(vp);
+			/*
+			 * Sigh. lofs entries can complicate matters so much
+			 * that the best way to avoid problems is to
+			 * stop parallel mounting when an lofs is
+			 * encountered, so we keep a count of how many
+			 * there are.
+			 * Fortunately this is rare.
+			 */
+			if (vp->v.vfs_fstype &&
+			    (strcmp(vp->v.vfs_fstype, MNTTYPE_LOFS) == 0))
+				lofscnt++;
+
+			vpp[ndx++] = vp;
+		}
+		vpp[ndx] = NULL;
+		return (vpp);
+	}
+
+	/*
+	 * A list of mount points was specified on the command line
+	 * and we need to search for each one.
+	 */
+	vpprev = vfslltail;
+	vpprev->next = vfsll;	/* make a circle out of it */
+	vmark = vp = vfsll;
+	/*
+	 * For each specified mount point:
+	 */
+	for (ndx = 0; *mntlist; mntlist++) {
+		found = 0;
+		/*
+		 * Circle our entire linked list, looking for *mntlist.
+		 */
+		while (vp) {
+			if (strcmp(*mntlist, vp->v.vfs_mountp) == 0) {
+				vpp[ndx++] = vp;	/* found it. */
+				(void) setrpath(vp);
+				if (vp->v.vfs_fstype &&
+				    (strcmp(vp->v.vfs_fstype,
+				    MNTTYPE_LOFS) == 0))
+					lofscnt++;
+
+				if (vp == vpprev) {	/* list exhausted */
+					vp = NULL;
+					found++;
+					break;
+				}
+				/*
+				 * Remove it from the circular list.  vpprev
+				 * remains unchanged.
+				 */
+				vp = vp->next;
+				vpprev->next->next = NULL;
+				vpprev->next = vp;
+				/*
+				 * Set vmark to the first elem that we check
+				 * each time.
+				 */
+				vmark = vp;
+				found++;
+				break;
+			}
+			vpprev = vp;
+			vp = vp->next;
+			if (vp == vmark)	/* break out if we completed */
+						/* the circle */
+				break;
+		}
+
+		if (!found) {
+			fprintf(stderr, 
+			    "%s: Warning: %s not found in %s\n",
+			    myname, *mntlist, vfstab);
+			exitcode = 1;
+		}
+	}
+	if (ndx == 0)
+		return (NULL);
+
+	vpp[ndx] = NULL;	/* null terminate the list */
+	vfsarraysize = ndx;	/* adjust vfsarraysize */
+	return (vpp);
+}
+
+/*
+ * Performs the exec argument processing, all  of the child forking and
+ * execing, and child cleanup.
+ * Sets exitcode to non-zero if any errors occurred.
+ */
+void
+do_mounts(void)
+{
+	int 		i, isave, cnt;
+	vfsent_t 	*vp, *vpprev, **vl;
+	char		*newargv[ARGV_MAX];
+	pid_t		child;
+
+	/*
+	 * create the arg list once;  the only differences among
+	 * the calls are the options, special and mountp fields.
+	 */
+	i = 2;
+	if (cflg)
+		newargv[i++] = "-c";
+	if (mflg)
+		newargv[i++] = "-m";
+	if (Oflg)
+		newargv[i++] = "-O";
+	if (qflg)
+		newargv[i++] = "-q";
+	if (rflg)
+		newargv[i++] = "-r";
+	if (dashflg)
+		newargv[i++] = "--";
+	if (oflg) {
+		newargv[i++] = "-o";
+		newargv[i++] = specific_opts;
+	}
+	isave = i;
+
+	/*
+	 * Main loop for the mount processes
+	 */
+	vl = vfsarray;
+	cnt = vfsarraysize;
+	for (vpprev = *vl; vp = *vl; vpprev = vp, vl++, cnt--) {
+		/*
+		 * Check to see if we cross a mount level: e.g.,
+		 * /a/b -> /a/b/c.  If so, we need to wait for all current
+		 * mounts to finish, rerun realpath on the remaining mount
+		 * points, and resort the list.
+		 *
+		 * Also, we mount serially as long as there are lofs's
+		 * to mount to avoid improper mount ordering.
+		 */
+		if (vp->mlevel > vpprev->mlevel || lofscnt > 0) {
+			vfsent_t **vlp;
+
+			while (nrun > 0 && (dowait() != -1))
+				;
+			/*
+			 * Gads! It's possible for real path mounts points to
+			 * change after mounts are done at a lower mount
+			 * level.
+			 * Thus, we need to recalculate mount levels and
+			 * resort the list from this point.
+			 */
+			for (vlp = vl; *vlp; vlp++)
+				(void) setrpath(*vlp);
+			/*
+			 * Sort the remaining entries based on their newly
+			 * resolved path names.
+			 * Do not sort if we still have lofs's to mount.
+			 */
+			if (lofscnt == 0) {
+				qsort((void *)vl, cnt, sizeof (vfsent_t *),
+				    mlevelcmp);
+				vp = *vl;
+			}
+		}
+
+		if (vp->flag & VRPFAILED) {
+			fprintf(stderr, 
+			    "%s: Nonexistent mount point: %s\n",
+			    myname, vp->v.vfs_mountp);
+			vp->flag |= VNOTMOUNTED;
+			exitcode = 1;
+			continue;
+		}
+
+		/*
+		 * If mount options were not specified on the command
+		 * line, then use the ones found in the vfstab entry,
+		 * if any.
+		 */
+		i = isave;
+		if (!oflg && vp->v.vfs_mntopts) {
+			newargv[i++] = "-o";
+			newargv[i++] = vp->v.vfs_mntopts;
+		}
+		newargv[i++] = vp->v.vfs_special;
+		newargv[i++] = vp->rpath;
+		newargv[i] = NULL;
+
+		/*
+		 * This should never really fail.
+		 */
+		while (setup_iopipe(vp) == -1 && (dowait() != -1))
+			;
+
+		while (nrun >= maxrun && (dowait() != -1))	/* throttle */
+			;
+
+#ifdef	CACHEFS_BUG
+		if (vp->v.vfs_fstype &&
+		    (strcmp(vp->v.vfs_fstype, "cachefs") == 0)) {
+			while (cachefs_running && (dowait() != -1))
+				;
+			cachefs_running = 1;
+		}
+#endif
+
+		if ((child = fork()) == -1) {
+			perror("fork");
+			cleanup(-1);
+			/* not reached */
+		}
+		if (child == 0) {		/* child */
+			signal(SIGHUP, SIG_IGN);
+			signal(SIGQUIT, SIG_IGN);
+			signal(SIGINT, SIG_IGN);
+			setup_output(vp);
+			doexec(vp->v.vfs_fstype, newargv);
+			perror("exec");
+			exit(1);
+		}
+
+		/* parent */
+		(void) close(vp->sopipe[WRPIPE]);
+		(void) close(vp->sepipe[WRPIPE]);
+		vp->pid = child;
+		nrun++;
+	}
+	/*
+	 * Mostly done by now - wait and clean up the stragglers.
+	 */
+	cleanup(0);
+}
+
+
+/*
+ * Setup stdout and stderr pipes for the children's output.
+ */
+int
+setup_iopipe(vfsent_t *mp)
+{
+	/*
+	 * Make a stdout and stderr pipe.  This should never fail.
+	 */
+	if (pipe(mp->sopipe) == -1)
+		return (-1);
+	if (pipe(mp->sepipe) == -1) {
+		(void) close(mp->sopipe[RDPIPE]);
+		(void) close(mp->sopipe[WRPIPE]);
+		return (-1);
+	}
+	/*
+	 * Don't block on an empty pipe.
+	 */
+	(void) fcntl(mp->sopipe[RDPIPE], F_SETFL, O_NDELAY|O_NONBLOCK);
+	(void) fcntl(mp->sepipe[RDPIPE], F_SETFL, O_NDELAY|O_NONBLOCK);
+	/*
+	 * Don't pass extra fds into children.
+	 */
+	(void) fcntl(mp->sopipe[RDPIPE], F_SETFD, FD_CLOEXEC);
+	(void) fcntl(mp->sepipe[RDPIPE], F_SETFD, FD_CLOEXEC);
+
+	return (0);
+}
+
+/*
+ * Called by a child to attach its stdout and stderr to the write side of
+ * the pipes.
+ */
+void
+setup_output(vfsent_t *vp)
+{
+
+	(void) close(fileno(stdout));
+	(void) dup(vp->sopipe[WRPIPE]);
+	(void) close(vp->sopipe[WRPIPE]);
+
+	(void) close(fileno(stderr));
+	(void) dup(vp->sepipe[WRPIPE]);
+	(void) close(vp->sepipe[WRPIPE]);
+}
+
+/*
+ * Parent uses this to print any stdout or stderr output issued by
+ * the child.
+ */
+static void
+doio(vfsent_t *vp)
+{
+	int bytes;
+	char ibuf[BUFSIZ];
+
+	while ((bytes = read(vp->sepipe[RDPIPE], ibuf, sizeof (ibuf))) > 0)
+		write(fileno(stderr), ibuf, bytes);
+	while ((bytes = read(vp->sopipe[RDPIPE], ibuf, sizeof (ibuf))) > 0)
+		write(fileno(stdout), ibuf, bytes);
+
+	(void) close(vp->sopipe[RDPIPE]);
+	(void) close(vp->sepipe[RDPIPE]);
+}
+
+/*
+ * Waits for 1 child to die.
+ *
+ * Returns -1 if no children are left to wait for.
+ * Returns 0 if a child died without an error.
+ * Returns 1 if a child died with an error.
+ */
+int
+dowait(void)
+{
+	int child, wstat;
+
+	if ((child = wait(&wstat)) == -1)
+		return (-1);
+	nrun--;
+	return (cleanupkid(child, wstat) != 0);
+}
+
+/*
+ * Locates the child mount process represented by pid, outputs any io
+ * it may have, and returns its exit code.
+ * Sets the global exitcode if an error occurred.
+ */
+int
+cleanupkid(pid_t pid, int wstat)
+{
+	vfsent_t *vp, *prevp;
+	int ret;
+
+	if (WIFEXITED(wstat))		/* this should always be true */
+		ret = WEXITSTATUS(wstat);
+	else
+		ret = 1;		/* assume some kind of error */
+	if (ret) {
+		exitcode = 1;
+		failcnt++;
+	}
+
+	/*
+	 * Find our child.
+	 * This search gets smaller and smaller as children are cleaned
+	 * up.
+	 */
+	for (prevp = NULL, vp = vfsll; vp; vp = vp->next) {
+		if (vp->pid != pid) {
+			prevp = vp;
+			continue;
+		}
+		/*
+		 * Found: let's remove it from this linked list.
+		 */
+		if (prevp) {
+			prevp->next = vp->next;
+			vp->next = NULL;
+		}
+		break;
+	}
+
+	if (vp == NULL) {
+		/*
+		 * This should never happen.
+		 */
+		fprintf(stderr, 
+		    "%s: Unknown child %d\n", myname, pid);
+		exitcode = 1;
+		return (ret);
+	}
+	doio(vp);	/* Any output? */
+
+	if (vp->v.vfs_fstype &&
+	    (strcmp(vp->v.vfs_fstype, MNTTYPE_LOFS) == 0)) {
+		lofscnt--;
+		if (ret)
+			lofsfail++;
+	}
+
+#ifdef CACHEFS_BUG
+	if (vp->v.vfs_fstype && (strcmp(vp->v.vfs_fstype, "cachefs") == 0))
+		cachefs_running = 0;
+#endif
+
+	vp->exitcode = ret;
+	return (ret);
+}
+
+
+static vfsent_t zvmount = { 0 };
+
+vfsent_t *
+new_vfsent(struct vfstab *vin, int order)
+{
+	vfsent_t *new;
+
+	new = (vfsent_t *)malloc(sizeof (*new));
+	if (new == NULL)
+		nomem();
+
+	*new = zvmount;
+	if (vin->vfs_special &&
+	    (new->v.vfs_special = strdup(vin->vfs_special)) == NULL)
+		nomem();
+	if (vin->vfs_mountp &&
+	    (new->v.vfs_mountp = strdup(vin->vfs_mountp)) == NULL)
+		nomem();
+	if (vin->vfs_fstype &&
+	    (new->v.vfs_fstype = strdup(vin->vfs_fstype)) == NULL)
+		nomem();
+	/*
+	 * If specific mount options were specified on the command
+	 * line, then use those.  Else, use the ones on the vfstab
+	 * line, if any.  In other words, specific options on the
+	 * command line override those in /etc/vfstab.
+	 */
+	if (oflg) {
+		if ((new->v.vfs_mntopts = strdup(specific_opts)) == NULL)
+			nomem();
+	} else if (vin->vfs_mntopts &&
+	    (new->v.vfs_mntopts = strdup(vin->vfs_mntopts)) == NULL)
+			nomem();
+
+	new->order = order;
+	return (new);
+}
+
+/*
+ * Runs realpath on vp's mount point, records success or failure,
+ * resets the mount level based on the new realpath, and returns
+ * realpath()'s return value.
+ */
+char *
+setrpath(vfsent_t *vp)
+{
+	char *rp;
+
+	if ((rp = realpath(vp->v.vfs_mountp, realdir)) == NULL)
+		vp->flag |= VRPFAILED;
+	else
+		vp->flag &= ~VRPFAILED;
+
+	if (vp->rpath)
+		free(vp->rpath);
+	if ((vp->rpath = strdup(realdir)) == NULL)
+		nomem();
+	vp->mlevel = fsgetmlevel(vp->rpath);
+	return (rp);
+}
+
+
+/*
+ * sort first by mlevel (1...N), then by vfstab order.
+ */
+int
+mlevelcmp(const void *a, const void *b)
+{
+	vfsent_t *a1, *b1;
+	int	lcmp;
+
+	a1 = *(vfsent_t **)a;
+	b1 = *(vfsent_t **)b;
+
+	lcmp = a1->mlevel - b1->mlevel;
+	if (lcmp == 0)
+		lcmp = a1->order - b1->order;
+	return (lcmp);
+}
+
+/*
+ * cleanup the existing children and exit with an error
+ * if asig != 0.
+ */
+void
+cleanup(int asig)
+{
+	while (nrun > 0 && (dowait() != -1))
+		;
+
+	if (asig != 0)
+		exit(1);
+}
+
+
+int
+check_fields(char *fstype, char *mountp)
+{
+	struct stat64 stbuf;
+
+	if (strlen(fstype) > (size_t)FSTYPE_MAX) {
+		fprintf(stderr,
+		    "%s: FSType %s exceeds %d characters\n",
+		    myname, fstype, FSTYPE_MAX);
+		return (1);
+	}
+
+	if (mountp == NULL) {
+		fprintf(stderr,
+		    "%s: Mount point cannot be determined\n",
+		    myname);
+		return (1);
+	}
+	if (*mountp != '/') {
+		fprintf(stderr, 
+		    "%s: Mount point %s is not an absolute pathname.\n",
+		    myname, mountp);
+		return (1);
+	}
+	/*
+	 * Don't do some of these checks if aflg because a mount point may
+	 * not exist now, but will be mounted before we get to it.
+	 * This is one of the quirks of "secondary mounting".
+	 */
+	if (!aflg && stat64(mountp, &stbuf) < 0) {
+		if (errno == ENOENT || errno == ENOTDIR)
+			fprintf(stderr,
+			    "%s: Mount point %s does not exist.\n",
+			    myname, mountp);
+		else {
+			fprintf(stderr,
+			    "%s: Cannot stat mount point %s.\n",
+			    myname, mountp);
+			perror(myname);
+		}
+		return (1);
+	}
+	return (0);
+}
+
+void
+nomem(void)
+{
+	fprintf(stderr, "%s: Out of memory\n", myname);
+	while (nrun > 0 && (dowait() != -1))
+		;
+	exit(1);
+}
diff -rupN busybox-1.2.0/coreutils/umount.c busybox-1.2.0solaris/coreutils/umount.c
--- busybox-1.2.0/coreutils/umount.c	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/coreutils/umount.c	2009-04-20 13:12:11.087277101 +0400
@@ -0,0 +1,1051 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
+/*	  All Rights Reserved  	*/
+
+#include	<stdio.h>
+#include	<stdio_ext.h>
+#include	<limits.h>
+#include	<unistd.h>
+#include	<stdlib.h>
+#include	<string.h>
+#include	<sys/signal.h>
+#include	<sys/mnttab.h>
+#include	<errno.h>
+#include	<sys/types.h>
+#include	<sys/stat.h>
+#include	<sys/param.h>
+#include	<sys/wait.h>
+#include	<sys/vfstab.h>
+#include	<sys/fcntl.h>
+#include	<sys/resource.h>
+#include	<sys/mntent.h>
+#include	<sys/ctfs.h>
+#include	<locale.h>
+#include	<stdarg.h>
+#include	<sys/mount.h>
+#include	<sys/objfs.h>
+#include	"fslib.h"
+#include	<sharefs/share.h>
+
+#include	"busybox.h"
+
+#define	FS_PATH		"/usr/lib/fs"
+#define	ALT_PATH	"/etc/fs"
+#define	FULLPATH_MAX	32
+#define	FSTYPE_MAX	8
+#define	ARGV_MAX	16
+
+static int	aflg, oflg, Vflg, dashflg, fflg;
+
+void	rpterr(), mnterror();
+
+extern	char	*optarg;	/* used by getopt */
+extern	int	optind, opterr;
+
+static char	*myname;
+char	fs_path[] = FS_PATH;
+char	alt_path[] = ALT_PATH;
+static char	mnttab[MAXPATHLEN + 1];
+char	*oarg, *farg;
+static int	maxrun, nrun;
+static int	no_mnttab;
+static int	lofscnt;		/* presence of lofs prohibits parallel */
+				/* umounting */
+static int	exitcode;
+char	resolve[MAXPATHLEN];
+static  char ibuf[BUFSIZ];
+
+/*
+ * Currently, mounting cachefs's simultaneous uncovers various problems.
+ * For the short term, we serialize cachefs activity while we fix
+ * these cachefs bugs.
+ */
+#define	CACHEFS_BUG
+#ifdef	CACHEFS_BUG
+#include	<sys/fs/cachefs_fs.h>	/* for BACKMNT_NAME */
+static int	cachefs_running;	/* parallel cachefs not supported yet */
+#endif
+
+/*
+ * The basic mount struct that describes an mnttab entry.
+ * It is used both in an array and as a linked list elem.
+ */
+
+typedef struct mountent {
+	struct mnttab	ment;		/* the mnttab data */
+	int		mlevel;		/* mount level of the mount pt */
+	pid_t		pid;		/* the pid of this mount process */
+#define	RDPIPE		0
+#define	WRPIPE		1
+	int		sopipe[2];	/* pipe attached to child's stdout */
+	int		sepipe[2];	/* pipe attached to child's stderr */
+	struct mountent *link;		/* used when in linked list */
+} mountent_t;
+
+static mountent_t	*mntll;		/* head of global linked list of */
+					/* mountents */
+int			listlength;	/* # of elems in this list */
+
+/*
+ * If the automatic flag (-a) is given and mount points are not specified
+ * on the command line, then do not attempt to umount these.  These
+ * generally need to be kept mounted until system shutdown.
+ */
+static const char   *keeplist[] = {
+	"/",
+	"/dev",
+	"/dev/fd",
+	"/devices",
+	"/etc/mnttab",
+	"/etc/svc/volatile",
+	"/lib",
+	"/proc",
+	"/sbin",
+	CTFS_ROOT,
+	OBJFS_ROOT,
+	"/tmp",
+	"/usr",
+	"/var",
+	"/var/adm",
+	"/var/run",
+	SHARETAB,
+	NULL
+};
+
+static void	nomem();
+static void	doexec(struct mnttab *);
+static int	setup_iopipe(mountent_t *);
+static void	setup_output(mountent_t *);
+static void	doio(mountent_t *);
+static void	do_umounts(mountent_t **);
+static int	dowait();
+static int	parumount();
+static int	mcompar(const void *, const void *);
+static void	cleanup(int);
+
+static mountent_t	**make_mntarray(char **, int);
+static mountent_t	*getmntall();
+static mountent_t 	*new_mountent(struct mnttab *);
+static mountent_t	*getmntlast(mountent_t *, char *, char *);
+
+int
+umount_main(int argc, char **argv)
+{
+	int 	cc;
+	struct mnttab  mget;
+	char 	*mname, *is_special;
+	int	fscnt;
+	mountent_t	*mp;
+
+	(void) setlocale(LC_ALL, "");
+
+#if !defined(TEXT_DOMAIN)
+#define	TEXT_DOMAIN "SYS_TEST"
+#endif
+	(void) textdomain(TEXT_DOMAIN);
+
+	myname = strrchr(argv[0], '/');
+	if (myname)
+		myname++;
+	else
+		myname = argv[0];
+
+	/*
+	 * Process the args.
+	 * "-d" for compatibility
+	 */
+	while ((cc = getopt(argc, argv, "ao:Vf?")) != -1)
+		switch (cc) {
+		case 'a':
+			aflg++;
+			break;
+		case '?':
+			bb_show_usage();
+			break;
+		case 'o':
+			if (oflg)
+				bb_show_usage();
+			else {
+				oflg++;
+				oarg = optarg;
+			}
+			break;
+		case 'f':
+			fflg++;
+			break;
+		case 'V':
+			if (Vflg)
+				bb_show_usage();
+			else
+				Vflg++;
+			break;
+		default:
+			bb_show_usage();
+			break;
+		}
+
+	fscnt = argc - optind;
+	if (!aflg && fscnt != 1)
+		bb_show_usage();
+
+	/* copy '--' to specific */
+	if (strcmp(argv[optind-1], "--") == 0)
+		dashflg++;
+
+	/*
+	 * mnttab may be a symlink to a file in another file system.
+	 * This happens during install when / is mounted read-only
+	 * and /etc/mnttab is symlinked to a file in /tmp.
+	 * If this is the case, we need to follow the symlink to the
+	 * read-write file itself so that the subsequent mnttab.temp
+	 * open and rename will work.
+	 */
+	if (realpath(MNTTAB, mnttab) == NULL) {
+		strcpy(mnttab, MNTTAB);
+	}
+
+	/*
+	 * bugid 1205242
+	 * call the realpath() here, so that if the user is
+	 * trying to umount an autofs directory, the directory
+	 * is forced to mount.
+	 */
+
+	mname = argv[optind];
+	is_special = realpath(mname, resolve);
+
+	/*
+	 * Read the whole mnttab into memory.
+	 */
+	mntll = getmntall();
+
+	if (aflg && fscnt != 1)
+		exit(parumount(argv + optind, fscnt));
+
+	aflg = 0;
+
+	mntnull(&mget);
+	if (listlength == 0) {
+		fprintf(stderr, "%s: warning: no entries found in %s\n",
+		    myname, mnttab);
+		mget.mnt_mountp = mname;	/* assume mount point */
+		no_mnttab++;
+		doexec(&mget);
+		exit(0);
+	}
+
+	mp = NULL;
+
+	/*
+	 * if realpath fails, it can't be a mount point, so we'll
+	 * go straight to the code that treats the arg as a special.
+	 * if realpath succeeds, it could be a special or a mount point;
+	 * we'll start by assuming it's a mount point, and if it's not,
+	 * try to treat it as a special.
+	 */
+	if (is_special != NULL) {
+		/*
+		 * if this succeeds,
+		 * we'll have the appropriate record; if it fails
+		 * we'll assume the arg is a special of some sort
+		 */
+		mp = getmntlast(mntll, NULL, resolve);
+	}
+	/*
+	 * Since stackable mount is allowed (RFE 2001535),
+	 * we will un-mount the last entry in the MNTTAB that matches.
+	 */
+	if (mp == NULL) {
+		/*
+		 * Perhaps there is a bogus mnttab entry that
+		 * can't be resolved:
+		 */
+		if ((mp = getmntlast(mntll, NULL, mname)) == NULL)
+			/*
+			 * assume it's a device (special) now
+			 */
+			mp = getmntlast(mntll, mname, NULL);
+		if (mp) {
+			/*
+			 * Found it.
+			 * This is a device. Now we want to know if
+			 * it stackmounted on by something else.
+			 * The original fix for bug 1103850 has a
+			 * problem with lockfs (bug 1119731). This
+			 * is a revised method.
+			 */
+			mountent_t *lmp;
+			lmp = getmntlast(mntll, NULL, mp->ment.mnt_mountp);
+
+			if (lmp && strcmp(lmp->ment.mnt_special,
+			    mp->ment.mnt_special)) {
+				errno = EBUSY;
+				rpterr(mname);
+				exit(1);
+			}
+		} else {
+			fprintf(stderr, "%s: warning: %s not in mnttab\n",
+			    myname, mname);
+			if (Vflg)
+				exit(1);
+				/*
+				 * same error as mount -V
+				 * would give for unknown
+				 * mount point
+				 */
+			mget.mnt_special = mget.mnt_mountp = mname;
+		}
+	}
+
+	if (mp)
+		doexec(&mp->ment);
+	else
+		doexec(&mget);
+
+	return (0);
+}
+
+void
+doexec(struct mnttab *ment)
+{
+	int 	ret;
+	/* try to exec the dependent portion */
+	if ((ment->mnt_fstype != NULL) || Vflg) {
+		char	full_path[FULLPATH_MAX];
+		char	alter_path[FULLPATH_MAX];
+		char	*newargv[ARGV_MAX];
+		int 	ii;
+		int	smbfs;
+
+		if (strlen(ment->mnt_fstype) > (size_t)FSTYPE_MAX) {
+			fprintf(stderr, "%s: FSType %s exceeds %d characters\n",
+			    myname, ment->mnt_fstype, FSTYPE_MAX);
+			exit(1);
+		}
+
+		/*
+		 * Special case smbfs file system.
+		 * Execute command in profile if possible.
+		 */
+		smbfs = strcmp(ment->mnt_fstype, "smbfs") == 0;
+
+		/* build the full pathname of the fstype dependent command. */
+		sprintf(full_path, "%s/%s/%s", fs_path, ment->mnt_fstype,
+		    myname);
+		sprintf(alter_path, "%s/%s/%s", alt_path, ment->mnt_fstype,
+		    myname);
+
+		/*
+		 * create the new arg list, and end the list with a
+		 * null pointer
+		 */
+		ii = 2;
+		if (oflg) {
+			newargv[ii++] = "-o";
+			newargv[ii++] = oarg;
+		}
+		if (dashflg) {
+			newargv[ii++] = "--";
+		}
+		if (fflg) {
+			newargv[ii++] = "-f";
+		}
+		newargv[ii++] = (ment->mnt_mountp)
+		    ? ment->mnt_mountp : ment->mnt_special;
+		newargv[ii] = NULL;
+
+		/* set the new argv[0] to the filename */
+		newargv[1] = myname;
+
+		if (Vflg) {
+			printf("%s", myname);
+			for (ii = 2; newargv[ii]; ii++)
+				printf(" %s", newargv[ii]);
+			printf("\n");
+			fflush(stdout);
+			exit(0);
+		}
+
+		/* Try to exec the fstype dependent umount. */
+		if (smbfs) {
+			/*
+			 * Run umount_smbfs(1m) with pfexec so that we can
+			 * add sys_mount privilege, (via exec_attr, etc.)
+			 * allowing normal users to unmount any directory
+			 * they own.
+			 */
+			newargv[0] = "pfexec";
+			newargv[1] = full_path;
+			execv("/usr/bin/pfexec", &newargv[0]);
+			newargv[1] = myname;
+		}
+		execv(full_path, &newargv[1]);
+		if (errno == ENOEXEC) {
+			newargv[0] = "sh";
+			newargv[1] = full_path;
+			execv("/sbin/sh", &newargv[0]);
+		}
+		if (smbfs) {
+			newargv[0] = "pfexec";
+			newargv[1] = alter_path;
+			execv("/usr/bin/pfexec", &newargv[0]);
+		}
+		newargv[1] = myname;
+		execv(alter_path, &newargv[1]);
+		if (errno == ENOEXEC) {
+			newargv[0] = "sh";
+			newargv[1] = alter_path;
+			execv("/sbin/sh", &newargv[0]);
+		}
+		/* exec failed */
+		if (errno != ENOENT) {
+			fprintf(stderr, "umount: cannot execute %s\n",
+			    full_path);
+			exit(1);
+		}
+	}
+	/*
+	 * No fstype independent executable then.  We'll go generic
+	 * from here.
+	 */
+
+	/* don't use -o with generic */
+	if (oflg) {
+		fprintf(stderr, "%s: %s specific umount does not exist;"
+		    " -o suboption ignored\n",
+		    myname, ment->mnt_fstype ? ment->mnt_fstype : "<null>");
+	}
+
+	signal(SIGHUP,  SIG_IGN);
+	signal(SIGQUIT, SIG_IGN);
+	signal(SIGINT,  SIG_IGN);
+	/*
+	 * Try to umount the mountpoint.
+	 * If that fails, try the corresponding special.
+	 * (This ordering is necessary for nfs umounts.)
+	 * (for remote resources:  if the first umount returns EBUSY
+	 * don't call umount again - umount() with a resource name
+	 * will return a misleading error to the user
+	 */
+	if (fflg) {
+		if (((ret = umount2(ment->mnt_mountp, MS_FORCE)) < 0) &&
+		    (errno != EBUSY && errno != ENOTSUP &&
+		    errno != EPERM))
+			ret = umount2(ment->mnt_special, MS_FORCE);
+	} else {
+		if (((ret = umount2(ment->mnt_mountp, 0)) < 0) &&
+		    (errno != EBUSY) && (errno != EPERM))
+			ret = umount2(ment->mnt_special, 0);
+	}
+
+	if (ret < 0) {
+		rpterr(ment->mnt_mountp);
+		if (errno != EINVAL && errno != EFAULT)
+			exit(1);
+
+		exitcode = 1;
+	}
+
+	exit(exitcode);
+}
+
+void
+rpterr(char *sp)
+{
+	switch (errno) {
+	case EPERM:
+		fprintf(stderr, "%s: permission denied\n", myname);
+		break;
+	case ENXIO:
+		fprintf(stderr, "%s: %s no device\n", myname, sp);
+		break;
+	case ENOENT:
+		fprintf(stderr, "%s: %s no such file or directory\n",
+		    myname, sp);
+		break;
+	case EINVAL:
+		fprintf(stderr, "%s: %s not mounted\n", myname, sp);
+		break;
+	case EBUSY:
+		fprintf(stderr, "%s: %s busy\n", myname, sp);
+		break;
+	case ENOTBLK:
+		fprintf(stderr, "%s: %s block device required\n", myname, sp);
+		break;
+	case ECOMM:
+		fprintf(stderr, "%s: warning: broken link detected\n", myname);
+		break;
+	default:
+		perror(myname);
+		fprintf(stderr, "%s: cannot unmount %s\n", myname, sp);
+	}
+}
+
+void
+mnterror(int flag)
+{
+	switch (flag) {
+	case MNT_TOOLONG:
+		fprintf(stderr,
+		    "%s: line in mnttab exceeds %d characters\n",
+		    myname, MNT_LINE_MAX-2);
+		break;
+	case MNT_TOOFEW:
+		fprintf(stderr,
+		    "%s: line in mnttab has too few entries\n",
+		    myname);
+		break;
+	default:
+		break;
+	}
+}
+
+/*
+ * Search the mlist linked list for the
+ * first match of specp or mntp.  The list is expected to be in reverse
+ * order of /etc/mnttab.
+ * If both are specified, then both have to match.
+ * Returns the (mountent_t *) of the match, otherwise returns NULL.
+ */
+mountent_t *
+getmntlast(mountent_t *mlist, char *specp, char *mntp)
+{
+	int		mfound, sfound;
+
+	for (/* */; mlist; mlist = mlist->link) {
+		mfound = sfound = 0;
+		if (mntp && (strcmp(mlist->ment.mnt_mountp, mntp) == 0)) {
+			if (specp == NULL)
+				return (mlist);
+			mfound++;
+		}
+		if (specp && (strcmp(mlist->ment.mnt_special, specp) == 0)) {
+			if (mntp == NULL)
+				return (mlist);
+			sfound++;
+		}
+		if (mfound && sfound)
+			return (mlist);
+	}
+	return (NULL);
+}
+
+
+
+/*
+ * Perform the parallel version of umount.  Returns 0 if no errors occurred,
+ * non zero otherwise.
+ */
+int
+parumount(char **mntlist, int count)
+{
+	int 		maxfd = OPEN_MAX;
+	struct rlimit 	rl;
+	mountent_t	**mntarray, **ml, *mp;
+
+	/*
+	 * If no mount points are specified and none were found in mnttab,
+	 * then end it all here.
+	 */
+	if (count == 0 && mntll == NULL)
+		return (0);
+
+	/*
+	 * This is the process scaling section.  After running a series
+	 * of tests based on the number of simultaneous processes and
+	 * processors available, optimum performance was achieved near or
+	 * at (PROCN * 2).
+	 */
+	if ((maxrun = sysconf(_SC_NPROCESSORS_ONLN)) == -1)
+		maxrun = 4;
+	else
+		maxrun = maxrun * 2 + 1;
+
+	if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
+		rl.rlim_cur = rl.rlim_max;
+		if (setrlimit(RLIMIT_NOFILE, &rl) == 0)
+			maxfd = (int)rl.rlim_cur;
+		(void) enable_extended_FILE_stdio(-1, -1);
+	}
+
+	/*
+	 * The parent needs to maintain 3 of its own fd's, plus 2 for
+	 * each child (the stdout and stderr pipes).
+	 */
+	maxfd = (maxfd / 2) - 6;	/* 6 takes care of temporary  */
+					/* periods of open fds */
+	if (maxfd < maxrun)
+		maxrun = maxfd;
+	if (maxrun < 4)
+		maxrun = 4;		/* sanity check */
+
+	mntarray = make_mntarray(mntlist, count);
+
+	if (listlength == 0) {
+		if (count == 0)		/* not an error, just none found */
+			return (0);
+		fprintf(stderr, "%s: no valid entries found in %s\n",
+		    myname, mnttab);
+		return (1);
+	}
+
+	/*
+	 * Sort the entries based on their mount level only if lofs's are
+	 * not present.
+	 */
+	if (lofscnt == 0) {
+		qsort((void *)mntarray, listlength, sizeof (mountent_t *),
+		    mcompar);
+		/*
+		 * If we do not detect a lofs by now, we never will.
+		 */
+		lofscnt = -1;
+	}
+	/*
+	 * Now link them up so that a given pid is easier to find when
+	 * we go to clean up after they are done.
+	 */
+	mntll = mntarray[0];
+	for (ml = mntarray; mp = *ml; /* */)
+		mp->link = *++ml;
+
+	/*
+	 * Try to handle interrupts in a reasonable way.
+	 */
+	sigset(SIGHUP, cleanup);
+	sigset(SIGQUIT, cleanup);
+	sigset(SIGINT, cleanup);
+
+	do_umounts(mntarray);	/* do the umounts */
+	return (exitcode);
+}
+
+/*
+ * Returns a mountent_t array based on mntlist.  If mntlist is NULL, then
+ * it returns all mnttab entries with a few exceptions.  Sets the global
+ * variable listlength to the number of entries in the array.
+ */
+mountent_t **
+make_mntarray(char **mntlist, int count)
+{
+	mountent_t 	*mp, **mpp;
+	int 		ndx;
+	char		*cp;
+
+	if (count > 0)
+		listlength = count;
+
+	mpp = (mountent_t **)malloc(sizeof (*mp) * (listlength + 1));
+	if (mpp == NULL)
+		nomem();
+
+	if (count == 0) {
+		if (mntll == NULL) {	/* no entries? */
+			listlength = 0;
+			return (NULL);
+		}
+		/*
+		 * No mount list specified: take all mnttab mount points
+		 * except for a few cases.
+		 */
+		for (ndx = 0, mp = mntll; mp; mp = mp->link) {
+			if (fsstrinlist(mp->ment.mnt_mountp, keeplist))
+				continue;
+			mp->mlevel = fsgetmlevel(mp->ment.mnt_mountp);
+			if (mp->ment.mnt_fstype &&
+			    (strcmp(mp->ment.mnt_fstype, MNTTYPE_LOFS) == 0))
+				lofscnt++;
+
+			mpp[ndx++] = mp;
+		}
+		mpp[ndx] = NULL;
+		listlength = ndx;
+		return (mpp);
+	}
+
+	/*
+	 * A list of mount points was specified on the command line.
+	 * Build an array out of these.
+	 */
+	for (ndx = 0; count--; ) {
+		cp = *mntlist++;
+		if (realpath(cp, resolve) == NULL) {
+			fprintf(stderr,
+			    "%s: warning: can't resolve %s\n",
+			    myname, cp);
+			exitcode = 1;
+			mp = getmntlast(mntll, NULL, cp); /* try anyways */
+		} else
+			mp = getmntlast(mntll, NULL, resolve);
+		if (mp == NULL) {
+			struct mnttab mnew;
+			/*
+			 * Then we've reached the end without finding
+			 * what we are looking for, but we still have to
+			 * try to umount it: append it to mntarray.
+			 */
+			fprintf(stderr, 
+			    "%s: warning: %s not found in %s\n",
+			    myname, resolve, mnttab);
+			exitcode = 1;
+			mntnull(&mnew);
+			mnew.mnt_special = mnew.mnt_mountp = strdup(resolve);
+			if (mnew.mnt_special == NULL)
+				nomem();
+			mp = new_mountent(&mnew);
+		}
+		if (mp->ment.mnt_fstype &&
+		    (strcmp(mp->ment.mnt_fstype, MNTTYPE_LOFS) == 0))
+			lofscnt++;
+
+		mp->mlevel = fsgetmlevel(mp->ment.mnt_mountp);
+		mpp[ndx++] = mp;
+	}
+	mpp[ndx] = NULL;
+	listlength = ndx;
+	return (mpp);
+}
+
+/*
+ * Returns the tail of a linked list of all mnttab entries.  I.e, it's faster
+ * to return the mnttab in reverse order.
+ * Sets listlength to the number of entries in the list.
+ * Returns NULL if none are found.
+ */
+mountent_t *
+getmntall(void)
+{
+	FILE		*fp;
+	mountent_t	*mtail;
+	int		cnt = 0, ret;
+	struct mnttab	mget;
+
+	if ((fp = fopen(mnttab, "r")) == NULL) {
+		fprintf(stderr, "%s: warning cannot open %s\n",
+		    myname, mnttab);
+		return (0);
+	}
+	mtail = NULL;
+
+	while ((ret = getmntent(fp, &mget)) != -1) {
+		mountent_t	*mp;
+
+		if (ret > 0) {
+			mnterror(ret);
+			continue;
+		}
+
+		mp = new_mountent(&mget);
+		mp->link = mtail;
+		mtail = mp;
+		cnt++;
+	}
+	fclose(fp);
+	if (mtail == NULL) {
+		listlength = 0;
+		return (NULL);
+	}
+	listlength = cnt;
+	return (mtail);
+}
+
+void
+do_umounts(mountent_t **mntarray)
+{
+	mountent_t *mp, *mpprev, **ml = mntarray;
+	int	cnt = listlength;
+
+	/*
+	 * Main loop for the forked children:
+	 */
+	for (mpprev = *ml; mp = *ml; mpprev = mp, ml++, cnt--) {
+		pid_t	pid;
+
+		/*
+		 * Check to see if we cross a mount level: e.g.,
+		 * /a/b/c -> /a/b.  If so, we need to wait for all current
+		 * umounts to finish before umounting the rest.
+		 *
+		 * Also, we unmount serially as long as there are lofs's
+		 * to mount to avoid improper umount ordering.
+		 */
+		if (mp->mlevel < mpprev->mlevel || lofscnt > 0)
+			while (nrun > 0 && (dowait() != -1))
+				;
+
+		if (lofscnt == 0) {
+			/*
+			 * We can now go to parallel umounting.
+			 */
+			qsort((void *)ml, cnt, sizeof (mountent_t *), mcompar);
+			mp = *ml;	/* possible first entry */
+			lofscnt--;	/* so we don't do this again */
+		}
+
+		while (setup_iopipe(mp) == -1 && (dowait() != -1))
+			;
+
+		while (nrun >= maxrun && (dowait() != -1))	/* throttle */
+			;
+
+#ifdef CACHEFS_BUG
+		/*
+		 * If this is the back file system, then let cachefs/umount
+		 * unmount it.
+		 */
+		if (strstr(mp->ment.mnt_mountp, BACKMNT_NAME))
+			continue;
+
+
+		if (mp->ment.mnt_fstype &&
+		    (strcmp(mp->ment.mnt_fstype, "cachefs") == 0)) {
+			while (cachefs_running && (dowait() != -1))
+					;
+			cachefs_running = 1;
+		}
+#endif
+
+		if ((pid = fork()) == -1) {
+			perror("fork");
+			cleanup(-1);
+			/* not reached */
+		}
+		if (pid == 0) {		/* child */
+			signal(SIGHUP, SIG_IGN);
+			signal(SIGQUIT, SIG_IGN);
+			signal(SIGINT, SIG_IGN);
+			setup_output(mp);
+			doexec(&mp->ment);
+			perror("exec");
+			exit(1);
+		}
+
+		/* parent */
+		(void) close(mp->sopipe[WRPIPE]);
+		(void) close(mp->sepipe[WRPIPE]);
+		mp->pid = pid;
+		nrun++;
+	}
+	cleanup(0);
+}
+
+/*
+ * cleanup the existing children and exit with an error
+ * if asig != 0.
+ */
+void
+cleanup(int asig)
+{
+	/*
+	 * Let the stragglers finish.
+	 */
+	while (nrun > 0 && (dowait() != -1))
+		;
+	if (asig != 0)
+		exit(1);
+}
+
+
+/*
+ * Waits for 1 child to die.
+ *
+ * Returns -1 if no children are left to wait for.
+ * Returns 0 if a child died without an error.
+ * Returns 1 if a child died with an error.
+ * Sets the global exitcode if an error occurred.
+ */
+int
+dowait(void)
+{
+	int		wstat, child, ret;
+	mountent_t 	*mp, *prevp;
+
+	if ((child = wait(&wstat)) == -1)
+		return (-1);
+
+	if (WIFEXITED(wstat))		/* this should always be true */
+		ret = WEXITSTATUS(wstat);
+	else
+		ret = 1;		/* assume some kind of error */
+	nrun--;
+	if (ret)
+		exitcode = 1;
+
+	/*
+	 * Find our child so we can process its std output, if any.
+	 * This search gets smaller and smaller as children are cleaned
+	 * up.
+	 */
+	for (prevp = NULL, mp = mntll; mp; mp = mp->link) {
+		if (mp->pid != child) {
+			prevp = mp;
+			continue;
+		}
+		/*
+		 * Found: let's remove it from this list.
+		 */
+		if (prevp) {
+			prevp->link = mp->link;
+			mp->link = NULL;
+		}
+		break;
+	}
+
+	if (mp == NULL) {
+		/*
+		 * This should never happen.
+		 */
+		exitcode = 1;
+		return (1);
+	}
+	doio(mp);	/* Any output? */
+
+	if (mp->ment.mnt_fstype &&
+	    (strcmp(mp->ment.mnt_fstype, MNTTYPE_LOFS) == 0))
+		lofscnt--;
+
+#ifdef CACHEFS_BUG
+	if (mp->ment.mnt_fstype &&
+	    (strcmp(mp->ment.mnt_fstype, "cachefs") == 0))
+		cachefs_running = 0;
+#endif
+
+	return (ret);
+}
+
+static const mountent_t zmount = { 0 };
+
+mountent_t *
+new_mountent(struct mnttab *ment)
+{
+	mountent_t *new;
+
+	new = (mountent_t *)malloc(sizeof (*new));
+	if (new == NULL)
+		nomem();
+
+	*new = zmount;
+	if (ment->mnt_special &&
+	    (new->ment.mnt_special = strdup(ment->mnt_special)) == NULL)
+		nomem();
+	if (ment->mnt_mountp &&
+	    (new->ment.mnt_mountp = strdup(ment->mnt_mountp)) == NULL)
+		nomem();
+	if (ment->mnt_fstype &&
+	    (new->ment.mnt_fstype = strdup(ment->mnt_fstype)) == NULL)
+		nomem();
+	return (new);
+}
+
+
+/*
+ * Sort in descending order of "mount level".  For example, /a/b/c is
+ * placed before /a/b .
+ */
+int
+mcompar(const void *a, const void *b)
+{
+	mountent_t *a1, *b1;
+
+	a1 = *(mountent_t **)a;
+	b1 = *(mountent_t **)b;
+	return (b1->mlevel - a1->mlevel);
+}
+
+/*
+ * The purpose of this routine is to form stdout and stderr
+ * pipes for the children's output.  The parent then reads and writes it
+ * out it serially in order to ensure that the output is
+ * not garbled.
+ */
+
+int
+setup_iopipe(mountent_t *mp)
+{
+	/*
+	 * Make a stdout and stderr pipe.  This should never fail.
+	 */
+	if (pipe(mp->sopipe) == -1)
+		return (-1);
+	if (pipe(mp->sepipe) == -1) {
+		(void) close(mp->sopipe[RDPIPE]);
+		(void) close(mp->sopipe[WRPIPE]);
+		return (-1);
+	}
+	/*
+	 * Don't block on an empty pipe.
+	 */
+	(void) fcntl(mp->sopipe[RDPIPE], F_SETFL, O_NDELAY|O_NONBLOCK);
+	(void) fcntl(mp->sepipe[RDPIPE], F_SETFL, O_NDELAY|O_NONBLOCK);
+	return (0);
+}
+
+/*
+ * Called by a child to attach its stdout and stderr to the write side of
+ * the pipes.
+ */
+void
+setup_output(mountent_t *mp)
+{
+	(void) close(fileno(stdout));
+	(void) dup(mp->sopipe[WRPIPE]);
+	(void) close(mp->sopipe[WRPIPE]);
+
+	(void) close(fileno(stderr));
+	(void) dup(mp->sepipe[WRPIPE]);
+	(void) close(mp->sepipe[WRPIPE]);
+}
+
+/*
+ * Parent uses this to print any stdout or stderr output issued by
+ * the child.
+ */
+static void
+doio(mountent_t *mp)
+{
+	int bytes;
+
+	while ((bytes = read(mp->sepipe[RDPIPE], ibuf, sizeof (ibuf))) > 0)
+		write(fileno(stderr), ibuf, bytes);
+	while ((bytes = read(mp->sopipe[RDPIPE], ibuf, sizeof (ibuf))) > 0)
+		write(fileno(stdout), ibuf, bytes);
+
+	(void) close(mp->sopipe[RDPIPE]);
+	(void) close(mp->sepipe[RDPIPE]);
+}
+
+void
+nomem(void)
+{
+	fprintf(stderr, "%s: out of memory\n", myname);
+	/*
+	 * Let the stragglers finish.
+	 */
+	while (nrun > 0 && (dowait() != -1))
+		;
+	exit(1);
+}
diff -rupN busybox-1.2.0/include/bb_config.h busybox-1.2.0solaris/include/bb_config.h
--- busybox-1.2.0/include/bb_config.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/bb_config.h	2009-04-20 14:06:29.499351717 +0400
@@ -0,0 +1,2685 @@
+#ifndef BB_CONFIG_H
+#define BB_CONFIG_H
+/*
+ * Automatically generated header file: don't edit
+ */
+
+/* Version Number */
+#define BB_VER "1.2.0"
+#define BB_BT "2009.04.20-10:06+0000"
+
+#define HAVE_DOT_CONFIG 1
+#define ENABLE_DOT_CONFIG 1
+#define USE_DOT_CONFIG(...)  __VA_ARGS__
+#define SKIP_DOT_CONFIG(...)
+
+
+/*
+ * Busybox Settings
+ */
+
+/*
+ * General Configuration
+ */
+#undef CONFIG_NITPICK
+#define ENABLE_NITPICK 0
+#define USE_NITPICK(...)
+#define SKIP_NITPICK(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_BUFFERS_USE_MALLOC
+#define ENABLE_FEATURE_BUFFERS_USE_MALLOC 0
+#define USE_FEATURE_BUFFERS_USE_MALLOC(...)
+#define SKIP_FEATURE_BUFFERS_USE_MALLOC(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_BUFFERS_GO_ON_STACK
+#define ENABLE_FEATURE_BUFFERS_GO_ON_STACK 0
+#define USE_FEATURE_BUFFERS_GO_ON_STACK(...)
+#define SKIP_FEATURE_BUFFERS_GO_ON_STACK(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_BUFFERS_GO_IN_BSS
+#define ENABLE_FEATURE_BUFFERS_GO_IN_BSS 0
+#define USE_FEATURE_BUFFERS_GO_IN_BSS(...)
+#define SKIP_FEATURE_BUFFERS_GO_IN_BSS(...)  __VA_ARGS__
+
+#define CONFIG_SHOW_USAGE 1
+#define ENABLE_SHOW_USAGE 1
+#define USE_SHOW_USAGE(...)  __VA_ARGS__
+#define SKIP_SHOW_USAGE(...)
+
+#undef CONFIG_FEATURE_VERBOSE_USAGE
+#define ENABLE_FEATURE_VERBOSE_USAGE 0
+#define USE_FEATURE_VERBOSE_USAGE(...)
+#define SKIP_FEATURE_VERBOSE_USAGE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_COMPRESS_USAGE
+#define ENABLE_FEATURE_COMPRESS_USAGE 0
+#define USE_FEATURE_COMPRESS_USAGE(...)
+#define SKIP_FEATURE_COMPRESS_USAGE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INSTALLER
+#define ENABLE_FEATURE_INSTALLER 0
+#define USE_FEATURE_INSTALLER(...)
+#define SKIP_FEATURE_INSTALLER(...)  __VA_ARGS__
+
+#undef CONFIG_LOCALE_SUPPORT
+#define ENABLE_LOCALE_SUPPORT 0
+#define USE_LOCALE_SUPPORT(...)
+#define SKIP_LOCALE_SUPPORT(...)  __VA_ARGS__
+
+#define CONFIG_GETOPT_LONG 1
+#define ENABLE_GETOPT_LONG 1
+#define USE_GETOPT_LONG(...)  __VA_ARGS__
+#define SKIP_GETOPT_LONG(...)
+
+#undef CONFIG_FEATURE_DEVPTS
+#define ENABLE_FEATURE_DEVPTS 0
+#define USE_FEATURE_DEVPTS(...)
+#define SKIP_FEATURE_DEVPTS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_CLEAN_UP
+#define ENABLE_FEATURE_CLEAN_UP 0
+#define USE_FEATURE_CLEAN_UP(...)
+#define SKIP_FEATURE_CLEAN_UP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SUID
+#define ENABLE_FEATURE_SUID 0
+#define USE_FEATURE_SUID(...)
+#define SKIP_FEATURE_SUID(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SUID_CONFIG
+#define ENABLE_FEATURE_SUID_CONFIG 0
+#define USE_FEATURE_SUID_CONFIG(...)
+#define SKIP_FEATURE_SUID_CONFIG(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SUID_CONFIG_QUIET
+#define ENABLE_FEATURE_SUID_CONFIG_QUIET 0
+#define USE_FEATURE_SUID_CONFIG_QUIET(...)
+#define SKIP_FEATURE_SUID_CONFIG_QUIET(...)  __VA_ARGS__
+
+#undef CONFIG_SELINUX
+#define ENABLE_SELINUX 0
+#define USE_SELINUX(...)
+#define SKIP_SELINUX(...)  __VA_ARGS__
+
+#define CONFIG_BUSYBOX_EXEC_PATH "n"
+#define ENABLE_BUSYBOX_EXEC_PATH 1
+#define USE_BUSYBOX_EXEC_PATH(...)  __VA_ARGS__
+#define SKIP_BUSYBOX_EXEC_PATH(...)
+
+
+/*
+ * Build Options
+ */
+#undef CONFIG_STATIC
+#define ENABLE_STATIC 0
+#define USE_STATIC(...)
+#define SKIP_STATIC(...)  __VA_ARGS__
+
+#undef CONFIG_BUILD_LIBBUSYBOX
+#define ENABLE_BUILD_LIBBUSYBOX 0
+#define USE_BUILD_LIBBUSYBOX(...)
+#define SKIP_BUILD_LIBBUSYBOX(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FULL_LIBBUSYBOX
+#define ENABLE_FEATURE_FULL_LIBBUSYBOX 0
+#define USE_FEATURE_FULL_LIBBUSYBOX(...)
+#define SKIP_FEATURE_FULL_LIBBUSYBOX(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SHARED_BUSYBOX
+#define ENABLE_FEATURE_SHARED_BUSYBOX 0
+#define USE_FEATURE_SHARED_BUSYBOX(...)
+#define SKIP_FEATURE_SHARED_BUSYBOX(...)  __VA_ARGS__
+
+#undef CONFIG_LFS
+#define ENABLE_LFS 0
+#define USE_LFS(...)
+#define SKIP_LFS(...)  __VA_ARGS__
+
+#undef USING_CROSS_COMPILER
+#define ENABLE_CROSS_COMPILER 0
+#define USE_CROSS_COMPILER(...)
+#define SKIP_CROSS_COMPILER(...)  __VA_ARGS__
+
+#define CROSS_COMPILER_PREFIX ""
+#define ENABLE_COMPILER_PREFIX 1
+#define USE_COMPILER_PREFIX(...)  __VA_ARGS__
+#define SKIP_COMPILER_PREFIX(...)
+
+#undef CONFIG_BUILD_AT_ONCE
+#define ENABLE_BUILD_AT_ONCE 0
+#define USE_BUILD_AT_ONCE(...)
+#define SKIP_BUILD_AT_ONCE(...)  __VA_ARGS__
+
+
+/*
+ * Debugging Options
+ */
+#undef CONFIG_DEBUG
+#define ENABLE_DEBUG 0
+#define USE_DEBUG(...)
+#define SKIP_DEBUG(...)  __VA_ARGS__
+
+#undef CONFIG_DEBUG_PESSIMIZE
+#define ENABLE_DEBUG_PESSIMIZE 0
+#define USE_DEBUG_PESSIMIZE(...)
+#define SKIP_DEBUG_PESSIMIZE(...)  __VA_ARGS__
+
+#undef CONFIG_NO_DEBUG_LIB
+#define ENABLE_NO_DEBUG_LIB 0
+#define USE_NO_DEBUG_LIB(...)
+#define SKIP_NO_DEBUG_LIB(...)  __VA_ARGS__
+
+#undef CONFIG_DMALLOC
+#define ENABLE_DMALLOC 0
+#define USE_DMALLOC(...)
+#define SKIP_DMALLOC(...)  __VA_ARGS__
+
+#undef CONFIG_EFENCE
+#define ENABLE_EFENCE 0
+#define USE_EFENCE(...)
+#define SKIP_EFENCE(...)  __VA_ARGS__
+
+#define CONFIG_DEBUG_YANK_SUSv2 1
+#define ENABLE_DEBUG_YANK_SUSv2 1
+#define USE_DEBUG_YANK_SUSv2(...)  __VA_ARGS__
+#define SKIP_DEBUG_YANK_SUSv2(...)
+
+
+/*
+ * Installation Options
+ */
+#undef CONFIG_INSTALL_NO_USR
+#define ENABLE_INSTALL_NO_USR 0
+#define USE_INSTALL_NO_USR(...)
+#define SKIP_INSTALL_NO_USR(...)  __VA_ARGS__
+
+#define CONFIG_INSTALL_APPLET_SYMLINKS 1
+#define ENABLE_INSTALL_APPLET_SYMLINKS 1
+#define USE_INSTALL_APPLET_SYMLINKS(...)  __VA_ARGS__
+#define SKIP_INSTALL_APPLET_SYMLINKS(...)
+
+#undef CONFIG_INSTALL_APPLET_HARDLINKS
+#define ENABLE_INSTALL_APPLET_HARDLINKS 0
+#define USE_INSTALL_APPLET_HARDLINKS(...)
+#define SKIP_INSTALL_APPLET_HARDLINKS(...)  __VA_ARGS__
+
+#undef CONFIG_INSTALL_APPLET_DONT
+#define ENABLE_INSTALL_APPLET_DONT 0
+#define USE_INSTALL_APPLET_DONT(...)
+#define SKIP_INSTALL_APPLET_DONT(...)  __VA_ARGS__
+
+#define PREFIX "./_install"
+#define ENABLE_PREFIX 1
+#define USE_PREFIX(...)  __VA_ARGS__
+#define SKIP_PREFIX(...)
+
+
+/*
+ * Busybox Library Tuning
+ */
+#define CONFIG_MD5_SIZE_VS_SPEED 2
+#define ENABLE_MD5_SIZE_VS_SPEED 1
+#define USE_MD5_SIZE_VS_SPEED(...)  __VA_ARGS__
+#define SKIP_MD5_SIZE_VS_SPEED(...)
+
+
+/*
+ * Applets
+ */
+
+/*
+ * Archival Utilities
+ */
+#undef CONFIG_AR
+#define ENABLE_AR 0
+#define USE_AR(...)
+#define SKIP_AR(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_AR_LONG_FILENAMES
+#define ENABLE_FEATURE_AR_LONG_FILENAMES 0
+#define USE_FEATURE_AR_LONG_FILENAMES(...)
+#define SKIP_FEATURE_AR_LONG_FILENAMES(...)  __VA_ARGS__
+
+#define CONFIG_BUNZIP2 1
+#define ENABLE_BUNZIP2 1
+#define USE_BUNZIP2(...)  __VA_ARGS__
+#define SKIP_BUNZIP2(...)
+
+#define CONFIG_CPIO 1
+#define ENABLE_CPIO 1
+#define USE_CPIO(...)  __VA_ARGS__
+#define SKIP_CPIO(...)
+
+#undef CONFIG_DPKG
+#define ENABLE_DPKG 0
+#define USE_DPKG(...)
+#define SKIP_DPKG(...)  __VA_ARGS__
+
+#undef CONFIG_DPKG_DEB
+#define ENABLE_DPKG_DEB 0
+#define USE_DPKG_DEB(...)
+#define SKIP_DPKG_DEB(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_DPKG_DEB_EXTRACT_ONLY
+#define ENABLE_FEATURE_DPKG_DEB_EXTRACT_ONLY 0
+#define USE_FEATURE_DPKG_DEB_EXTRACT_ONLY(...)
+#define SKIP_FEATURE_DPKG_DEB_EXTRACT_ONLY(...)  __VA_ARGS__
+
+#define CONFIG_GUNZIP 1
+#define ENABLE_GUNZIP 1
+#define USE_GUNZIP(...)  __VA_ARGS__
+#define SKIP_GUNZIP(...)
+
+#undef CONFIG_FEATURE_GUNZIP_UNCOMPRESS
+#define ENABLE_FEATURE_GUNZIP_UNCOMPRESS 0
+#define USE_FEATURE_GUNZIP_UNCOMPRESS(...)
+#define SKIP_FEATURE_GUNZIP_UNCOMPRESS(...)  __VA_ARGS__
+
+#define CONFIG_GZIP 1
+#define ENABLE_GZIP 1
+#define USE_GZIP(...)  __VA_ARGS__
+#define SKIP_GZIP(...)
+
+#undef CONFIG_RPM2CPIO
+#define ENABLE_RPM2CPIO 0
+#define USE_RPM2CPIO(...)
+#define SKIP_RPM2CPIO(...)  __VA_ARGS__
+
+#undef CONFIG_RPM
+#define ENABLE_RPM 0
+#define USE_RPM(...)
+#define SKIP_RPM(...)  __VA_ARGS__
+
+#define CONFIG_TAR 1
+#define ENABLE_TAR 1
+#define USE_TAR(...)  __VA_ARGS__
+#define SKIP_TAR(...)
+
+#define CONFIG_FEATURE_TAR_CREATE 1
+#define ENABLE_FEATURE_TAR_CREATE 1
+#define USE_FEATURE_TAR_CREATE(...)  __VA_ARGS__
+#define SKIP_FEATURE_TAR_CREATE(...)
+
+#undef CONFIG_FEATURE_TAR_BZIP2
+#define ENABLE_FEATURE_TAR_BZIP2 0
+#define USE_FEATURE_TAR_BZIP2(...)
+#define SKIP_FEATURE_TAR_BZIP2(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TAR_LZMA
+#define ENABLE_FEATURE_TAR_LZMA 0
+#define USE_FEATURE_TAR_LZMA(...)
+#define SKIP_FEATURE_TAR_LZMA(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TAR_FROM
+#define ENABLE_FEATURE_TAR_FROM 0
+#define USE_FEATURE_TAR_FROM(...)
+#define SKIP_FEATURE_TAR_FROM(...)  __VA_ARGS__
+
+#define CONFIG_FEATURE_TAR_GZIP 1
+#define ENABLE_FEATURE_TAR_GZIP 1
+#define USE_FEATURE_TAR_GZIP(...)  __VA_ARGS__
+#define SKIP_FEATURE_TAR_GZIP(...)
+
+#undef CONFIG_FEATURE_TAR_COMPRESS
+#define ENABLE_FEATURE_TAR_COMPRESS 0
+#define USE_FEATURE_TAR_COMPRESS(...)
+#define SKIP_FEATURE_TAR_COMPRESS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY
+#define ENABLE_FEATURE_TAR_OLDGNU_COMPATIBILITY 0
+#define USE_FEATURE_TAR_OLDGNU_COMPATIBILITY(...)
+#define SKIP_FEATURE_TAR_OLDGNU_COMPATIBILITY(...)  __VA_ARGS__
+
+#define CONFIG_FEATURE_TAR_GNU_EXTENSIONS 1
+#define ENABLE_FEATURE_TAR_GNU_EXTENSIONS 1
+#define USE_FEATURE_TAR_GNU_EXTENSIONS(...)  __VA_ARGS__
+#define SKIP_FEATURE_TAR_GNU_EXTENSIONS(...)
+
+#undef CONFIG_FEATURE_TAR_LONG_OPTIONS
+#define ENABLE_FEATURE_TAR_LONG_OPTIONS 0
+#define USE_FEATURE_TAR_LONG_OPTIONS(...)
+#define SKIP_FEATURE_TAR_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_UNCOMPRESS
+#define ENABLE_UNCOMPRESS 0
+#define USE_UNCOMPRESS(...)
+#define SKIP_UNCOMPRESS(...)  __VA_ARGS__
+
+#undef CONFIG_UNLZMA
+#define ENABLE_UNLZMA 0
+#define USE_UNLZMA(...)
+#define SKIP_UNLZMA(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_LZMA_FAST
+#define ENABLE_FEATURE_LZMA_FAST 0
+#define USE_FEATURE_LZMA_FAST(...)
+#define SKIP_FEATURE_LZMA_FAST(...)  __VA_ARGS__
+
+#define CONFIG_UNZIP 1
+#define ENABLE_UNZIP 1
+#define USE_UNZIP(...)  __VA_ARGS__
+#define SKIP_UNZIP(...)
+
+
+/*
+ * Common options for cpio and tar
+ */
+#undef CONFIG_FEATURE_UNARCHIVE_TAPE
+#define ENABLE_FEATURE_UNARCHIVE_TAPE 0
+#define USE_FEATURE_UNARCHIVE_TAPE(...)
+#define SKIP_FEATURE_UNARCHIVE_TAPE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_DEB_TAR_GZ
+#define ENABLE_FEATURE_DEB_TAR_GZ 0
+#define USE_FEATURE_DEB_TAR_GZ(...)
+#define SKIP_FEATURE_DEB_TAR_GZ(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_DEB_TAR_BZ2
+#define ENABLE_FEATURE_DEB_TAR_BZ2 0
+#define USE_FEATURE_DEB_TAR_BZ2(...)
+#define SKIP_FEATURE_DEB_TAR_BZ2(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_DEB_TAR_LZMA
+#define ENABLE_FEATURE_DEB_TAR_LZMA 0
+#define USE_FEATURE_DEB_TAR_LZMA(...)
+#define SKIP_FEATURE_DEB_TAR_LZMA(...)  __VA_ARGS__
+
+
+/*
+ * Coreutils
+ */
+#undef CONFIG_BASENAME
+#define ENABLE_BASENAME 0
+#define USE_BASENAME(...)
+#define SKIP_BASENAME(...)  __VA_ARGS__
+
+#undef CONFIG_CAL
+#define ENABLE_CAL 0
+#define USE_CAL(...)
+#define SKIP_CAL(...)  __VA_ARGS__
+
+#define CONFIG_CAT 1
+#define ENABLE_CAT 1
+#define USE_CAT(...)  __VA_ARGS__
+#define SKIP_CAT(...)
+
+#undef CONFIG_CATV
+#define ENABLE_CATV 0
+#define USE_CATV(...)
+#define SKIP_CATV(...)  __VA_ARGS__
+
+#define CONFIG_CHGRP 1
+#define ENABLE_CHGRP 1
+#define USE_CHGRP(...)  __VA_ARGS__
+#define SKIP_CHGRP(...)
+
+#define CONFIG_CHMOD 1
+#define ENABLE_CHMOD 1
+#define USE_CHMOD(...)  __VA_ARGS__
+#define SKIP_CHMOD(...)
+
+#define CONFIG_CHOWN 1
+#define ENABLE_CHOWN 1
+#define USE_CHOWN(...)  __VA_ARGS__
+#define SKIP_CHOWN(...)
+
+#define CONFIG_CHROOT 1
+#define ENABLE_CHROOT 1
+#define USE_CHROOT(...)  __VA_ARGS__
+#define SKIP_CHROOT(...)
+
+#undef CONFIG_CKSUM
+#define ENABLE_CKSUM 0
+#define USE_CKSUM(...)
+#define SKIP_CKSUM(...)  __VA_ARGS__
+
+#undef CONFIG_CMP
+#define ENABLE_CMP 0
+#define USE_CMP(...)
+#define SKIP_CMP(...)  __VA_ARGS__
+
+#undef CONFIG_COMM
+#define ENABLE_COMM 0
+#define USE_COMM(...)
+#define SKIP_COMM(...)  __VA_ARGS__
+
+#define CONFIG_CP 1
+#define ENABLE_CP 1
+#define USE_CP(...)  __VA_ARGS__
+#define SKIP_CP(...)
+
+#define CONFIG_CUT 1
+#define ENABLE_CUT 1
+#define USE_CUT(...)  __VA_ARGS__
+#define SKIP_CUT(...)
+
+#define CONFIG_DATE 1
+#define ENABLE_DATE 1
+#define USE_DATE(...)  __VA_ARGS__
+#define SKIP_DATE(...)
+
+#define CONFIG_FEATURE_DATE_ISOFMT 1
+#define ENABLE_FEATURE_DATE_ISOFMT 1
+#define USE_FEATURE_DATE_ISOFMT(...)  __VA_ARGS__
+#define SKIP_FEATURE_DATE_ISOFMT(...)
+
+#define CONFIG_DD 1
+#define ENABLE_DD 1
+#define USE_DD(...)  __VA_ARGS__
+#define SKIP_DD(...)
+
+#define CONFIG_FEATURE_DD_SIGNAL_HANDLING 1
+#define ENABLE_FEATURE_DD_SIGNAL_HANDLING 1
+#define USE_FEATURE_DD_SIGNAL_HANDLING(...)  __VA_ARGS__
+#define SKIP_FEATURE_DD_SIGNAL_HANDLING(...)
+
+#undef CONFIG_FEATURE_DD_IBS_OBS
+#define ENABLE_FEATURE_DD_IBS_OBS 0
+#define USE_FEATURE_DD_IBS_OBS(...)
+#define SKIP_FEATURE_DD_IBS_OBS(...)  __VA_ARGS__
+
+#define CONFIG_DF 1
+#define ENABLE_DF 1
+#define USE_DF(...)  __VA_ARGS__
+#define SKIP_DF(...)
+
+#undef CONFIG_DIFF
+#define ENABLE_DIFF 0
+#define USE_DIFF(...)
+#define SKIP_DIFF(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_DIFF_BINARY
+#define ENABLE_FEATURE_DIFF_BINARY 0
+#define USE_FEATURE_DIFF_BINARY(...)
+#define SKIP_FEATURE_DIFF_BINARY(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_DIFF_DIR
+#define ENABLE_FEATURE_DIFF_DIR 0
+#define USE_FEATURE_DIFF_DIR(...)
+#define SKIP_FEATURE_DIFF_DIR(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_DIFF_MINIMAL
+#define ENABLE_FEATURE_DIFF_MINIMAL 0
+#define USE_FEATURE_DIFF_MINIMAL(...)
+#define SKIP_FEATURE_DIFF_MINIMAL(...)  __VA_ARGS__
+
+#undef CONFIG_DIRNAME
+#define ENABLE_DIRNAME 0
+#define USE_DIRNAME(...)
+#define SKIP_DIRNAME(...)  __VA_ARGS__
+
+#undef CONFIG_DOS2UNIX
+#define ENABLE_DOS2UNIX 0
+#define USE_DOS2UNIX(...)
+#define SKIP_DOS2UNIX(...)  __VA_ARGS__
+
+#undef CONFIG_UNIX2DOS
+#define ENABLE_UNIX2DOS 0
+#define USE_UNIX2DOS(...)
+#define SKIP_UNIX2DOS(...)  __VA_ARGS__
+
+#define CONFIG_DU 1
+#define ENABLE_DU 1
+#define USE_DU(...)  __VA_ARGS__
+#define SKIP_DU(...)
+
+#define CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K 1
+#define ENABLE_FEATURE_DU_DEFAULT_BLOCKSIZE_1K 1
+#define USE_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(...)  __VA_ARGS__
+#define SKIP_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(...)
+
+#define CONFIG_ECHO 1
+#define ENABLE_ECHO 1
+#define USE_ECHO(...)  __VA_ARGS__
+#define SKIP_ECHO(...)
+
+#define CONFIG_FEATURE_FANCY_ECHO 1
+#define ENABLE_FEATURE_FANCY_ECHO 1
+#define USE_FEATURE_FANCY_ECHO(...)  __VA_ARGS__
+#define SKIP_FEATURE_FANCY_ECHO(...)
+
+#define CONFIG_ENV 1
+#define ENABLE_ENV 1
+#define USE_ENV(...)  __VA_ARGS__
+#define SKIP_ENV(...)
+
+#undef CONFIG_FEATURE_ENV_LONG_OPTIONS
+#define ENABLE_FEATURE_ENV_LONG_OPTIONS 0
+#define USE_FEATURE_ENV_LONG_OPTIONS(...)
+#define SKIP_FEATURE_ENV_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_EXPR
+#define ENABLE_EXPR 0
+#define USE_EXPR(...)
+#define SKIP_EXPR(...)  __VA_ARGS__
+
+#undef CONFIG_EXPR_MATH_SUPPORT_64
+#define ENABLE_EXPR_MATH_SUPPORT_64 0
+#define USE_EXPR_MATH_SUPPORT_64(...)
+#define SKIP_EXPR_MATH_SUPPORT_64(...)  __VA_ARGS__
+
+#define CONFIG_FALSE 1
+#define ENABLE_FALSE 1
+#define USE_FALSE(...)  __VA_ARGS__
+#define SKIP_FALSE(...)
+
+#undef CONFIG_FOLD
+#define ENABLE_FOLD 0
+#define USE_FOLD(...)
+#define SKIP_FOLD(...)  __VA_ARGS__
+
+#define CONFIG_HEAD 1
+#define ENABLE_HEAD 1
+#define USE_HEAD(...)  __VA_ARGS__
+#define SKIP_HEAD(...)
+
+#undef CONFIG_FEATURE_FANCY_HEAD
+#define ENABLE_FEATURE_FANCY_HEAD 0
+#define USE_FEATURE_FANCY_HEAD(...)
+#define SKIP_FEATURE_FANCY_HEAD(...)  __VA_ARGS__
+
+#define CONFIG_HOSTID 1
+#define ENABLE_HOSTID 1
+#define USE_HOSTID(...)  __VA_ARGS__
+#define SKIP_HOSTID(...)
+
+#define CONFIG_ID 1
+#define ENABLE_ID 1
+#define USE_ID(...)  __VA_ARGS__
+#define SKIP_ID(...)
+
+#undef CONFIG_INSTALL
+#define ENABLE_INSTALL 0
+#define USE_INSTALL(...)
+#define SKIP_INSTALL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INSTALL_LONG_OPTIONS
+#define ENABLE_FEATURE_INSTALL_LONG_OPTIONS 0
+#define USE_FEATURE_INSTALL_LONG_OPTIONS(...)
+#define SKIP_FEATURE_INSTALL_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_LENGTH
+#define ENABLE_LENGTH 0
+#define USE_LENGTH(...)
+#define SKIP_LENGTH(...)  __VA_ARGS__
+
+#undef CONFIG_LN
+#define ENABLE_LN 0
+#define USE_LN(...)
+#define SKIP_LN(...)  __VA_ARGS__
+
+#undef CONFIG_LOGNAME
+#define ENABLE_LOGNAME 0
+#define USE_LOGNAME(...)
+#define SKIP_LOGNAME(...)  __VA_ARGS__
+
+#define CONFIG_LS 1
+#define ENABLE_LS 1
+#define USE_LS(...)  __VA_ARGS__
+#define SKIP_LS(...)
+
+#define CONFIG_FEATURE_LS_FILETYPES 1
+#define ENABLE_FEATURE_LS_FILETYPES 1
+#define USE_FEATURE_LS_FILETYPES(...)  __VA_ARGS__
+#define SKIP_FEATURE_LS_FILETYPES(...)
+
+#define CONFIG_FEATURE_LS_FOLLOWLINKS 1
+#define ENABLE_FEATURE_LS_FOLLOWLINKS 1
+#define USE_FEATURE_LS_FOLLOWLINKS(...)  __VA_ARGS__
+#define SKIP_FEATURE_LS_FOLLOWLINKS(...)
+
+#define CONFIG_FEATURE_LS_RECURSIVE 1
+#define ENABLE_FEATURE_LS_RECURSIVE 1
+#define USE_FEATURE_LS_RECURSIVE(...)  __VA_ARGS__
+#define SKIP_FEATURE_LS_RECURSIVE(...)
+
+#define CONFIG_FEATURE_LS_SORTFILES 1
+#define ENABLE_FEATURE_LS_SORTFILES 1
+#define USE_FEATURE_LS_SORTFILES(...)  __VA_ARGS__
+#define SKIP_FEATURE_LS_SORTFILES(...)
+
+#define CONFIG_FEATURE_LS_TIMESTAMPS 1
+#define ENABLE_FEATURE_LS_TIMESTAMPS 1
+#define USE_FEATURE_LS_TIMESTAMPS(...)  __VA_ARGS__
+#define SKIP_FEATURE_LS_TIMESTAMPS(...)
+
+#define CONFIG_FEATURE_LS_USERNAME 1
+#define ENABLE_FEATURE_LS_USERNAME 1
+#define USE_FEATURE_LS_USERNAME(...)  __VA_ARGS__
+#define SKIP_FEATURE_LS_USERNAME(...)
+
+#define CONFIG_FEATURE_LS_COLOR 1
+#define ENABLE_FEATURE_LS_COLOR 1
+#define USE_FEATURE_LS_COLOR(...)  __VA_ARGS__
+#define SKIP_FEATURE_LS_COLOR(...)
+
+#undef CONFIG_FEATURE_LS_COLOR_IS_DEFAULT
+#define ENABLE_FEATURE_LS_COLOR_IS_DEFAULT 0
+#define USE_FEATURE_LS_COLOR_IS_DEFAULT(...)
+#define SKIP_FEATURE_LS_COLOR_IS_DEFAULT(...)  __VA_ARGS__
+
+#define CONFIG_MD5SUM 1
+#define ENABLE_MD5SUM 1
+#define USE_MD5SUM(...)  __VA_ARGS__
+#define SKIP_MD5SUM(...)
+
+#define CONFIG_MKDIR 1
+#define ENABLE_MKDIR 1
+#define USE_MKDIR(...)  __VA_ARGS__
+#define SKIP_MKDIR(...)
+
+#undef CONFIG_FEATURE_MKDIR_LONG_OPTIONS
+#define ENABLE_FEATURE_MKDIR_LONG_OPTIONS 0
+#define USE_FEATURE_MKDIR_LONG_OPTIONS(...)
+#define SKIP_FEATURE_MKDIR_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_MKFIFO
+#define ENABLE_MKFIFO 0
+#define USE_MKFIFO(...)
+#define SKIP_MKFIFO(...)  __VA_ARGS__
+
+#define CONFIG_MKNOD 1
+#define ENABLE_MKNOD 1
+#define USE_MKNOD(...)  __VA_ARGS__
+#define SKIP_MKNOD(...)
+
+#define CONFIG_MOUNT 1
+#define ENABLE_MOUNT 1
+#define USE_MOUNT(...)  __VA_ARGS__
+#define SKIP_MOUNT(...)
+
+#define CONFIG_MV 1
+#define ENABLE_MV 1
+#define USE_MV(...)  __VA_ARGS__
+#define SKIP_MV(...)
+
+#undef CONFIG_FEATURE_MV_LONG_OPTIONS
+#define ENABLE_FEATURE_MV_LONG_OPTIONS 0
+#define USE_FEATURE_MV_LONG_OPTIONS(...)
+#define SKIP_FEATURE_MV_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_NICE
+#define ENABLE_NICE 0
+#define USE_NICE(...)
+#define SKIP_NICE(...)  __VA_ARGS__
+
+#undef CONFIG_NOHUP
+#define ENABLE_NOHUP 0
+#define USE_NOHUP(...)
+#define SKIP_NOHUP(...)  __VA_ARGS__
+
+#undef CONFIG_OD
+#define ENABLE_OD 0
+#define USE_OD(...)
+#define SKIP_OD(...)  __VA_ARGS__
+
+#undef CONFIG_PRINTENV
+#define ENABLE_PRINTENV 0
+#define USE_PRINTENV(...)
+#define SKIP_PRINTENV(...)  __VA_ARGS__
+
+#define CONFIG_PRINTF 1
+#define ENABLE_PRINTF 1
+#define USE_PRINTF(...)  __VA_ARGS__
+#define SKIP_PRINTF(...)
+
+#define CONFIG_PWD 1
+#define ENABLE_PWD 1
+#define USE_PWD(...)  __VA_ARGS__
+#define SKIP_PWD(...)
+
+#undef CONFIG_REALPATH
+#define ENABLE_REALPATH 0
+#define USE_REALPATH(...)
+#define SKIP_REALPATH(...)  __VA_ARGS__
+
+#define CONFIG_RM 1
+#define ENABLE_RM 1
+#define USE_RM(...)  __VA_ARGS__
+#define SKIP_RM(...)
+
+#undef CONFIG_RMDIR
+#define ENABLE_RMDIR 0
+#define USE_RMDIR(...)
+#define SKIP_RMDIR(...)  __VA_ARGS__
+
+#undef CONFIG_SEQ
+#define ENABLE_SEQ 0
+#define USE_SEQ(...)
+#define SKIP_SEQ(...)  __VA_ARGS__
+
+#undef CONFIG_SHA1SUM
+#define ENABLE_SHA1SUM 0
+#define USE_SHA1SUM(...)
+#define SKIP_SHA1SUM(...)  __VA_ARGS__
+
+#define CONFIG_SLEEP 1
+#define ENABLE_SLEEP 1
+#define USE_SLEEP(...)  __VA_ARGS__
+#define SKIP_SLEEP(...)
+
+#undef CONFIG_FEATURE_FANCY_SLEEP
+#define ENABLE_FEATURE_FANCY_SLEEP 0
+#define USE_FEATURE_FANCY_SLEEP(...)
+#define SKIP_FEATURE_FANCY_SLEEP(...)  __VA_ARGS__
+
+#define CONFIG_SORT 1
+#define ENABLE_SORT 1
+#define USE_SORT(...)  __VA_ARGS__
+#define SKIP_SORT(...)
+
+#define CONFIG_FEATURE_SORT_BIG 1
+#define ENABLE_FEATURE_SORT_BIG 1
+#define USE_FEATURE_SORT_BIG(...)  __VA_ARGS__
+#define SKIP_FEATURE_SORT_BIG(...)
+
+#undef CONFIG_STAT
+#define ENABLE_STAT 0
+#define USE_STAT(...)
+#define SKIP_STAT(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_STAT_FORMAT
+#define ENABLE_FEATURE_STAT_FORMAT 0
+#define USE_FEATURE_STAT_FORMAT(...)
+#define SKIP_FEATURE_STAT_FORMAT(...)  __VA_ARGS__
+
+#undef CONFIG_STTY
+#define ENABLE_STTY 0
+#define USE_STTY(...)
+#define SKIP_STTY(...)  __VA_ARGS__
+
+#undef CONFIG_SUM
+#define ENABLE_SUM 0
+#define USE_SUM(...)
+#define SKIP_SUM(...)  __VA_ARGS__
+
+#undef CONFIG_SYNC
+#define ENABLE_SYNC 0
+#define USE_SYNC(...)
+#define SKIP_SYNC(...)  __VA_ARGS__
+
+#undef CONFIG_TAIL
+#define ENABLE_TAIL 0
+#define USE_TAIL(...)
+#define SKIP_TAIL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FANCY_TAIL
+#define ENABLE_FEATURE_FANCY_TAIL 0
+#define USE_FEATURE_FANCY_TAIL(...)
+#define SKIP_FEATURE_FANCY_TAIL(...)  __VA_ARGS__
+
+#define CONFIG_TEE 1
+#define ENABLE_TEE 1
+#define USE_TEE(...)  __VA_ARGS__
+#define SKIP_TEE(...)
+
+#undef CONFIG_FEATURE_TEE_USE_BLOCK_IO
+#define ENABLE_FEATURE_TEE_USE_BLOCK_IO 0
+#define USE_FEATURE_TEE_USE_BLOCK_IO(...)
+#define SKIP_FEATURE_TEE_USE_BLOCK_IO(...)  __VA_ARGS__
+
+#define CONFIG_TEST 1
+#define ENABLE_TEST 1
+#define USE_TEST(...)  __VA_ARGS__
+#define SKIP_TEST(...)
+
+#undef CONFIG_FEATURE_TEST_64
+#define ENABLE_FEATURE_TEST_64 0
+#define USE_FEATURE_TEST_64(...)
+#define SKIP_FEATURE_TEST_64(...)  __VA_ARGS__
+
+#define CONFIG_TOUCH 1
+#define ENABLE_TOUCH 1
+#define USE_TOUCH(...)  __VA_ARGS__
+#define SKIP_TOUCH(...)
+
+#define CONFIG_TR 1
+#define ENABLE_TR 1
+#define USE_TR(...)  __VA_ARGS__
+#define SKIP_TR(...)
+
+#undef CONFIG_FEATURE_TR_CLASSES
+#define ENABLE_FEATURE_TR_CLASSES 0
+#define USE_FEATURE_TR_CLASSES(...)
+#define SKIP_FEATURE_TR_CLASSES(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TR_EQUIV
+#define ENABLE_FEATURE_TR_EQUIV 0
+#define USE_FEATURE_TR_EQUIV(...)
+#define SKIP_FEATURE_TR_EQUIV(...)  __VA_ARGS__
+
+#define CONFIG_TRUE 1
+#define ENABLE_TRUE 1
+#define USE_TRUE(...)  __VA_ARGS__
+#define SKIP_TRUE(...)
+
+#define CONFIG_TTY 1
+#define ENABLE_TTY 1
+#define USE_TTY(...)  __VA_ARGS__
+#define SKIP_TTY(...)
+
+#define CONFIG_UMOUNT 1
+#define ENABLE_UMOUNT 1
+#define USE_UMOUNT(...)  __VA_ARGS__
+#define SKIP_UMOUNT(...)
+
+#define CONFIG_UNAME 1
+#define ENABLE_UNAME 1
+#define USE_UNAME(...)  __VA_ARGS__
+#define SKIP_UNAME(...)
+
+#undef CONFIG_UNIQ
+#define ENABLE_UNIQ 0
+#define USE_UNIQ(...)
+#define SKIP_UNIQ(...)  __VA_ARGS__
+
+#undef CONFIG_USLEEP
+#define ENABLE_USLEEP 0
+#define USE_USLEEP(...)
+#define SKIP_USLEEP(...)  __VA_ARGS__
+
+#undef CONFIG_UUDECODE
+#define ENABLE_UUDECODE 0
+#define USE_UUDECODE(...)
+#define SKIP_UUDECODE(...)  __VA_ARGS__
+
+#undef CONFIG_UUENCODE
+#define ENABLE_UUENCODE 0
+#define USE_UUENCODE(...)
+#define SKIP_UUENCODE(...)  __VA_ARGS__
+
+#undef CONFIG_WATCH
+#define ENABLE_WATCH 0
+#define USE_WATCH(...)
+#define SKIP_WATCH(...)  __VA_ARGS__
+
+#define CONFIG_WC 1
+#define ENABLE_WC 1
+#define USE_WC(...)  __VA_ARGS__
+#define SKIP_WC(...)
+
+#undef CONFIG_WHO
+#define ENABLE_WHO 0
+#define USE_WHO(...)
+#define SKIP_WHO(...)  __VA_ARGS__
+
+#define CONFIG_WHOAMI 1
+#define ENABLE_WHOAMI 1
+#define USE_WHOAMI(...)  __VA_ARGS__
+#define SKIP_WHOAMI(...)
+
+#define CONFIG_YES 1
+#define ENABLE_YES 1
+#define USE_YES(...)  __VA_ARGS__
+#define SKIP_YES(...)
+
+
+/*
+ * Common options for cp and mv
+ */
+#undef CONFIG_FEATURE_PRESERVE_HARDLINKS
+#define ENABLE_FEATURE_PRESERVE_HARDLINKS 0
+#define USE_FEATURE_PRESERVE_HARDLINKS(...)
+#define SKIP_FEATURE_PRESERVE_HARDLINKS(...)  __VA_ARGS__
+
+
+/*
+ * Common options for ls, more and telnet
+ */
+#define CONFIG_FEATURE_AUTOWIDTH 1
+#define ENABLE_FEATURE_AUTOWIDTH 1
+#define USE_FEATURE_AUTOWIDTH(...)  __VA_ARGS__
+#define SKIP_FEATURE_AUTOWIDTH(...)
+
+
+/*
+ * Common options for df, du, ls
+ */
+#undef CONFIG_FEATURE_HUMAN_READABLE
+#define ENABLE_FEATURE_HUMAN_READABLE 0
+#define USE_FEATURE_HUMAN_READABLE(...)
+#define SKIP_FEATURE_HUMAN_READABLE(...)  __VA_ARGS__
+
+
+/*
+ * Common options for md5sum, sha1sum
+ */
+#undef CONFIG_FEATURE_MD5_SHA1_SUM_CHECK
+#define ENABLE_FEATURE_MD5_SHA1_SUM_CHECK 0
+#define USE_FEATURE_MD5_SHA1_SUM_CHECK(...)
+#define SKIP_FEATURE_MD5_SHA1_SUM_CHECK(...)  __VA_ARGS__
+
+
+/*
+ * Console Utilities
+ */
+#undef CONFIG_CHVT
+#define ENABLE_CHVT 0
+#define USE_CHVT(...)
+#define SKIP_CHVT(...)  __VA_ARGS__
+
+#define CONFIG_CLEAR 1
+#define ENABLE_CLEAR 1
+#define USE_CLEAR(...)  __VA_ARGS__
+#define SKIP_CLEAR(...)
+
+#undef CONFIG_DEALLOCVT
+#define ENABLE_DEALLOCVT 0
+#define USE_DEALLOCVT(...)
+#define SKIP_DEALLOCVT(...)  __VA_ARGS__
+
+#undef CONFIG_DUMPKMAP
+#define ENABLE_DUMPKMAP 0
+#define USE_DUMPKMAP(...)
+#define SKIP_DUMPKMAP(...)  __VA_ARGS__
+
+#undef CONFIG_LOADFONT
+#define ENABLE_LOADFONT 0
+#define USE_LOADFONT(...)
+#define SKIP_LOADFONT(...)  __VA_ARGS__
+
+#undef CONFIG_LOADKMAP
+#define ENABLE_LOADKMAP 0
+#define USE_LOADKMAP(...)
+#define SKIP_LOADKMAP(...)  __VA_ARGS__
+
+#undef CONFIG_OPENVT
+#define ENABLE_OPENVT 0
+#define USE_OPENVT(...)
+#define SKIP_OPENVT(...)  __VA_ARGS__
+
+#undef CONFIG_RESET
+#define ENABLE_RESET 0
+#define USE_RESET(...)
+#define SKIP_RESET(...)  __VA_ARGS__
+
+#undef CONFIG_SETCONSOLE
+#define ENABLE_SETCONSOLE 0
+#define USE_SETCONSOLE(...)
+#define SKIP_SETCONSOLE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SETCONSOLE_LONG_OPTIONS
+#define ENABLE_FEATURE_SETCONSOLE_LONG_OPTIONS 0
+#define USE_FEATURE_SETCONSOLE_LONG_OPTIONS(...)
+#define SKIP_FEATURE_SETCONSOLE_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_SETKEYCODES
+#define ENABLE_SETKEYCODES 0
+#define USE_SETKEYCODES(...)
+#define SKIP_SETKEYCODES(...)  __VA_ARGS__
+
+#undef CONFIG_SETLOGCONS
+#define ENABLE_SETLOGCONS 0
+#define USE_SETLOGCONS(...)
+#define SKIP_SETLOGCONS(...)  __VA_ARGS__
+
+
+/*
+ * Debian Utilities
+ */
+#undef CONFIG_MKTEMP
+#define ENABLE_MKTEMP 0
+#define USE_MKTEMP(...)
+#define SKIP_MKTEMP(...)  __VA_ARGS__
+
+#undef CONFIG_PIPE_PROGRESS
+#define ENABLE_PIPE_PROGRESS 0
+#define USE_PIPE_PROGRESS(...)
+#define SKIP_PIPE_PROGRESS(...)  __VA_ARGS__
+
+#undef CONFIG_READLINK
+#define ENABLE_READLINK 0
+#define USE_READLINK(...)
+#define SKIP_READLINK(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_READLINK_FOLLOW
+#define ENABLE_FEATURE_READLINK_FOLLOW 0
+#define USE_FEATURE_READLINK_FOLLOW(...)
+#define SKIP_FEATURE_READLINK_FOLLOW(...)  __VA_ARGS__
+
+#undef CONFIG_RUN_PARTS
+#define ENABLE_RUN_PARTS 0
+#define USE_RUN_PARTS(...)
+#define SKIP_RUN_PARTS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_RUN_PARTS_LONG_OPTIONS
+#define ENABLE_FEATURE_RUN_PARTS_LONG_OPTIONS 0
+#define USE_FEATURE_RUN_PARTS_LONG_OPTIONS(...)
+#define SKIP_FEATURE_RUN_PARTS_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_START_STOP_DAEMON
+#define ENABLE_START_STOP_DAEMON 0
+#define USE_START_STOP_DAEMON(...)
+#define SKIP_START_STOP_DAEMON(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_START_STOP_DAEMON_FANCY
+#define ENABLE_FEATURE_START_STOP_DAEMON_FANCY 0
+#define USE_FEATURE_START_STOP_DAEMON_FANCY(...)
+#define SKIP_FEATURE_START_STOP_DAEMON_FANCY(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_START_STOP_DAEMON_LONG_OPTIONS
+#define ENABLE_FEATURE_START_STOP_DAEMON_LONG_OPTIONS 0
+#define USE_FEATURE_START_STOP_DAEMON_LONG_OPTIONS(...)
+#define SKIP_FEATURE_START_STOP_DAEMON_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_WHICH
+#define ENABLE_WHICH 0
+#define USE_WHICH(...)
+#define SKIP_WHICH(...)  __VA_ARGS__
+
+
+/*
+ * Editors
+ */
+#define CONFIG_AWK 1
+#define ENABLE_AWK 1
+#define USE_AWK(...)  __VA_ARGS__
+#define SKIP_AWK(...)
+
+#define CONFIG_FEATURE_AWK_MATH 1
+#define ENABLE_FEATURE_AWK_MATH 1
+#define USE_FEATURE_AWK_MATH(...)  __VA_ARGS__
+#define SKIP_FEATURE_AWK_MATH(...)
+
+#define CONFIG_ED 1
+#define ENABLE_ED 1
+#define USE_ED(...)  __VA_ARGS__
+#define SKIP_ED(...)
+
+#undef CONFIG_PATCH
+#define ENABLE_PATCH 0
+#define USE_PATCH(...)
+#define SKIP_PATCH(...)  __VA_ARGS__
+
+#define CONFIG_SED 1
+#define ENABLE_SED 1
+#define USE_SED(...)  __VA_ARGS__
+#define SKIP_SED(...)
+
+#define CONFIG_VI 1
+#define ENABLE_VI 1
+#define USE_VI(...)  __VA_ARGS__
+#define SKIP_VI(...)
+
+#define CONFIG_FEATURE_VI_COLON 1
+#define ENABLE_FEATURE_VI_COLON 1
+#define USE_FEATURE_VI_COLON(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_COLON(...)
+
+#define CONFIG_FEATURE_VI_YANKMARK 1
+#define ENABLE_FEATURE_VI_YANKMARK 1
+#define USE_FEATURE_VI_YANKMARK(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_YANKMARK(...)
+
+#define CONFIG_FEATURE_VI_SEARCH 1
+#define ENABLE_FEATURE_VI_SEARCH 1
+#define USE_FEATURE_VI_SEARCH(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_SEARCH(...)
+
+#define CONFIG_FEATURE_VI_USE_SIGNALS 1
+#define ENABLE_FEATURE_VI_USE_SIGNALS 1
+#define USE_FEATURE_VI_USE_SIGNALS(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_USE_SIGNALS(...)
+
+#define CONFIG_FEATURE_VI_DOT_CMD 1
+#define ENABLE_FEATURE_VI_DOT_CMD 1
+#define USE_FEATURE_VI_DOT_CMD(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_DOT_CMD(...)
+
+#define CONFIG_FEATURE_VI_READONLY 1
+#define ENABLE_FEATURE_VI_READONLY 1
+#define USE_FEATURE_VI_READONLY(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_READONLY(...)
+
+#define CONFIG_FEATURE_VI_SETOPTS 1
+#define ENABLE_FEATURE_VI_SETOPTS 1
+#define USE_FEATURE_VI_SETOPTS(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_SETOPTS(...)
+
+#define CONFIG_FEATURE_VI_SET 1
+#define ENABLE_FEATURE_VI_SET 1
+#define USE_FEATURE_VI_SET(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_SET(...)
+
+#define CONFIG_FEATURE_VI_WIN_RESIZE 1
+#define ENABLE_FEATURE_VI_WIN_RESIZE 1
+#define USE_FEATURE_VI_WIN_RESIZE(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_WIN_RESIZE(...)
+
+#define CONFIG_FEATURE_VI_OPTIMIZE_CURSOR 1
+#define ENABLE_FEATURE_VI_OPTIMIZE_CURSOR 1
+#define USE_FEATURE_VI_OPTIMIZE_CURSOR(...)  __VA_ARGS__
+#define SKIP_FEATURE_VI_OPTIMIZE_CURSOR(...)
+
+
+/*
+ * Finding Utilities
+ */
+#define CONFIG_FIND 1
+#define ENABLE_FIND 1
+#define USE_FIND(...)  __VA_ARGS__
+#define SKIP_FIND(...)
+
+#define CONFIG_FEATURE_FIND_PRINT0 1
+#define ENABLE_FEATURE_FIND_PRINT0 1
+#define USE_FEATURE_FIND_PRINT0(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_PRINT0(...)
+
+#define CONFIG_FEATURE_FIND_MTIME 1
+#define ENABLE_FEATURE_FIND_MTIME 1
+#define USE_FEATURE_FIND_MTIME(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_MTIME(...)
+
+#define CONFIG_FEATURE_FIND_MMIN 1
+#define ENABLE_FEATURE_FIND_MMIN 1
+#define USE_FEATURE_FIND_MMIN(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_MMIN(...)
+
+#define CONFIG_FEATURE_FIND_PERM 1
+#define ENABLE_FEATURE_FIND_PERM 1
+#define USE_FEATURE_FIND_PERM(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_PERM(...)
+
+#define CONFIG_FEATURE_FIND_TYPE 1
+#define ENABLE_FEATURE_FIND_TYPE 1
+#define USE_FEATURE_FIND_TYPE(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_TYPE(...)
+
+#define CONFIG_FEATURE_FIND_XDEV 1
+#define ENABLE_FEATURE_FIND_XDEV 1
+#define USE_FEATURE_FIND_XDEV(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_XDEV(...)
+
+#define CONFIG_FEATURE_FIND_NEWER 1
+#define ENABLE_FEATURE_FIND_NEWER 1
+#define USE_FEATURE_FIND_NEWER(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_NEWER(...)
+
+#define CONFIG_FEATURE_FIND_INUM 1
+#define ENABLE_FEATURE_FIND_INUM 1
+#define USE_FEATURE_FIND_INUM(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_INUM(...)
+
+#define CONFIG_FEATURE_FIND_EXEC 1
+#define ENABLE_FEATURE_FIND_EXEC 1
+#define USE_FEATURE_FIND_EXEC(...)  __VA_ARGS__
+#define SKIP_FEATURE_FIND_EXEC(...)
+
+#define CONFIG_GREP 1
+#define ENABLE_GREP 1
+#define USE_GREP(...)  __VA_ARGS__
+#define SKIP_GREP(...)
+
+#define CONFIG_FEATURE_GREP_EGREP_ALIAS 1
+#define ENABLE_FEATURE_GREP_EGREP_ALIAS 1
+#define USE_FEATURE_GREP_EGREP_ALIAS(...)  __VA_ARGS__
+#define SKIP_FEATURE_GREP_EGREP_ALIAS(...)
+
+#define CONFIG_FEATURE_GREP_FGREP_ALIAS 1
+#define ENABLE_FEATURE_GREP_FGREP_ALIAS 1
+#define USE_FEATURE_GREP_FGREP_ALIAS(...)  __VA_ARGS__
+#define SKIP_FEATURE_GREP_FGREP_ALIAS(...)
+
+#define CONFIG_FEATURE_GREP_CONTEXT 1
+#define ENABLE_FEATURE_GREP_CONTEXT 1
+#define USE_FEATURE_GREP_CONTEXT(...)  __VA_ARGS__
+#define SKIP_FEATURE_GREP_CONTEXT(...)
+
+#define CONFIG_XARGS 1
+#define ENABLE_XARGS 1
+#define USE_XARGS(...)  __VA_ARGS__
+#define SKIP_XARGS(...)
+
+#undef CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION
+#define ENABLE_FEATURE_XARGS_SUPPORT_CONFIRMATION 0
+#define USE_FEATURE_XARGS_SUPPORT_CONFIRMATION(...)
+#define SKIP_FEATURE_XARGS_SUPPORT_CONFIRMATION(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_XARGS_SUPPORT_QUOTES
+#define ENABLE_FEATURE_XARGS_SUPPORT_QUOTES 0
+#define USE_FEATURE_XARGS_SUPPORT_QUOTES(...)
+#define SKIP_FEATURE_XARGS_SUPPORT_QUOTES(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT
+#define ENABLE_FEATURE_XARGS_SUPPORT_TERMOPT 0
+#define USE_FEATURE_XARGS_SUPPORT_TERMOPT(...)
+#define SKIP_FEATURE_XARGS_SUPPORT_TERMOPT(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM
+#define ENABLE_FEATURE_XARGS_SUPPORT_ZERO_TERM 0
+#define USE_FEATURE_XARGS_SUPPORT_ZERO_TERM(...)
+#define SKIP_FEATURE_XARGS_SUPPORT_ZERO_TERM(...)  __VA_ARGS__
+
+
+/*
+ * Init Utilities
+ */
+#define CONFIG_INIT 1
+#define ENABLE_INIT 1
+#define USE_INIT(...)  __VA_ARGS__
+#define SKIP_INIT(...)
+
+#undef CONFIG_DEBUG_INIT
+#define ENABLE_DEBUG_INIT 0
+#define USE_DEBUG_INIT(...)
+#define SKIP_DEBUG_INIT(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_USE_INITTAB
+#define ENABLE_FEATURE_USE_INITTAB 0
+#define USE_FEATURE_USE_INITTAB(...)
+#define SKIP_FEATURE_USE_INITTAB(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INIT_SCTTY
+#define ENABLE_FEATURE_INIT_SCTTY 0
+#define USE_FEATURE_INIT_SCTTY(...)
+#define SKIP_FEATURE_INIT_SCTTY(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_EXTRA_QUIET
+#define ENABLE_FEATURE_EXTRA_QUIET 0
+#define USE_FEATURE_EXTRA_QUIET(...)
+#define SKIP_FEATURE_EXTRA_QUIET(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INIT_COREDUMPS
+#define ENABLE_FEATURE_INIT_COREDUMPS 0
+#define USE_FEATURE_INIT_COREDUMPS(...)
+#define SKIP_FEATURE_INIT_COREDUMPS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INITRD
+#define ENABLE_FEATURE_INITRD 0
+#define USE_FEATURE_INITRD(...)
+#define SKIP_FEATURE_INITRD(...)  __VA_ARGS__
+
+#define CONFIG_HALT 1
+#define ENABLE_HALT 1
+#define USE_HALT(...)  __VA_ARGS__
+#define SKIP_HALT(...)
+
+#undef CONFIG_MESG
+#define ENABLE_MESG 0
+#define USE_MESG(...)
+#define SKIP_MESG(...)  __VA_ARGS__
+
+
+/*
+ * Login/Password Management Utilities
+ */
+#undef CONFIG_FEATURE_SHADOWPASSWDS
+#define ENABLE_FEATURE_SHADOWPASSWDS 0
+#define USE_FEATURE_SHADOWPASSWDS(...)
+#define SKIP_FEATURE_SHADOWPASSWDS(...)  __VA_ARGS__
+
+#undef CONFIG_USE_BB_SHADOW
+#define ENABLE_USE_BB_SHADOW 0
+#define USE_USE_BB_SHADOW(...)
+#define SKIP_USE_BB_SHADOW(...)  __VA_ARGS__
+
+#undef CONFIG_USE_BB_PWD_GRP
+#define ENABLE_USE_BB_PWD_GRP 0
+#define USE_USE_BB_PWD_GRP(...)
+#define SKIP_USE_BB_PWD_GRP(...)  __VA_ARGS__
+
+#undef CONFIG_ADDGROUP
+#define ENABLE_ADDGROUP 0
+#define USE_ADDGROUP(...)
+#define SKIP_ADDGROUP(...)  __VA_ARGS__
+
+#undef CONFIG_DELGROUP
+#define ENABLE_DELGROUP 0
+#define USE_DELGROUP(...)
+#define SKIP_DELGROUP(...)  __VA_ARGS__
+
+#undef CONFIG_ADDUSER
+#define ENABLE_ADDUSER 0
+#define USE_ADDUSER(...)
+#define SKIP_ADDUSER(...)  __VA_ARGS__
+
+#undef CONFIG_DELUSER
+#define ENABLE_DELUSER 0
+#define USE_DELUSER(...)
+#define SKIP_DELUSER(...)  __VA_ARGS__
+
+#undef CONFIG_GETTY
+#define ENABLE_GETTY 0
+#define USE_GETTY(...)
+#define SKIP_GETTY(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_UTMP
+#define ENABLE_FEATURE_UTMP 0
+#define USE_FEATURE_UTMP(...)
+#define SKIP_FEATURE_UTMP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_WTMP
+#define ENABLE_FEATURE_WTMP 0
+#define USE_FEATURE_WTMP(...)
+#define SKIP_FEATURE_WTMP(...)  __VA_ARGS__
+
+#undef CONFIG_LOGIN
+#define ENABLE_LOGIN 0
+#define USE_LOGIN(...)
+#define SKIP_LOGIN(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SECURETTY
+#define ENABLE_FEATURE_SECURETTY 0
+#define USE_FEATURE_SECURETTY(...)
+#define SKIP_FEATURE_SECURETTY(...)  __VA_ARGS__
+
+#undef CONFIG_PASSWD
+#define ENABLE_PASSWD 0
+#define USE_PASSWD(...)
+#define SKIP_PASSWD(...)  __VA_ARGS__
+
+#undef CONFIG_SU
+#define ENABLE_SU 0
+#define USE_SU(...)
+#define SKIP_SU(...)  __VA_ARGS__
+
+#undef CONFIG_SULOGIN
+#define ENABLE_SULOGIN 0
+#define USE_SULOGIN(...)
+#define SKIP_SULOGIN(...)  __VA_ARGS__
+
+#undef CONFIG_VLOCK
+#define ENABLE_VLOCK 0
+#define USE_VLOCK(...)
+#define SKIP_VLOCK(...)  __VA_ARGS__
+
+
+/*
+ * Linux Ext2 FS Progs
+ */
+#undef CONFIG_CHATTR
+#define ENABLE_CHATTR 0
+#define USE_CHATTR(...)
+#define SKIP_CHATTR(...)  __VA_ARGS__
+
+#undef CONFIG_E2FSCK
+#define ENABLE_E2FSCK 0
+#define USE_E2FSCK(...)
+#define SKIP_E2FSCK(...)  __VA_ARGS__
+
+#undef CONFIG_FSCK
+#define ENABLE_FSCK 0
+#define USE_FSCK(...)
+#define SKIP_FSCK(...)  __VA_ARGS__
+
+#undef CONFIG_LSATTR
+#define ENABLE_LSATTR 0
+#define USE_LSATTR(...)
+#define SKIP_LSATTR(...)  __VA_ARGS__
+
+#undef CONFIG_MKE2FS
+#define ENABLE_MKE2FS 0
+#define USE_MKE2FS(...)
+#define SKIP_MKE2FS(...)  __VA_ARGS__
+
+#undef CONFIG_TUNE2FS
+#define ENABLE_TUNE2FS 0
+#define USE_TUNE2FS(...)
+#define SKIP_TUNE2FS(...)  __VA_ARGS__
+
+#undef CONFIG_E2LABEL
+#define ENABLE_E2LABEL 0
+#define USE_E2LABEL(...)
+#define SKIP_E2LABEL(...)  __VA_ARGS__
+
+#undef CONFIG_FINDFS
+#define ENABLE_FINDFS 0
+#define USE_FINDFS(...)
+#define SKIP_FINDFS(...)  __VA_ARGS__
+
+
+/*
+ * Linux Module Utilities
+ */
+#undef CONFIG_INSMOD
+#define ENABLE_INSMOD 0
+#define USE_INSMOD(...)
+#define SKIP_INSMOD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INSMOD_VERSION_CHECKING
+#define ENABLE_FEATURE_INSMOD_VERSION_CHECKING 0
+#define USE_FEATURE_INSMOD_VERSION_CHECKING(...)
+#define SKIP_FEATURE_INSMOD_VERSION_CHECKING(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS
+#define ENABLE_FEATURE_INSMOD_KSYMOOPS_SYMBOLS 0
+#define USE_FEATURE_INSMOD_KSYMOOPS_SYMBOLS(...)
+#define SKIP_FEATURE_INSMOD_KSYMOOPS_SYMBOLS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INSMOD_LOADINKMEM
+#define ENABLE_FEATURE_INSMOD_LOADINKMEM 0
+#define USE_FEATURE_INSMOD_LOADINKMEM(...)
+#define SKIP_FEATURE_INSMOD_LOADINKMEM(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INSMOD_LOAD_MAP
+#define ENABLE_FEATURE_INSMOD_LOAD_MAP 0
+#define USE_FEATURE_INSMOD_LOAD_MAP(...)
+#define SKIP_FEATURE_INSMOD_LOAD_MAP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL
+#define ENABLE_FEATURE_INSMOD_LOAD_MAP_FULL 0
+#define USE_FEATURE_INSMOD_LOAD_MAP_FULL(...)
+#define SKIP_FEATURE_INSMOD_LOAD_MAP_FULL(...)  __VA_ARGS__
+
+#undef CONFIG_RMMOD
+#define ENABLE_RMMOD 0
+#define USE_RMMOD(...)
+#define SKIP_RMMOD(...)  __VA_ARGS__
+
+#undef CONFIG_LSMOD
+#define ENABLE_LSMOD 0
+#define USE_LSMOD(...)
+#define SKIP_LSMOD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT
+#define ENABLE_FEATURE_LSMOD_PRETTY_2_6_OUTPUT 0
+#define USE_FEATURE_LSMOD_PRETTY_2_6_OUTPUT(...)
+#define SKIP_FEATURE_LSMOD_PRETTY_2_6_OUTPUT(...)  __VA_ARGS__
+
+#undef CONFIG_MODPROBE
+#define ENABLE_MODPROBE 0
+#define USE_MODPROBE(...)
+#define SKIP_MODPROBE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MODPROBE_MULTIPLE_OPTIONS
+#define ENABLE_FEATURE_MODPROBE_MULTIPLE_OPTIONS 0
+#define USE_FEATURE_MODPROBE_MULTIPLE_OPTIONS(...)
+#define SKIP_FEATURE_MODPROBE_MULTIPLE_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_CHECK_TAINTED_MODULE
+#define ENABLE_FEATURE_CHECK_TAINTED_MODULE 0
+#define USE_FEATURE_CHECK_TAINTED_MODULE(...)
+#define SKIP_FEATURE_CHECK_TAINTED_MODULE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_2_4_MODULES
+#define ENABLE_FEATURE_2_4_MODULES 0
+#define USE_FEATURE_2_4_MODULES(...)
+#define SKIP_FEATURE_2_4_MODULES(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_2_6_MODULES
+#define ENABLE_FEATURE_2_6_MODULES 0
+#define USE_FEATURE_2_6_MODULES(...)
+#define SKIP_FEATURE_2_6_MODULES(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_QUERY_MODULE_INTERFACE
+#define ENABLE_FEATURE_QUERY_MODULE_INTERFACE 0
+#define USE_FEATURE_QUERY_MODULE_INTERFACE(...)
+#define SKIP_FEATURE_QUERY_MODULE_INTERFACE(...)  __VA_ARGS__
+
+
+/*
+ * Linux System Utilities
+ */
+#undef CONFIG_DMESG
+#define ENABLE_DMESG 0
+#define USE_DMESG(...)
+#define SKIP_DMESG(...)  __VA_ARGS__
+
+#undef CONFIG_FBSET
+#define ENABLE_FBSET 0
+#define USE_FBSET(...)
+#define SKIP_FBSET(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FBSET_FANCY
+#define ENABLE_FEATURE_FBSET_FANCY 0
+#define USE_FEATURE_FBSET_FANCY(...)
+#define SKIP_FEATURE_FBSET_FANCY(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FBSET_READMODE
+#define ENABLE_FEATURE_FBSET_READMODE 0
+#define USE_FEATURE_FBSET_READMODE(...)
+#define SKIP_FEATURE_FBSET_READMODE(...)  __VA_ARGS__
+
+#undef CONFIG_FDFLUSH
+#define ENABLE_FDFLUSH 0
+#define USE_FDFLUSH(...)
+#define SKIP_FDFLUSH(...)  __VA_ARGS__
+
+#undef CONFIG_FDFORMAT
+#define ENABLE_FDFORMAT 0
+#define USE_FDFORMAT(...)
+#define SKIP_FDFORMAT(...)  __VA_ARGS__
+
+#undef CONFIG_FDISK
+#define ENABLE_FDISK 0
+#define USE_FDISK(...)
+#define SKIP_FDISK(...)  __VA_ARGS__
+
+#undef FDISK_SUPPORT_LARGE_DISKS
+#define ENABLE_SUPPORT_LARGE_DISKS 0
+#define USE_SUPPORT_LARGE_DISKS(...)
+#define SKIP_SUPPORT_LARGE_DISKS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FDISK_WRITABLE
+#define ENABLE_FEATURE_FDISK_WRITABLE 0
+#define USE_FEATURE_FDISK_WRITABLE(...)
+#define SKIP_FEATURE_FDISK_WRITABLE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_AIX_LABEL
+#define ENABLE_FEATURE_AIX_LABEL 0
+#define USE_FEATURE_AIX_LABEL(...)
+#define SKIP_FEATURE_AIX_LABEL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SGI_LABEL
+#define ENABLE_FEATURE_SGI_LABEL 0
+#define USE_FEATURE_SGI_LABEL(...)
+#define SKIP_FEATURE_SGI_LABEL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SUN_LABEL
+#define ENABLE_FEATURE_SUN_LABEL 0
+#define USE_FEATURE_SUN_LABEL(...)
+#define SKIP_FEATURE_SUN_LABEL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_OSF_LABEL
+#define ENABLE_FEATURE_OSF_LABEL 0
+#define USE_FEATURE_OSF_LABEL(...)
+#define SKIP_FEATURE_OSF_LABEL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FDISK_ADVANCED
+#define ENABLE_FEATURE_FDISK_ADVANCED 0
+#define USE_FEATURE_FDISK_ADVANCED(...)
+#define SKIP_FEATURE_FDISK_ADVANCED(...)  __VA_ARGS__
+
+#undef CONFIG_FREERAMDISK
+#define ENABLE_FREERAMDISK 0
+#define USE_FREERAMDISK(...)
+#define SKIP_FREERAMDISK(...)  __VA_ARGS__
+
+#undef CONFIG_FSCK_MINIX
+#define ENABLE_FSCK_MINIX 0
+#define USE_FSCK_MINIX(...)
+#define SKIP_FSCK_MINIX(...)  __VA_ARGS__
+
+#undef CONFIG_MKFS_MINIX
+#define ENABLE_MKFS_MINIX 0
+#define USE_MKFS_MINIX(...)
+#define SKIP_MKFS_MINIX(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MINIX2
+#define ENABLE_FEATURE_MINIX2 0
+#define USE_FEATURE_MINIX2(...)
+#define SKIP_FEATURE_MINIX2(...)  __VA_ARGS__
+
+#undef CONFIG_GETOPT
+#define ENABLE_GETOPT 0
+#define USE_GETOPT(...)
+#define SKIP_GETOPT(...)  __VA_ARGS__
+
+#undef CONFIG_HEXDUMP
+#define ENABLE_HEXDUMP 0
+#define USE_HEXDUMP(...)
+#define SKIP_HEXDUMP(...)  __VA_ARGS__
+
+#undef CONFIG_HWCLOCK
+#define ENABLE_HWCLOCK 0
+#define USE_HWCLOCK(...)
+#define SKIP_HWCLOCK(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HWCLOCK_LONG_OPTIONS
+#define ENABLE_FEATURE_HWCLOCK_LONG_OPTIONS 0
+#define USE_FEATURE_HWCLOCK_LONG_OPTIONS(...)
+#define SKIP_FEATURE_HWCLOCK_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS
+#define ENABLE_FEATURE_HWCLOCK_ADJTIME_FHS 0
+#define USE_FEATURE_HWCLOCK_ADJTIME_FHS(...)
+#define SKIP_FEATURE_HWCLOCK_ADJTIME_FHS(...)  __VA_ARGS__
+
+#undef CONFIG_IPCRM
+#define ENABLE_IPCRM 0
+#define USE_IPCRM(...)
+#define SKIP_IPCRM(...)  __VA_ARGS__
+
+#undef CONFIG_IPCS
+#define ENABLE_IPCS 0
+#define USE_IPCS(...)
+#define SKIP_IPCS(...)  __VA_ARGS__
+
+#undef CONFIG_LOSETUP
+#define ENABLE_LOSETUP 0
+#define USE_LOSETUP(...)
+#define SKIP_LOSETUP(...)  __VA_ARGS__
+
+#undef CONFIG_MDEV
+#define ENABLE_MDEV 0
+#define USE_MDEV(...)
+#define SKIP_MDEV(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MDEV_CONF
+#define ENABLE_FEATURE_MDEV_CONF 0
+#define USE_FEATURE_MDEV_CONF(...)
+#define SKIP_FEATURE_MDEV_CONF(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MDEV_EXEC
+#define ENABLE_FEATURE_MDEV_EXEC 0
+#define USE_FEATURE_MDEV_EXEC(...)
+#define SKIP_FEATURE_MDEV_EXEC(...)  __VA_ARGS__
+
+#undef CONFIG_MKSWAP
+#define ENABLE_MKSWAP 0
+#define USE_MKSWAP(...)
+#define SKIP_MKSWAP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MKSWAP_V0
+#define ENABLE_FEATURE_MKSWAP_V0 0
+#define USE_FEATURE_MKSWAP_V0(...)
+#define SKIP_FEATURE_MKSWAP_V0(...)  __VA_ARGS__
+
+#undef CONFIG_MORE
+#define ENABLE_MORE 0
+#define USE_MORE(...)
+#define SKIP_MORE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_USE_TERMIOS
+#define ENABLE_FEATURE_USE_TERMIOS 0
+#define USE_FEATURE_USE_TERMIOS(...)
+#define SKIP_FEATURE_USE_TERMIOS(...)  __VA_ARGS__
+
+#undef CONFIG_LINUX_MOUNT
+#define ENABLE_LINUX_MOUNT 0
+#define USE_LINUX_MOUNT(...)
+#define SKIP_LINUX_MOUNT(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MOUNT_NFS
+#define ENABLE_FEATURE_MOUNT_NFS 0
+#define USE_FEATURE_MOUNT_NFS(...)
+#define SKIP_FEATURE_MOUNT_NFS(...)  __VA_ARGS__
+
+#undef CONFIG_PIVOT_ROOT
+#define ENABLE_PIVOT_ROOT 0
+#define USE_PIVOT_ROOT(...)
+#define SKIP_PIVOT_ROOT(...)  __VA_ARGS__
+
+#undef CONFIG_RDATE
+#define ENABLE_RDATE 0
+#define USE_RDATE(...)
+#define SKIP_RDATE(...)  __VA_ARGS__
+
+#undef CONFIG_READPROFILE
+#define ENABLE_READPROFILE 0
+#define USE_READPROFILE(...)
+#define SKIP_READPROFILE(...)  __VA_ARGS__
+
+#undef CONFIG_SETARCH
+#define ENABLE_SETARCH 0
+#define USE_SETARCH(...)
+#define SKIP_SETARCH(...)  __VA_ARGS__
+
+#undef CONFIG_SWAPONOFF
+#define ENABLE_SWAPONOFF 0
+#define USE_SWAPONOFF(...)
+#define SKIP_SWAPONOFF(...)  __VA_ARGS__
+
+#undef CONFIG_SWITCH_ROOT
+#define ENABLE_SWITCH_ROOT 0
+#define USE_SWITCH_ROOT(...)
+#define SKIP_SWITCH_ROOT(...)  __VA_ARGS__
+
+#undef CONFIG_LINUX_UMOUNT
+#define ENABLE_LINUX_UMOUNT 0
+#define USE_LINUX_UMOUNT(...)
+#define SKIP_LINUX_UMOUNT(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_UMOUNT_ALL
+#define ENABLE_FEATURE_UMOUNT_ALL 0
+#define USE_FEATURE_UMOUNT_ALL(...)
+#define SKIP_FEATURE_UMOUNT_ALL(...)  __VA_ARGS__
+
+
+/*
+ * Common options for mount/umount
+ */
+#undef CONFIG_FEATURE_MOUNT_LOOP
+#define ENABLE_FEATURE_MOUNT_LOOP 0
+#define USE_FEATURE_MOUNT_LOOP(...)
+#define SKIP_FEATURE_MOUNT_LOOP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MTAB_SUPPORT
+#define ENABLE_FEATURE_MTAB_SUPPORT 0
+#define USE_FEATURE_MTAB_SUPPORT(...)
+#define SKIP_FEATURE_MTAB_SUPPORT(...)  __VA_ARGS__
+
+
+/*
+ * Miscellaneous Utilities
+ */
+#undef CONFIG_ADJTIMEX
+#define ENABLE_ADJTIMEX 0
+#define USE_ADJTIMEX(...)
+#define SKIP_ADJTIMEX(...)  __VA_ARGS__
+
+#undef CONFIG_BBCONFIG
+#define ENABLE_BBCONFIG 0
+#define USE_BBCONFIG(...)
+#define SKIP_BBCONFIG(...)  __VA_ARGS__
+
+#undef CONFIG_CROND
+#define ENABLE_CROND 0
+#define USE_CROND(...)
+#define SKIP_CROND(...)  __VA_ARGS__
+
+#undef CONFIG_DEBUG_CROND_OPTION
+#define ENABLE_DEBUG_CROND_OPTION 0
+#define USE_DEBUG_CROND_OPTION(...)
+#define SKIP_DEBUG_CROND_OPTION(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_CROND_CALL_SENDMAIL
+#define ENABLE_FEATURE_CROND_CALL_SENDMAIL 0
+#define USE_FEATURE_CROND_CALL_SENDMAIL(...)
+#define SKIP_FEATURE_CROND_CALL_SENDMAIL(...)  __VA_ARGS__
+
+#undef CONFIG_CRONTAB
+#define ENABLE_CRONTAB 0
+#define USE_CRONTAB(...)
+#define SKIP_CRONTAB(...)  __VA_ARGS__
+
+#undef CONFIG_DC
+#define ENABLE_DC 0
+#define USE_DC(...)
+#define SKIP_DC(...)  __VA_ARGS__
+
+#undef CONFIG_DEVFSD
+#define ENABLE_DEVFSD 0
+#define USE_DEVFSD(...)
+#define SKIP_DEVFSD(...)  __VA_ARGS__
+
+#undef CONFIG_DEVFSD_MODLOAD
+#define ENABLE_DEVFSD_MODLOAD 0
+#define USE_DEVFSD_MODLOAD(...)
+#define SKIP_DEVFSD_MODLOAD(...)  __VA_ARGS__
+
+#undef CONFIG_DEVFSD_FG_NP
+#define ENABLE_DEVFSD_FG_NP 0
+#define USE_DEVFSD_FG_NP(...)
+#define SKIP_DEVFSD_FG_NP(...)  __VA_ARGS__
+
+#undef CONFIG_DEVFSD_VERBOSE
+#define ENABLE_DEVFSD_VERBOSE 0
+#define USE_DEVFSD_VERBOSE(...)
+#define SKIP_DEVFSD_VERBOSE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_DEVFS
+#define ENABLE_FEATURE_DEVFS 0
+#define USE_FEATURE_DEVFS(...)
+#define SKIP_FEATURE_DEVFS(...)  __VA_ARGS__
+
+#undef CONFIG_EJECT
+#define ENABLE_EJECT 0
+#define USE_EJECT(...)
+#define SKIP_EJECT(...)  __VA_ARGS__
+
+#undef CONFIG_LAST
+#define ENABLE_LAST 0
+#define USE_LAST(...)
+#define SKIP_LAST(...)  __VA_ARGS__
+
+#define CONFIG_LESS 1
+#define ENABLE_LESS 1
+#define USE_LESS(...)  __VA_ARGS__
+#define SKIP_LESS(...)
+
+#define CONFIG_FEATURE_LESS_BRACKETS 1
+#define ENABLE_FEATURE_LESS_BRACKETS 1
+#define USE_FEATURE_LESS_BRACKETS(...)  __VA_ARGS__
+#define SKIP_FEATURE_LESS_BRACKETS(...)
+
+#define CONFIG_FEATURE_LESS_FLAGS 1
+#define ENABLE_FEATURE_LESS_FLAGS 1
+#define USE_FEATURE_LESS_FLAGS(...)  __VA_ARGS__
+#define SKIP_FEATURE_LESS_FLAGS(...)
+
+#undef CONFIG_FEATURE_LESS_FLAGCS
+#define ENABLE_FEATURE_LESS_FLAGCS 0
+#define USE_FEATURE_LESS_FLAGCS(...)
+#define SKIP_FEATURE_LESS_FLAGCS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_LESS_MARKS
+#define ENABLE_FEATURE_LESS_MARKS 0
+#define USE_FEATURE_LESS_MARKS(...)
+#define SKIP_FEATURE_LESS_MARKS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_LESS_REGEXP
+#define ENABLE_FEATURE_LESS_REGEXP 0
+#define USE_FEATURE_LESS_REGEXP(...)
+#define SKIP_FEATURE_LESS_REGEXP(...)  __VA_ARGS__
+
+#undef CONFIG_HDPARM
+#define ENABLE_HDPARM 0
+#define USE_HDPARM(...)
+#define SKIP_HDPARM(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HDPARM_GET_IDENTITY
+#define ENABLE_FEATURE_HDPARM_GET_IDENTITY 0
+#define USE_FEATURE_HDPARM_GET_IDENTITY(...)
+#define SKIP_FEATURE_HDPARM_GET_IDENTITY(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HDPARM_HDIO_SCAN_HWIF
+#define ENABLE_FEATURE_HDPARM_HDIO_SCAN_HWIF 0
+#define USE_FEATURE_HDPARM_HDIO_SCAN_HWIF(...)
+#define SKIP_FEATURE_HDPARM_HDIO_SCAN_HWIF(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF
+#define ENABLE_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF 0
+#define USE_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF(...)
+#define SKIP_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HDPARM_HDIO_DRIVE_RESET
+#define ENABLE_FEATURE_HDPARM_HDIO_DRIVE_RESET 0
+#define USE_FEATURE_HDPARM_HDIO_DRIVE_RESET(...)
+#define SKIP_FEATURE_HDPARM_HDIO_DRIVE_RESET(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HDPARM_HDIO_TRISTATE_HWIF
+#define ENABLE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF 0
+#define USE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(...)
+#define SKIP_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HDPARM_HDIO_GETSET_DMA
+#define ENABLE_FEATURE_HDPARM_HDIO_GETSET_DMA 0
+#define USE_FEATURE_HDPARM_HDIO_GETSET_DMA(...)
+#define SKIP_FEATURE_HDPARM_HDIO_GETSET_DMA(...)  __VA_ARGS__
+
+#undef CONFIG_MAKEDEVS
+#define ENABLE_MAKEDEVS 0
+#define USE_MAKEDEVS(...)
+#define SKIP_MAKEDEVS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MAKEDEVS_LEAF
+#define ENABLE_FEATURE_MAKEDEVS_LEAF 0
+#define USE_FEATURE_MAKEDEVS_LEAF(...)
+#define SKIP_FEATURE_MAKEDEVS_LEAF(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_MAKEDEVS_TABLE
+#define ENABLE_FEATURE_MAKEDEVS_TABLE 0
+#define USE_FEATURE_MAKEDEVS_TABLE(...)
+#define SKIP_FEATURE_MAKEDEVS_TABLE(...)  __VA_ARGS__
+
+#undef CONFIG_MOUNTPOINT
+#define ENABLE_MOUNTPOINT 0
+#define USE_MOUNTPOINT(...)
+#define SKIP_MOUNTPOINT(...)  __VA_ARGS__
+
+#undef CONFIG_MT
+#define ENABLE_MT 0
+#define USE_MT(...)
+#define SKIP_MT(...)  __VA_ARGS__
+
+#undef CONFIG_RUNLEVEL
+#define ENABLE_RUNLEVEL 0
+#define USE_RUNLEVEL(...)
+#define SKIP_RUNLEVEL(...)  __VA_ARGS__
+
+#undef CONFIG_RX
+#define ENABLE_RX 0
+#define USE_RX(...)
+#define SKIP_RX(...)  __VA_ARGS__
+
+#undef CONFIG_STRINGS
+#define ENABLE_STRINGS 0
+#define USE_STRINGS(...)
+#define SKIP_STRINGS(...)  __VA_ARGS__
+
+#undef CONFIG_SETSID
+#define ENABLE_SETSID 0
+#define USE_SETSID(...)
+#define SKIP_SETSID(...)  __VA_ARGS__
+
+#undef CONFIG_TASKSET
+#define ENABLE_TASKSET 0
+#define USE_TASKSET(...)
+#define SKIP_TASKSET(...)  __VA_ARGS__
+
+#undef CONFIG_TIME
+#define ENABLE_TIME 0
+#define USE_TIME(...)
+#define SKIP_TIME(...)  __VA_ARGS__
+
+#undef CONFIG_WATCHDOG
+#define ENABLE_WATCHDOG 0
+#define USE_WATCHDOG(...)
+#define SKIP_WATCHDOG(...)  __VA_ARGS__
+
+
+/*
+ * Networking Utilities
+ */
+#undef CONFIG_FEATURE_IPV6
+#define ENABLE_FEATURE_IPV6 0
+#define USE_FEATURE_IPV6(...)
+#define SKIP_FEATURE_IPV6(...)  __VA_ARGS__
+
+#undef CONFIG_ARPING
+#define ENABLE_ARPING 0
+#define USE_ARPING(...)
+#define SKIP_ARPING(...)  __VA_ARGS__
+
+#undef CONFIG_DNSD
+#define ENABLE_DNSD 0
+#define USE_DNSD(...)
+#define SKIP_DNSD(...)  __VA_ARGS__
+
+#undef CONFIG_ETHER_WAKE
+#define ENABLE_ETHER_WAKE 0
+#define USE_ETHER_WAKE(...)
+#define SKIP_ETHER_WAKE(...)  __VA_ARGS__
+
+#undef CONFIG_FAKEIDENTD
+#define ENABLE_FAKEIDENTD 0
+#define USE_FAKEIDENTD(...)
+#define SKIP_FAKEIDENTD(...)  __VA_ARGS__
+
+#undef CONFIG_FTPGET
+#define ENABLE_FTPGET 0
+#define USE_FTPGET(...)
+#define SKIP_FTPGET(...)  __VA_ARGS__
+
+#undef CONFIG_FTPPUT
+#define ENABLE_FTPPUT 0
+#define USE_FTPPUT(...)
+#define SKIP_FTPPUT(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FTPGETPUT_LONG_OPTIONS
+#define ENABLE_FEATURE_FTPGETPUT_LONG_OPTIONS 0
+#define USE_FEATURE_FTPGETPUT_LONG_OPTIONS(...)
+#define SKIP_FEATURE_FTPGETPUT_LONG_OPTIONS(...)  __VA_ARGS__
+
+#define CONFIG_HOSTNAME 1
+#define ENABLE_HOSTNAME 1
+#define USE_HOSTNAME(...)  __VA_ARGS__
+#define SKIP_HOSTNAME(...)
+
+#undef CONFIG_HTTPD
+#define ENABLE_HTTPD 0
+#define USE_HTTPD(...)
+#define SKIP_HTTPD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_WITHOUT_INETD
+#define ENABLE_FEATURE_HTTPD_WITHOUT_INETD 0
+#define USE_FEATURE_HTTPD_WITHOUT_INETD(...)
+#define SKIP_FEATURE_HTTPD_WITHOUT_INETD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP
+#define ENABLE_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP 0
+#define USE_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP(...)
+#define SKIP_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_SETUID
+#define ENABLE_FEATURE_HTTPD_SETUID 0
+#define USE_FEATURE_HTTPD_SETUID(...)
+#define SKIP_FEATURE_HTTPD_SETUID(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_BASIC_AUTH
+#define ENABLE_FEATURE_HTTPD_BASIC_AUTH 0
+#define USE_FEATURE_HTTPD_BASIC_AUTH(...)
+#define SKIP_FEATURE_HTTPD_BASIC_AUTH(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_AUTH_MD5
+#define ENABLE_FEATURE_HTTPD_AUTH_MD5 0
+#define USE_FEATURE_HTTPD_AUTH_MD5(...)
+#define SKIP_FEATURE_HTTPD_AUTH_MD5(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES
+#define ENABLE_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES 0
+#define USE_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES(...)
+#define SKIP_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_CGI
+#define ENABLE_FEATURE_HTTPD_CGI 0
+#define USE_FEATURE_HTTPD_CGI(...)
+#define SKIP_FEATURE_HTTPD_CGI(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
+#define ENABLE_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR 0
+#define USE_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR(...)
+#define SKIP_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV
+#define ENABLE_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV 0
+#define USE_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV(...)
+#define SKIP_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_HTTPD_ENCODE_URL_STR
+#define ENABLE_FEATURE_HTTPD_ENCODE_URL_STR 0
+#define USE_FEATURE_HTTPD_ENCODE_URL_STR(...)
+#define SKIP_FEATURE_HTTPD_ENCODE_URL_STR(...)  __VA_ARGS__
+
+#undef CONFIG_IFCONFIG
+#define ENABLE_IFCONFIG 0
+#define USE_IFCONFIG(...)
+#define SKIP_IFCONFIG(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFCONFIG_STATUS
+#define ENABLE_FEATURE_IFCONFIG_STATUS 0
+#define USE_FEATURE_IFCONFIG_STATUS(...)
+#define SKIP_FEATURE_IFCONFIG_STATUS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFCONFIG_SLIP
+#define ENABLE_FEATURE_IFCONFIG_SLIP 0
+#define USE_FEATURE_IFCONFIG_SLIP(...)
+#define SKIP_FEATURE_IFCONFIG_SLIP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
+#define ENABLE_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ 0
+#define USE_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ(...)
+#define SKIP_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFCONFIG_HW
+#define ENABLE_FEATURE_IFCONFIG_HW 0
+#define USE_FEATURE_IFCONFIG_HW(...)
+#define SKIP_FEATURE_IFCONFIG_HW(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS
+#define ENABLE_FEATURE_IFCONFIG_BROADCAST_PLUS 0
+#define USE_FEATURE_IFCONFIG_BROADCAST_PLUS(...)
+#define SKIP_FEATURE_IFCONFIG_BROADCAST_PLUS(...)  __VA_ARGS__
+
+#undef CONFIG_IFUPDOWN
+#define ENABLE_IFUPDOWN 0
+#define USE_IFUPDOWN(...)
+#define SKIP_IFUPDOWN(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFUPDOWN_IP
+#define ENABLE_FEATURE_IFUPDOWN_IP 0
+#define USE_FEATURE_IFUPDOWN_IP(...)
+#define SKIP_FEATURE_IFUPDOWN_IP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFUPDOWN_IP_BUILTIN
+#define ENABLE_FEATURE_IFUPDOWN_IP_BUILTIN 0
+#define USE_FEATURE_IFUPDOWN_IP_BUILTIN(...)
+#define SKIP_FEATURE_IFUPDOWN_IP_BUILTIN(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFUPDOWN_IPV4
+#define ENABLE_FEATURE_IFUPDOWN_IPV4 0
+#define USE_FEATURE_IFUPDOWN_IPV4(...)
+#define SKIP_FEATURE_IFUPDOWN_IPV4(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFUPDOWN_IPV6
+#define ENABLE_FEATURE_IFUPDOWN_IPV6 0
+#define USE_FEATURE_IFUPDOWN_IPV6(...)
+#define SKIP_FEATURE_IFUPDOWN_IPV6(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFUPDOWN_IPX
+#define ENABLE_FEATURE_IFUPDOWN_IPX 0
+#define USE_FEATURE_IFUPDOWN_IPX(...)
+#define SKIP_FEATURE_IFUPDOWN_IPX(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IFUPDOWN_MAPPING
+#define ENABLE_FEATURE_IFUPDOWN_MAPPING 0
+#define USE_FEATURE_IFUPDOWN_MAPPING(...)
+#define SKIP_FEATURE_IFUPDOWN_MAPPING(...)  __VA_ARGS__
+
+#undef CONFIG_INETD
+#define ENABLE_INETD 0
+#define USE_INETD(...)
+#define SKIP_INETD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO
+#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_ECHO 0
+#define USE_FEATURE_INETD_SUPPORT_BUILTIN_ECHO(...)
+#define SKIP_FEATURE_INETD_SUPPORT_BUILTIN_ECHO(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD
+#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD 0
+#define USE_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD(...)
+#define SKIP_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME
+#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_TIME 0
+#define USE_FEATURE_INETD_SUPPORT_BUILTIN_TIME(...)
+#define SKIP_FEATURE_INETD_SUPPORT_BUILTIN_TIME(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME
+#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME 0
+#define USE_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME(...)
+#define SKIP_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN
+#define ENABLE_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN 0
+#define USE_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN(...)
+#define SKIP_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_INETD_RPC
+#define ENABLE_FEATURE_INETD_RPC 0
+#define USE_FEATURE_INETD_RPC(...)
+#define SKIP_FEATURE_INETD_RPC(...)  __VA_ARGS__
+
+#undef CONFIG_IP
+#define ENABLE_IP 0
+#define USE_IP(...)
+#define SKIP_IP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IP_ADDRESS
+#define ENABLE_FEATURE_IP_ADDRESS 0
+#define USE_FEATURE_IP_ADDRESS(...)
+#define SKIP_FEATURE_IP_ADDRESS(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IP_LINK
+#define ENABLE_FEATURE_IP_LINK 0
+#define USE_FEATURE_IP_LINK(...)
+#define SKIP_FEATURE_IP_LINK(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IP_ROUTE
+#define ENABLE_FEATURE_IP_ROUTE 0
+#define USE_FEATURE_IP_ROUTE(...)
+#define SKIP_FEATURE_IP_ROUTE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IP_TUNNEL
+#define ENABLE_FEATURE_IP_TUNNEL 0
+#define USE_FEATURE_IP_TUNNEL(...)
+#define SKIP_FEATURE_IP_TUNNEL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IP_SHORT_FORMS
+#define ENABLE_FEATURE_IP_SHORT_FORMS 0
+#define USE_FEATURE_IP_SHORT_FORMS(...)
+#define SKIP_FEATURE_IP_SHORT_FORMS(...)  __VA_ARGS__
+
+#undef CONFIG_IPADDR
+#define ENABLE_IPADDR 0
+#define USE_IPADDR(...)
+#define SKIP_IPADDR(...)  __VA_ARGS__
+
+#undef CONFIG_IPLINK
+#define ENABLE_IPLINK 0
+#define USE_IPLINK(...)
+#define SKIP_IPLINK(...)  __VA_ARGS__
+
+#undef CONFIG_IPROUTE
+#define ENABLE_IPROUTE 0
+#define USE_IPROUTE(...)
+#define SKIP_IPROUTE(...)  __VA_ARGS__
+
+#undef CONFIG_IPTUNNEL
+#define ENABLE_IPTUNNEL 0
+#define USE_IPTUNNEL(...)
+#define SKIP_IPTUNNEL(...)  __VA_ARGS__
+
+#undef CONFIG_IPCALC
+#define ENABLE_IPCALC 0
+#define USE_IPCALC(...)
+#define SKIP_IPCALC(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IPCALC_FANCY
+#define ENABLE_FEATURE_IPCALC_FANCY 0
+#define USE_FEATURE_IPCALC_FANCY(...)
+#define SKIP_FEATURE_IPCALC_FANCY(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IPCALC_LONG_OPTIONS
+#define ENABLE_FEATURE_IPCALC_LONG_OPTIONS 0
+#define USE_FEATURE_IPCALC_LONG_OPTIONS(...)
+#define SKIP_FEATURE_IPCALC_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_NAMEIF
+#define ENABLE_NAMEIF 0
+#define USE_NAMEIF(...)
+#define SKIP_NAMEIF(...)  __VA_ARGS__
+
+#define CONFIG_NC 1
+#define ENABLE_NC 1
+#define USE_NC(...)  __VA_ARGS__
+#define SKIP_NC(...)
+
+#undef CONFIG_NC_GAPING_SECURITY_HOLE
+#define ENABLE_NC_GAPING_SECURITY_HOLE 0
+#define USE_NC_GAPING_SECURITY_HOLE(...)
+#define SKIP_NC_GAPING_SECURITY_HOLE(...)  __VA_ARGS__
+
+#undef CONFIG_NETSTAT
+#define ENABLE_NETSTAT 0
+#define USE_NETSTAT(...)
+#define SKIP_NETSTAT(...)  __VA_ARGS__
+
+#define CONFIG_NSLOOKUP 1
+#define ENABLE_NSLOOKUP 1
+#define USE_NSLOOKUP(...)  __VA_ARGS__
+#define SKIP_NSLOOKUP(...)
+
+#undef CONFIG_PING
+#define ENABLE_PING 0
+#define USE_PING(...)
+#define SKIP_PING(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FANCY_PING
+#define ENABLE_FEATURE_FANCY_PING 0
+#define USE_FEATURE_FANCY_PING(...)
+#define SKIP_FEATURE_FANCY_PING(...)  __VA_ARGS__
+
+#undef CONFIG_PING6
+#define ENABLE_PING6 0
+#define USE_PING6(...)
+#define SKIP_PING6(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_FANCY_PING6
+#define ENABLE_FEATURE_FANCY_PING6 0
+#define USE_FEATURE_FANCY_PING6(...)
+#define SKIP_FEATURE_FANCY_PING6(...)  __VA_ARGS__
+
+#undef CONFIG_ROUTE
+#define ENABLE_ROUTE 0
+#define USE_ROUTE(...)
+#define SKIP_ROUTE(...)  __VA_ARGS__
+
+#define CONFIG_TELNET 1
+#define ENABLE_TELNET 1
+#define USE_TELNET(...)  __VA_ARGS__
+#define SKIP_TELNET(...)
+
+#undef CONFIG_FEATURE_TELNET_TTYPE
+#define ENABLE_FEATURE_TELNET_TTYPE 0
+#define USE_FEATURE_TELNET_TTYPE(...)
+#define SKIP_FEATURE_TELNET_TTYPE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TELNET_AUTOLOGIN
+#define ENABLE_FEATURE_TELNET_AUTOLOGIN 0
+#define USE_FEATURE_TELNET_AUTOLOGIN(...)
+#define SKIP_FEATURE_TELNET_AUTOLOGIN(...)  __VA_ARGS__
+
+#undef CONFIG_TELNETD
+#define ENABLE_TELNETD 0
+#define USE_TELNETD(...)
+#define SKIP_TELNETD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TELNETD_INETD
+#define ENABLE_FEATURE_TELNETD_INETD 0
+#define USE_FEATURE_TELNETD_INETD(...)
+#define SKIP_FEATURE_TELNETD_INETD(...)  __VA_ARGS__
+
+#undef CONFIG_TFTP
+#define ENABLE_TFTP 0
+#define USE_TFTP(...)
+#define SKIP_TFTP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TFTP_GET
+#define ENABLE_FEATURE_TFTP_GET 0
+#define USE_FEATURE_TFTP_GET(...)
+#define SKIP_FEATURE_TFTP_GET(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TFTP_PUT
+#define ENABLE_FEATURE_TFTP_PUT 0
+#define USE_FEATURE_TFTP_PUT(...)
+#define SKIP_FEATURE_TFTP_PUT(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TFTP_BLOCKSIZE
+#define ENABLE_FEATURE_TFTP_BLOCKSIZE 0
+#define USE_FEATURE_TFTP_BLOCKSIZE(...)
+#define SKIP_FEATURE_TFTP_BLOCKSIZE(...)  __VA_ARGS__
+
+#undef CONFIG_DEBUG_TFTP
+#define ENABLE_DEBUG_TFTP 0
+#define USE_DEBUG_TFTP(...)
+#define SKIP_DEBUG_TFTP(...)  __VA_ARGS__
+
+#undef CONFIG_TRACEROUTE
+#define ENABLE_TRACEROUTE 0
+#define USE_TRACEROUTE(...)
+#define SKIP_TRACEROUTE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TRACEROUTE_VERBOSE
+#define ENABLE_FEATURE_TRACEROUTE_VERBOSE 0
+#define USE_FEATURE_TRACEROUTE_VERBOSE(...)
+#define SKIP_FEATURE_TRACEROUTE_VERBOSE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE
+#define ENABLE_FEATURE_TRACEROUTE_SOURCE_ROUTE 0
+#define USE_FEATURE_TRACEROUTE_SOURCE_ROUTE(...)
+#define SKIP_FEATURE_TRACEROUTE_SOURCE_ROUTE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TRACEROUTE_USE_ICMP
+#define ENABLE_FEATURE_TRACEROUTE_USE_ICMP 0
+#define USE_FEATURE_TRACEROUTE_USE_ICMP(...)
+#define SKIP_FEATURE_TRACEROUTE_USE_ICMP(...)  __VA_ARGS__
+
+
+/*
+ * udhcp Server/Client
+ */
+#undef CONFIG_APP_UDHCPD
+#define ENABLE_APP_UDHCPD 0
+#define USE_APP_UDHCPD(...)
+#define SKIP_APP_UDHCPD(...)  __VA_ARGS__
+
+#undef CONFIG_APP_UDHCPC
+#define ENABLE_APP_UDHCPC 0
+#define USE_APP_UDHCPC(...)
+#define SKIP_APP_UDHCPC(...)  __VA_ARGS__
+
+#undef CONFIG_APP_DUMPLEASES
+#define ENABLE_APP_DUMPLEASES 0
+#define USE_APP_DUMPLEASES(...)
+#define SKIP_APP_DUMPLEASES(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_UDHCP_SYSLOG
+#define ENABLE_FEATURE_UDHCP_SYSLOG 0
+#define USE_FEATURE_UDHCP_SYSLOG(...)
+#define SKIP_FEATURE_UDHCP_SYSLOG(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_UDHCP_DEBUG
+#define ENABLE_FEATURE_UDHCP_DEBUG 0
+#define USE_FEATURE_UDHCP_DEBUG(...)
+#define SKIP_FEATURE_UDHCP_DEBUG(...)  __VA_ARGS__
+
+#undef CONFIG_VCONFIG
+#define ENABLE_VCONFIG 0
+#define USE_VCONFIG(...)
+#define SKIP_VCONFIG(...)  __VA_ARGS__
+
+#undef CONFIG_WGET
+#define ENABLE_WGET 0
+#define USE_WGET(...)
+#define SKIP_WGET(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_WGET_STATUSBAR
+#define ENABLE_FEATURE_WGET_STATUSBAR 0
+#define USE_FEATURE_WGET_STATUSBAR(...)
+#define SKIP_FEATURE_WGET_STATUSBAR(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_WGET_AUTHENTICATION
+#define ENABLE_FEATURE_WGET_AUTHENTICATION 0
+#define USE_FEATURE_WGET_AUTHENTICATION(...)
+#define SKIP_FEATURE_WGET_AUTHENTICATION(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_WGET_IP6_LITERAL
+#define ENABLE_FEATURE_WGET_IP6_LITERAL 0
+#define USE_FEATURE_WGET_IP6_LITERAL(...)
+#define SKIP_FEATURE_WGET_IP6_LITERAL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_WGET_LONG_OPTIONS
+#define ENABLE_FEATURE_WGET_LONG_OPTIONS 0
+#define USE_FEATURE_WGET_LONG_OPTIONS(...)
+#define SKIP_FEATURE_WGET_LONG_OPTIONS(...)  __VA_ARGS__
+
+#undef CONFIG_ZCIP
+#define ENABLE_ZCIP 0
+#define USE_ZCIP(...)
+#define SKIP_ZCIP(...)  __VA_ARGS__
+
+
+/*
+ * Process Utilities
+ */
+#undef CONFIG_FREE
+#define ENABLE_FREE 0
+#define USE_FREE(...)
+#define SKIP_FREE(...)  __VA_ARGS__
+
+#undef CONFIG_FUSER
+#define ENABLE_FUSER 0
+#define USE_FUSER(...)
+#define SKIP_FUSER(...)  __VA_ARGS__
+
+#define CONFIG_KILL 1
+#define ENABLE_KILL 1
+#define USE_KILL(...)  __VA_ARGS__
+#define SKIP_KILL(...)
+
+#undef CONFIG_KILLALL
+#define ENABLE_KILLALL 0
+#define USE_KILLALL(...)
+#define SKIP_KILLALL(...)  __VA_ARGS__
+
+#undef CONFIG_PIDOF
+#define ENABLE_PIDOF 0
+#define USE_PIDOF(...)
+#define SKIP_PIDOF(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_PIDOF_SINGLE
+#define ENABLE_FEATURE_PIDOF_SINGLE 0
+#define USE_FEATURE_PIDOF_SINGLE(...)
+#define SKIP_FEATURE_PIDOF_SINGLE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_PIDOF_OMIT
+#define ENABLE_FEATURE_PIDOF_OMIT 0
+#define USE_FEATURE_PIDOF_OMIT(...)
+#define SKIP_FEATURE_PIDOF_OMIT(...)  __VA_ARGS__
+
+#define CONFIG_PS 1
+#define ENABLE_PS 1
+#define USE_PS(...)  __VA_ARGS__
+#define SKIP_PS(...)
+
+#undef CONFIG_FEATURE_PS_WIDE
+#define ENABLE_FEATURE_PS_WIDE 0
+#define USE_FEATURE_PS_WIDE(...)
+#define SKIP_FEATURE_PS_WIDE(...)  __VA_ARGS__
+
+#undef CONFIG_RENICE
+#define ENABLE_RENICE 0
+#define USE_RENICE(...)
+#define SKIP_RENICE(...)  __VA_ARGS__
+
+#undef CONFIG_BB_SYSCTL
+#define ENABLE_BB_SYSCTL 0
+#define USE_BB_SYSCTL(...)
+#define SKIP_BB_SYSCTL(...)  __VA_ARGS__
+
+#undef CONFIG_TOP
+#define ENABLE_TOP 0
+#define USE_TOP(...)
+#define SKIP_TOP(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE
+#define ENABLE_FEATURE_TOP_CPU_USAGE_PERCENTAGE 0
+#define USE_FEATURE_TOP_CPU_USAGE_PERCENTAGE(...)
+#define SKIP_FEATURE_TOP_CPU_USAGE_PERCENTAGE(...)  __VA_ARGS__
+
+#undef CONFIG_UPTIME
+#define ENABLE_UPTIME 0
+#define USE_UPTIME(...)
+#define SKIP_UPTIME(...)  __VA_ARGS__
+
+
+/*
+ * Shells
+ */
+#undef CONFIG_FEATURE_SH_IS_ASH
+#define ENABLE_FEATURE_SH_IS_ASH 0
+#define USE_FEATURE_SH_IS_ASH(...)
+#define SKIP_FEATURE_SH_IS_ASH(...)  __VA_ARGS__
+
+#define CONFIG_FEATURE_SH_IS_HUSH 1
+#define ENABLE_FEATURE_SH_IS_HUSH 1
+#define USE_FEATURE_SH_IS_HUSH(...)  __VA_ARGS__
+#define SKIP_FEATURE_SH_IS_HUSH(...)
+
+#undef CONFIG_FEATURE_SH_IS_LASH
+#define ENABLE_FEATURE_SH_IS_LASH 0
+#define USE_FEATURE_SH_IS_LASH(...)
+#define SKIP_FEATURE_SH_IS_LASH(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SH_IS_MSH
+#define ENABLE_FEATURE_SH_IS_MSH 0
+#define USE_FEATURE_SH_IS_MSH(...)
+#define SKIP_FEATURE_SH_IS_MSH(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SH_IS_NONE
+#define ENABLE_FEATURE_SH_IS_NONE 0
+#define USE_FEATURE_SH_IS_NONE(...)
+#define SKIP_FEATURE_SH_IS_NONE(...)  __VA_ARGS__
+
+#undef CONFIG_ASH
+#define ENABLE_ASH 0
+#define USE_ASH(...)
+#define SKIP_ASH(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_JOB_CONTROL
+#define ENABLE_ASH_JOB_CONTROL 0
+#define USE_ASH_JOB_CONTROL(...)
+#define SKIP_ASH_JOB_CONTROL(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_READ_NCHARS
+#define ENABLE_ASH_READ_NCHARS 0
+#define USE_ASH_READ_NCHARS(...)
+#define SKIP_ASH_READ_NCHARS(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_READ_TIMEOUT
+#define ENABLE_ASH_READ_TIMEOUT 0
+#define USE_ASH_READ_TIMEOUT(...)
+#define SKIP_ASH_READ_TIMEOUT(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_ALIAS
+#define ENABLE_ASH_ALIAS 0
+#define USE_ASH_ALIAS(...)
+#define SKIP_ASH_ALIAS(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_MATH_SUPPORT
+#define ENABLE_ASH_MATH_SUPPORT 0
+#define USE_ASH_MATH_SUPPORT(...)
+#define SKIP_ASH_MATH_SUPPORT(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_MATH_SUPPORT_64
+#define ENABLE_ASH_MATH_SUPPORT_64 0
+#define USE_ASH_MATH_SUPPORT_64(...)
+#define SKIP_ASH_MATH_SUPPORT_64(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_GETOPTS
+#define ENABLE_ASH_GETOPTS 0
+#define USE_ASH_GETOPTS(...)
+#define SKIP_ASH_GETOPTS(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_BUILTIN_ECHO
+#define ENABLE_ASH_BUILTIN_ECHO 0
+#define USE_ASH_BUILTIN_ECHO(...)
+#define SKIP_ASH_BUILTIN_ECHO(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_BUILTIN_TEST
+#define ENABLE_ASH_BUILTIN_TEST 0
+#define USE_ASH_BUILTIN_TEST(...)
+#define SKIP_ASH_BUILTIN_TEST(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_CMDCMD
+#define ENABLE_ASH_CMDCMD 0
+#define USE_ASH_CMDCMD(...)
+#define SKIP_ASH_CMDCMD(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_MAIL
+#define ENABLE_ASH_MAIL 0
+#define USE_ASH_MAIL(...)
+#define SKIP_ASH_MAIL(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_OPTIMIZE_FOR_SIZE
+#define ENABLE_ASH_OPTIMIZE_FOR_SIZE 0
+#define USE_ASH_OPTIMIZE_FOR_SIZE(...)
+#define SKIP_ASH_OPTIMIZE_FOR_SIZE(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_RANDOM_SUPPORT
+#define ENABLE_ASH_RANDOM_SUPPORT 0
+#define USE_ASH_RANDOM_SUPPORT(...)
+#define SKIP_ASH_RANDOM_SUPPORT(...)  __VA_ARGS__
+
+#undef CONFIG_ASH_EXPAND_PRMT
+#define ENABLE_ASH_EXPAND_PRMT 0
+#define USE_ASH_EXPAND_PRMT(...)
+#define SKIP_ASH_EXPAND_PRMT(...)  __VA_ARGS__
+
+#define CONFIG_HUSH 1
+#define ENABLE_HUSH 1
+#define USE_HUSH(...)  __VA_ARGS__
+#define SKIP_HUSH(...)
+
+#undef CONFIG_LASH
+#define ENABLE_LASH 0
+#define USE_LASH(...)
+#define SKIP_LASH(...)  __VA_ARGS__
+
+#undef CONFIG_MSH
+#define ENABLE_MSH 0
+#define USE_MSH(...)
+#define SKIP_MSH(...)  __VA_ARGS__
+
+
+/*
+ * Bourne Shell Options
+ */
+#undef CONFIG_FEATURE_SH_EXTRA_QUIET
+#define ENABLE_FEATURE_SH_EXTRA_QUIET 0
+#define USE_FEATURE_SH_EXTRA_QUIET(...)
+#define SKIP_FEATURE_SH_EXTRA_QUIET(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SH_STANDALONE_SHELL
+#define ENABLE_FEATURE_SH_STANDALONE_SHELL 0
+#define USE_FEATURE_SH_STANDALONE_SHELL(...)
+#define SKIP_FEATURE_SH_STANDALONE_SHELL(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_COMMAND_EDITING
+#define ENABLE_FEATURE_COMMAND_EDITING 0
+#define USE_FEATURE_COMMAND_EDITING(...)
+#define SKIP_FEATURE_COMMAND_EDITING(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_COMMAND_EDITING_VI
+#define ENABLE_FEATURE_COMMAND_EDITING_VI 0
+#define USE_FEATURE_COMMAND_EDITING_VI(...)
+#define SKIP_FEATURE_COMMAND_EDITING_VI(...)  __VA_ARGS__
+
+#define CONFIG_FEATURE_COMMAND_HISTORY 
+#define ENABLE_FEATURE_COMMAND_HISTORY 1
+#define USE_FEATURE_COMMAND_HISTORY(...)  __VA_ARGS__
+#define SKIP_FEATURE_COMMAND_HISTORY(...)
+
+#undef CONFIG_FEATURE_COMMAND_SAVEHISTORY
+#define ENABLE_FEATURE_COMMAND_SAVEHISTORY 0
+#define USE_FEATURE_COMMAND_SAVEHISTORY(...)
+#define SKIP_FEATURE_COMMAND_SAVEHISTORY(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_COMMAND_TAB_COMPLETION
+#define ENABLE_FEATURE_COMMAND_TAB_COMPLETION 0
+#define USE_FEATURE_COMMAND_TAB_COMPLETION(...)
+#define SKIP_FEATURE_COMMAND_TAB_COMPLETION(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION
+#define ENABLE_FEATURE_COMMAND_USERNAME_COMPLETION 0
+#define USE_FEATURE_COMMAND_USERNAME_COMPLETION(...)
+#define SKIP_FEATURE_COMMAND_USERNAME_COMPLETION(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_SH_FANCY_PROMPT
+#define ENABLE_FEATURE_SH_FANCY_PROMPT 0
+#define USE_FEATURE_SH_FANCY_PROMPT(...)
+#define SKIP_FEATURE_SH_FANCY_PROMPT(...)  __VA_ARGS__
+
+
+/*
+ * System Logging Utilities
+ */
+#undef CONFIG_SYSLOGD
+#define ENABLE_SYSLOGD 0
+#define USE_SYSLOGD(...)
+#define SKIP_SYSLOGD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_ROTATE_LOGFILE
+#define ENABLE_FEATURE_ROTATE_LOGFILE 0
+#define USE_FEATURE_ROTATE_LOGFILE(...)
+#define SKIP_FEATURE_ROTATE_LOGFILE(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_REMOTE_LOG
+#define ENABLE_FEATURE_REMOTE_LOG 0
+#define USE_FEATURE_REMOTE_LOG(...)
+#define SKIP_FEATURE_REMOTE_LOG(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_IPC_SYSLOG
+#define ENABLE_FEATURE_IPC_SYSLOG 0
+#define USE_FEATURE_IPC_SYSLOG(...)
+#define SKIP_FEATURE_IPC_SYSLOG(...)  __VA_ARGS__
+
+#define CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE 
+#define ENABLE_FEATURE_IPC_SYSLOG_BUFFER_SIZE 1
+#define USE_FEATURE_IPC_SYSLOG_BUFFER_SIZE(...)  __VA_ARGS__
+#define SKIP_FEATURE_IPC_SYSLOG_BUFFER_SIZE(...)
+
+#undef CONFIG_LOGREAD
+#define ENABLE_LOGREAD 0
+#define USE_LOGREAD(...)
+#define SKIP_LOGREAD(...)  __VA_ARGS__
+
+#undef CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING
+#define ENABLE_FEATURE_LOGREAD_REDUCED_LOCKING 0
+#define USE_FEATURE_LOGREAD_REDUCED_LOCKING(...)
+#define SKIP_FEATURE_LOGREAD_REDUCED_LOCKING(...)  __VA_ARGS__
+
+#undef CONFIG_KLOGD
+#define ENABLE_KLOGD 0
+#define USE_KLOGD(...)
+#define SKIP_KLOGD(...)  __VA_ARGS__
+
+#undef CONFIG_LOGGER
+#define ENABLE_LOGGER 0
+#define USE_LOGGER(...)
+#define SKIP_LOGGER(...)  __VA_ARGS__
+
+#endif /* BB_CONFIG_H */
diff -rupN busybox-1.2.0/include/config/bb/bt.h busybox-1.2.0solaris/include/config/bb/bt.h
--- busybox-1.2.0/include/config/bb/bt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/bb/bt.h	2009-04-20 14:06:34.706598050 +0400
@@ -0,0 +1 @@
+#define BB_BT "2009.04.20-10:06+0000"
diff -rupN busybox-1.2.0/include/config/bb/ver.h busybox-1.2.0solaris/include/config/bb/ver.h
--- busybox-1.2.0/include/config/bb/ver.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/bb/ver.h	2009-04-17 16:46:43.838254595 +0400
@@ -0,0 +1 @@
+#define BB_VER "1.2.0"
diff -rupN busybox-1.2.0/include/config/config/ar.h busybox-1.2.0solaris/include/config/config/ar.h
--- busybox-1.2.0/include/config/config/ar.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ar.h	2009-04-17 16:46:43.823355155 +0400
@@ -0,0 +1 @@
+#undef CONFIG_AR
diff -rupN busybox-1.2.0/include/config/config/ash/alias.h busybox-1.2.0solaris/include/config/config/ash/alias.h
--- busybox-1.2.0/include/config/config/ash/alias.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/alias.h	2009-04-18 09:28:20.892720848 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_ALIAS
diff -rupN busybox-1.2.0/include/config/config/ash/builtin/echo.h busybox-1.2.0solaris/include/config/config/ash/builtin/echo.h
--- busybox-1.2.0/include/config/config/ash/builtin/echo.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/builtin/echo.h	2009-04-18 09:28:20.891909384 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_BUILTIN_ECHO
diff -rupN busybox-1.2.0/include/config/config/ash/builtin/test.h busybox-1.2.0solaris/include/config/config/ash/builtin/test.h
--- busybox-1.2.0/include/config/config/ash/builtin/test.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/builtin/test.h	2009-04-17 16:46:43.428564158 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_BUILTIN_TEST
diff -rupN busybox-1.2.0/include/config/config/ash/cmdcmd.h busybox-1.2.0solaris/include/config/config/ash/cmdcmd.h
--- busybox-1.2.0/include/config/config/ash/cmdcmd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/cmdcmd.h	2009-04-18 09:26:07.539784572 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_CMDCMD
diff -rupN busybox-1.2.0/include/config/config/ash/expand/prmt.h busybox-1.2.0solaris/include/config/config/ash/expand/prmt.h
--- busybox-1.2.0/include/config/config/ash/expand/prmt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/expand/prmt.h	2009-04-18 09:26:07.538946939 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_EXPAND_PRMT
diff -rupN busybox-1.2.0/include/config/config/ash/getopts.h busybox-1.2.0solaris/include/config/config/ash/getopts.h
--- busybox-1.2.0/include/config/config/ash/getopts.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/getopts.h	2009-04-18 09:26:07.541249246 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_GETOPTS
diff -rupN busybox-1.2.0/include/config/config/ash/job/control.h busybox-1.2.0solaris/include/config/config/ash/job/control.h
--- busybox-1.2.0/include/config/config/ash/job/control.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/job/control.h	2009-04-18 09:28:20.893379197 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_JOB_CONTROL
diff -rupN busybox-1.2.0/include/config/config/ash/mail.h busybox-1.2.0solaris/include/config/config/ash/mail.h
--- busybox-1.2.0/include/config/config/ash/mail.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/mail.h	2009-04-17 16:46:43.426964141 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_MAIL
diff -rupN busybox-1.2.0/include/config/config/ash/math/support.h busybox-1.2.0solaris/include/config/config/ash/math/support.h
--- busybox-1.2.0/include/config/config/ash/math/support.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/math/support.h	2009-04-18 09:28:20.892295638 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_MATH_SUPPORT
diff -rupN busybox-1.2.0/include/config/config/ash/math/support_64.h busybox-1.2.0solaris/include/config/config/ash/math/support_64.h
--- busybox-1.2.0/include/config/config/ash/math/support_64.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/math/support_64.h	2009-04-18 09:26:07.541453574 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_MATH_SUPPORT_64
diff -rupN busybox-1.2.0/include/config/config/ash/optimize/for/size.h busybox-1.2.0solaris/include/config/config/ash/optimize/for/size.h
--- busybox-1.2.0/include/config/config/ash/optimize/for/size.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/optimize/for/size.h	2009-04-18 09:28:20.890984999 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_OPTIMIZE_FOR_SIZE
diff -rupN busybox-1.2.0/include/config/config/ash/random/support.h busybox-1.2.0solaris/include/config/config/ash/random/support.h
--- busybox-1.2.0/include/config/config/ash/random/support.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/random/support.h	2009-04-18 09:26:07.539139666 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_RANDOM_SUPPORT
diff -rupN busybox-1.2.0/include/config/config/ash/read/nchars.h busybox-1.2.0solaris/include/config/config/ash/read/nchars.h
--- busybox-1.2.0/include/config/config/ash/read/nchars.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/read/nchars.h	2009-04-18 09:26:07.542141521 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_READ_NCHARS
diff -rupN busybox-1.2.0/include/config/config/ash/read/timeout.h busybox-1.2.0solaris/include/config/config/ash/read/timeout.h
--- busybox-1.2.0/include/config/config/ash/read/timeout.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash/read/timeout.h	2009-04-18 09:26:07.541954844 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH_READ_TIMEOUT
diff -rupN busybox-1.2.0/include/config/config/ash.h busybox-1.2.0solaris/include/config/config/ash.h
--- busybox-1.2.0/include/config/config/ash.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ash.h	2009-04-18 09:28:20.893722214 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ASH
diff -rupN busybox-1.2.0/include/config/config/busybox/exec/path.h busybox-1.2.0solaris/include/config/config/busybox/exec/path.h
--- busybox-1.2.0/include/config/config/busybox/exec/path.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/busybox/exec/path.h	2009-04-17 16:46:43.827021168 +0400
@@ -0,0 +1 @@
+#define CONFIG_BUSYBOX_EXEC_PATH "n"
diff -rupN busybox-1.2.0/include/config/config/debug/tftp.h busybox-1.2.0solaris/include/config/config/debug/tftp.h
--- busybox-1.2.0/include/config/config/debug/tftp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/debug/tftp.h	2009-04-17 16:46:43.449504719 +0400
@@ -0,0 +1 @@
+#undef CONFIG_DEBUG_TFTP
diff -rupN busybox-1.2.0/include/config/config/debug.h busybox-1.2.0solaris/include/config/config/debug.h
--- busybox-1.2.0/include/config/config/debug.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/debug.h	2009-04-17 16:46:43.826078158 +0400
@@ -0,0 +1 @@
+#undef CONFIG_DEBUG
diff -rupN busybox-1.2.0/include/config/config/devfsd/verbose.h busybox-1.2.0solaris/include/config/config/devfsd/verbose.h
--- busybox-1.2.0/include/config/config/devfsd/verbose.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/devfsd/verbose.h	2009-04-17 16:46:43.511733588 +0400
@@ -0,0 +1 @@
+#undef CONFIG_DEVFSD_VERBOSE
diff -rupN busybox-1.2.0/include/config/config/e2label.h busybox-1.2.0solaris/include/config/config/e2label.h
--- busybox-1.2.0/include/config/config/e2label.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/e2label.h	2009-04-17 16:46:43.709686169 +0400
@@ -0,0 +1 @@
+#undef CONFIG_E2LABEL
diff -rupN busybox-1.2.0/include/config/config/feature/aix/label.h busybox-1.2.0solaris/include/config/config/feature/aix/label.h
--- busybox-1.2.0/include/config/config/feature/aix/label.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/aix/label.h	2009-04-17 16:46:43.534067515 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_AIX_LABEL
diff -rupN busybox-1.2.0/include/config/config/feature/ar/long/filenames.h busybox-1.2.0solaris/include/config/config/feature/ar/long/filenames.h
--- busybox-1.2.0/include/config/config/feature/ar/long/filenames.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ar/long/filenames.h	2009-04-17 16:46:43.822658703 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_AR_LONG_FILENAMES
diff -rupN busybox-1.2.0/include/config/config/feature/autowidth.h busybox-1.2.0solaris/include/config/config/feature/autowidth.h
--- busybox-1.2.0/include/config/config/feature/autowidth.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/autowidth.h	2009-04-17 16:46:43.756882837 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_AUTOWIDTH 1
diff -rupN busybox-1.2.0/include/config/config/feature/awk/math.h busybox-1.2.0solaris/include/config/config/feature/awk/math.h
--- busybox-1.2.0/include/config/config/feature/awk/math.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/awk/math.h	2009-04-17 16:46:43.741763744 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_AWK_MATH 1
diff -rupN busybox-1.2.0/include/config/config/feature/buffers/go/in/bss.h busybox-1.2.0solaris/include/config/config/feature/buffers/go/in/bss.h
--- busybox-1.2.0/include/config/config/feature/buffers/go/in/bss.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/buffers/go/in/bss.h	2009-04-17 16:46:43.836928855 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_BUFFERS_GO_IN_BSS
diff -rupN busybox-1.2.0/include/config/config/feature/buffers/go/on/stack.h busybox-1.2.0solaris/include/config/config/feature/buffers/go/on/stack.h
--- busybox-1.2.0/include/config/config/feature/buffers/go/on/stack.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/buffers/go/on/stack.h	2009-04-17 16:46:43.837538682 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_BUFFERS_GO_ON_STACK
diff -rupN busybox-1.2.0/include/config/config/feature/check/tainted/module.h busybox-1.2.0solaris/include/config/config/feature/check/tainted/module.h
--- busybox-1.2.0/include/config/config/feature/check/tainted/module.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/check/tainted/module.h	2009-04-17 16:46:43.702567132 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_CHECK_TAINTED_MODULE
diff -rupN busybox-1.2.0/include/config/config/feature/clean/up.h busybox-1.2.0solaris/include/config/config/feature/clean/up.h
--- busybox-1.2.0/include/config/config/feature/clean/up.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/clean/up.h	2009-04-17 16:46:43.831950368 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_CLEAN_UP
diff -rupN busybox-1.2.0/include/config/config/feature/command/editing/vi.h busybox-1.2.0solaris/include/config/config/feature/command/editing/vi.h
--- busybox-1.2.0/include/config/config/feature/command/editing/vi.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/command/editing/vi.h	2009-04-17 16:46:43.421630841 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_COMMAND_EDITING_VI
diff -rupN busybox-1.2.0/include/config/config/feature/command/editing.h busybox-1.2.0solaris/include/config/config/feature/command/editing.h
--- busybox-1.2.0/include/config/config/feature/command/editing.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/command/editing.h	2009-04-17 16:46:43.422508770 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_COMMAND_EDITING
diff -rupN busybox-1.2.0/include/config/config/feature/command/history.h busybox-1.2.0solaris/include/config/config/feature/command/history.h
--- busybox-1.2.0/include/config/config/feature/command/history.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/command/history.h	2009-04-17 16:46:43.421126763 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_COMMAND_HISTORY
diff -rupN busybox-1.2.0/include/config/config/feature/command/savehistory.h busybox-1.2.0solaris/include/config/config/feature/command/savehistory.h
--- busybox-1.2.0/include/config/config/feature/command/savehistory.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/command/savehistory.h	2009-04-17 16:46:43.420751836 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_COMMAND_SAVEHISTORY
diff -rupN busybox-1.2.0/include/config/config/feature/command/tab/completion.h busybox-1.2.0solaris/include/config/config/feature/command/tab/completion.h
--- busybox-1.2.0/include/config/config/feature/command/tab/completion.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/command/tab/completion.h	2009-04-17 16:46:43.420435093 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_COMMAND_TAB_COMPLETION
diff -rupN busybox-1.2.0/include/config/config/feature/command/username/completion.h busybox-1.2.0solaris/include/config/config/feature/command/username/completion.h
--- busybox-1.2.0/include/config/config/feature/command/username/completion.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/command/username/completion.h	2009-04-17 16:46:43.419823879 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_COMMAND_USERNAME_COMPLETION
diff -rupN busybox-1.2.0/include/config/config/feature/deb/tar/bz2.h busybox-1.2.0solaris/include/config/config/feature/deb/tar/bz2.h
--- busybox-1.2.0/include/config/config/feature/deb/tar/bz2.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/deb/tar/bz2.h	2009-04-17 16:46:43.807861748 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_DEB_TAR_BZ2
diff -rupN busybox-1.2.0/include/config/config/feature/deb/tar/gz.h busybox-1.2.0solaris/include/config/config/feature/deb/tar/gz.h
--- busybox-1.2.0/include/config/config/feature/deb/tar/gz.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/deb/tar/gz.h	2009-04-17 16:46:43.808262532 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_DEB_TAR_GZ
diff -rupN busybox-1.2.0/include/config/config/feature/devfs.h busybox-1.2.0solaris/include/config/config/feature/devfs.h
--- busybox-1.2.0/include/config/config/feature/devfs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/devfs.h	2009-04-17 16:46:43.510829538 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_DEVFS
diff -rupN busybox-1.2.0/include/config/config/feature/devpts.h busybox-1.2.0solaris/include/config/config/feature/devpts.h
--- busybox-1.2.0/include/config/config/feature/devpts.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/devpts.h	2009-04-17 16:46:43.832258156 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_DEVPTS
diff -rupN busybox-1.2.0/include/config/config/feature/du/default/blocksize_1k.h busybox-1.2.0solaris/include/config/config/feature/du/default/blocksize_1k.h
--- busybox-1.2.0/include/config/config/feature/du/default/blocksize_1k.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/du/default/blocksize_1k.h	2009-04-18 09:51:41.629145377 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_DU_DEFAULT_BLOCKSIZE_1K 1
diff -rupN busybox-1.2.0/include/config/config/feature/extra/quiet.h busybox-1.2.0solaris/include/config/config/feature/extra/quiet.h
--- busybox-1.2.0/include/config/config/feature/extra/quiet.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/extra/quiet.h	2009-04-17 16:46:43.720266928 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_EXTRA_QUIET
diff -rupN busybox-1.2.0/include/config/config/feature/fancy/echo.h busybox-1.2.0solaris/include/config/config/feature/fancy/echo.h
--- busybox-1.2.0/include/config/config/feature/fancy/echo.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fancy/echo.h	2009-04-17 16:46:43.793421178 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FANCY_ECHO 1
diff -rupN busybox-1.2.0/include/config/config/feature/fancy/ping.h busybox-1.2.0solaris/include/config/config/feature/fancy/ping.h
--- busybox-1.2.0/include/config/config/feature/fancy/ping.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fancy/ping.h	2009-04-17 16:46:43.456724741 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_FANCY_PING
diff -rupN busybox-1.2.0/include/config/config/feature/fancy/ping6.h busybox-1.2.0solaris/include/config/config/feature/fancy/ping6.h
--- busybox-1.2.0/include/config/config/feature/fancy/ping6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fancy/ping6.h	2009-04-17 16:46:43.456113223 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_FANCY_PING6
diff -rupN busybox-1.2.0/include/config/config/feature/fancy/sleep.h busybox-1.2.0solaris/include/config/config/feature/fancy/sleep.h
--- busybox-1.2.0/include/config/config/feature/fancy/sleep.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fancy/sleep.h	2009-04-17 16:46:43.770649880 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_FANCY_SLEEP
diff -rupN busybox-1.2.0/include/config/config/feature/fancy/tail.h busybox-1.2.0solaris/include/config/config/feature/fancy/tail.h
--- busybox-1.2.0/include/config/config/feature/fancy/tail.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fancy/tail.h	2009-04-17 16:46:43.766355349 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_FANCY_TAIL
diff -rupN busybox-1.2.0/include/config/config/feature/fbset/fancy.h busybox-1.2.0solaris/include/config/config/feature/fbset/fancy.h
--- busybox-1.2.0/include/config/config/feature/fbset/fancy.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fbset/fancy.h	2009-04-17 16:46:43.536371054 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_FBSET_FANCY
diff -rupN busybox-1.2.0/include/config/config/feature/fbset/readmode.h busybox-1.2.0solaris/include/config/config/feature/fbset/readmode.h
--- busybox-1.2.0/include/config/config/feature/fbset/readmode.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fbset/readmode.h	2009-04-17 16:46:43.536000533 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_FBSET_READMODE
diff -rupN busybox-1.2.0/include/config/config/feature/fdisk/advanced.h busybox-1.2.0solaris/include/config/config/feature/fdisk/advanced.h
--- busybox-1.2.0/include/config/config/feature/fdisk/advanced.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fdisk/advanced.h	2009-04-17 16:46:43.531913781 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_FDISK_ADVANCED
diff -rupN busybox-1.2.0/include/config/config/feature/fdisk/writable.h busybox-1.2.0solaris/include/config/config/feature/fdisk/writable.h
--- busybox-1.2.0/include/config/config/feature/fdisk/writable.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/fdisk/writable.h	2009-04-17 16:46:43.534413088 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_FDISK_WRITABLE
diff -rupN busybox-1.2.0/include/config/config/feature/find/exec.h busybox-1.2.0solaris/include/config/config/feature/find/exec.h
--- busybox-1.2.0/include/config/config/feature/find/exec.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/exec.h	2009-04-17 16:46:43.728985928 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_EXEC 1
diff -rupN busybox-1.2.0/include/config/config/feature/find/inum.h busybox-1.2.0solaris/include/config/config/feature/find/inum.h
--- busybox-1.2.0/include/config/config/feature/find/inum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/inum.h	2009-04-17 16:46:43.729715229 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_INUM 1
diff -rupN busybox-1.2.0/include/config/config/feature/find/mmin.h busybox-1.2.0solaris/include/config/config/feature/find/mmin.h
--- busybox-1.2.0/include/config/config/feature/find/mmin.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/mmin.h	2009-04-17 16:46:43.733080815 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_MMIN 1
diff -rupN busybox-1.2.0/include/config/config/feature/find/mtime.h busybox-1.2.0solaris/include/config/config/feature/find/mtime.h
--- busybox-1.2.0/include/config/config/feature/find/mtime.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/mtime.h	2009-04-17 16:46:43.733794233 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_MTIME 1
diff -rupN busybox-1.2.0/include/config/config/feature/find/newer.h busybox-1.2.0solaris/include/config/config/feature/find/newer.h
--- busybox-1.2.0/include/config/config/feature/find/newer.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/newer.h	2009-04-17 16:46:43.730534936 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_NEWER 1
diff -rupN busybox-1.2.0/include/config/config/feature/find/perm.h busybox-1.2.0solaris/include/config/config/feature/find/perm.h
--- busybox-1.2.0/include/config/config/feature/find/perm.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/perm.h	2009-04-17 16:46:43.732370184 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_PERM 1
diff -rupN busybox-1.2.0/include/config/config/feature/find/print0.h busybox-1.2.0solaris/include/config/config/feature/find/print0.h
--- busybox-1.2.0/include/config/config/feature/find/print0.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/print0.h	2009-04-17 16:46:43.734470267 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_PRINT0 1
diff -rupN busybox-1.2.0/include/config/config/feature/find/type.h busybox-1.2.0solaris/include/config/config/feature/find/type.h
--- busybox-1.2.0/include/config/config/feature/find/type.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/type.h	2009-04-17 16:46:43.731680146 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_TYPE 1
diff -rupN busybox-1.2.0/include/config/config/feature/find/xdev.h busybox-1.2.0solaris/include/config/config/feature/find/xdev.h
--- busybox-1.2.0/include/config/config/feature/find/xdev.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/find/xdev.h	2009-04-17 16:46:43.730879638 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_FIND_XDEV 1
diff -rupN busybox-1.2.0/include/config/config/feature/gunzip/uncompress.h busybox-1.2.0solaris/include/config/config/feature/gunzip/uncompress.h
--- busybox-1.2.0/include/config/config/feature/gunzip/uncompress.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/gunzip/uncompress.h	2009-04-17 16:46:43.819707416 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_GUNZIP_UNCOMPRESS
diff -rupN busybox-1.2.0/include/config/config/feature/hdparm/get/identity.h busybox-1.2.0solaris/include/config/config/feature/hdparm/get/identity.h
--- busybox-1.2.0/include/config/config/feature/hdparm/get/identity.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/hdparm/get/identity.h	2009-04-17 16:46:43.507174503 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HDPARM_GET_IDENTITY
diff -rupN busybox-1.2.0/include/config/config/feature/hdparm/hdio/drive/reset.h busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/drive/reset.h
--- busybox-1.2.0/include/config/config/feature/hdparm/hdio/drive/reset.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/drive/reset.h	2009-04-17 16:46:43.502344456 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HDPARM_HDIO_DRIVE_RESET
diff -rupN busybox-1.2.0/include/config/config/feature/hdparm/hdio/getset/dma.h busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/getset/dma.h
--- busybox-1.2.0/include/config/config/feature/hdparm/hdio/getset/dma.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/getset/dma.h	2009-04-17 16:46:43.499914514 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HDPARM_HDIO_GETSET_DMA
diff -rupN busybox-1.2.0/include/config/config/feature/hdparm/hdio/scan/hwif.h busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/scan/hwif.h
--- busybox-1.2.0/include/config/config/feature/hdparm/hdio/scan/hwif.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/scan/hwif.h	2009-04-17 16:46:43.505490624 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HDPARM_HDIO_SCAN_HWIF
diff -rupN busybox-1.2.0/include/config/config/feature/hdparm/hdio/tristate/hwif.h busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/tristate/hwif.h
--- busybox-1.2.0/include/config/config/feature/hdparm/hdio/tristate/hwif.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/tristate/hwif.h	2009-04-17 16:46:43.501170104 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HDPARM_HDIO_TRISTATE_HWIF
diff -rupN busybox-1.2.0/include/config/config/feature/hdparm/hdio/unregister/hwif.h busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/unregister/hwif.h
--- busybox-1.2.0/include/config/config/feature/hdparm/hdio/unregister/hwif.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/hdparm/hdio/unregister/hwif.h	2009-04-17 16:46:43.503507531 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/auth/md5.h busybox-1.2.0solaris/include/config/config/feature/httpd/auth/md5.h
--- busybox-1.2.0/include/config/config/feature/httpd/auth/md5.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/auth/md5.h	2009-04-17 16:46:43.482449115 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_AUTH_MD5
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/basic/auth.h busybox-1.2.0solaris/include/config/config/feature/httpd/basic/auth.h
--- busybox-1.2.0/include/config/config/feature/httpd/basic/auth.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/basic/auth.h	2009-04-17 16:46:43.484111365 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_BASIC_AUTH
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/cgi.h busybox-1.2.0solaris/include/config/config/feature/httpd/cgi.h
--- busybox-1.2.0/include/config/config/feature/httpd/cgi.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/cgi.h	2009-04-17 16:46:43.480063500 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_CGI
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/config/with/mime/types.h busybox-1.2.0solaris/include/config/config/feature/httpd/config/with/mime/types.h
--- busybox-1.2.0/include/config/config/feature/httpd/config/with/mime/types.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/config/with/mime/types.h	2009-04-17 16:46:43.480759249 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_CONFIG_WITH_MIME_TYPES
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/config/with/script/interpr.h busybox-1.2.0solaris/include/config/config/feature/httpd/config/with/script/interpr.h
--- busybox-1.2.0/include/config/config/feature/httpd/config/with/script/interpr.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/config/with/script/interpr.h	2009-04-17 16:46:43.479303755 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/encode/url/str.h busybox-1.2.0solaris/include/config/config/feature/httpd/encode/url/str.h
--- busybox-1.2.0/include/config/config/feature/httpd/encode/url/str.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/encode/url/str.h	2009-04-17 16:46:43.476921509 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_ENCODE_URL_STR
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/reload/config/sighup.h busybox-1.2.0solaris/include/config/config/feature/httpd/reload/config/sighup.h
--- busybox-1.2.0/include/config/config/feature/httpd/reload/config/sighup.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/reload/config/sighup.h	2009-04-17 16:46:43.485927714 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_RELOAD_CONFIG_SIGHUP
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/set/remote/port/to/env.h busybox-1.2.0solaris/include/config/config/feature/httpd/set/remote/port/to/env.h
--- busybox-1.2.0/include/config/config/feature/httpd/set/remote/port/to/env.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/set/remote/port/to/env.h	2009-04-17 16:46:43.478387510 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_SET_REMOTE_PORT_TO_ENV
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/setuid.h busybox-1.2.0solaris/include/config/config/feature/httpd/setuid.h
--- busybox-1.2.0/include/config/config/feature/httpd/setuid.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/setuid.h	2009-04-17 16:46:43.485161976 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_SETUID
diff -rupN busybox-1.2.0/include/config/config/feature/httpd/without/inetd.h busybox-1.2.0solaris/include/config/config/feature/httpd/without/inetd.h
--- busybox-1.2.0/include/config/config/feature/httpd/without/inetd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/httpd/without/inetd.h	2009-04-17 16:46:43.487679013 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HTTPD_WITHOUT_INETD
diff -rupN busybox-1.2.0/include/config/config/feature/human/readable.h busybox-1.2.0solaris/include/config/config/feature/human/readable.h
--- busybox-1.2.0/include/config/config/feature/human/readable.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/human/readable.h	2009-04-17 16:46:43.756267649 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HUMAN_READABLE
diff -rupN busybox-1.2.0/include/config/config/feature/hwclock/adjtime/fhs.h busybox-1.2.0solaris/include/config/config/feature/hwclock/adjtime/fhs.h
--- busybox-1.2.0/include/config/config/feature/hwclock/adjtime/fhs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/hwclock/adjtime/fhs.h	2009-04-17 16:46:43.527663185 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_HWCLOCK_ADJTIME_FHS
diff -rupN busybox-1.2.0/include/config/config/feature/ifconfig/broadcast/plus.h busybox-1.2.0solaris/include/config/config/feature/ifconfig/broadcast/plus.h
--- busybox-1.2.0/include/config/config/feature/ifconfig/broadcast/plus.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifconfig/broadcast/plus.h	2009-04-17 16:46:43.471902593 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFCONFIG_BROADCAST_PLUS
diff -rupN busybox-1.2.0/include/config/config/feature/ifconfig/hw.h busybox-1.2.0solaris/include/config/config/feature/ifconfig/hw.h
--- busybox-1.2.0/include/config/config/feature/ifconfig/hw.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifconfig/hw.h	2009-04-17 16:46:43.472240377 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFCONFIG_HW
diff -rupN busybox-1.2.0/include/config/config/feature/ifconfig/memstart/ioaddr/irq.h busybox-1.2.0solaris/include/config/config/feature/ifconfig/memstart/ioaddr/irq.h
--- busybox-1.2.0/include/config/config/feature/ifconfig/memstart/ioaddr/irq.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifconfig/memstart/ioaddr/irq.h	2009-04-17 16:46:43.472964468 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFCONFIG_MEMSTART_IOADDR_IRQ
diff -rupN busybox-1.2.0/include/config/config/feature/ifconfig/slip.h busybox-1.2.0solaris/include/config/config/feature/ifconfig/slip.h
--- busybox-1.2.0/include/config/config/feature/ifconfig/slip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifconfig/slip.h	2009-04-17 16:46:43.473303139 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFCONFIG_SLIP
diff -rupN busybox-1.2.0/include/config/config/feature/ifconfig/status.h busybox-1.2.0solaris/include/config/config/feature/ifconfig/status.h
--- busybox-1.2.0/include/config/config/feature/ifconfig/status.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifconfig/status.h	2009-04-17 16:46:43.473628539 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFCONFIG_STATUS
diff -rupN busybox-1.2.0/include/config/config/feature/ifupdown/ip.h busybox-1.2.0solaris/include/config/config/feature/ifupdown/ip.h
--- busybox-1.2.0/include/config/config/feature/ifupdown/ip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifupdown/ip.h	2009-04-17 16:46:43.470866088 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFUPDOWN_IP
diff -rupN busybox-1.2.0/include/config/config/feature/ifupdown/ipv4.h busybox-1.2.0solaris/include/config/config/feature/ifupdown/ipv4.h
--- busybox-1.2.0/include/config/config/feature/ifupdown/ipv4.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifupdown/ipv4.h	2009-04-17 16:46:43.470522650 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFUPDOWN_IPV4
diff -rupN busybox-1.2.0/include/config/config/feature/ifupdown/ipv6.h busybox-1.2.0solaris/include/config/config/feature/ifupdown/ipv6.h
--- busybox-1.2.0/include/config/config/feature/ifupdown/ipv6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifupdown/ipv6.h	2009-04-17 16:46:43.469762202 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFUPDOWN_IPV6
diff -rupN busybox-1.2.0/include/config/config/feature/ifupdown/mapping.h busybox-1.2.0solaris/include/config/config/feature/ifupdown/mapping.h
--- busybox-1.2.0/include/config/config/feature/ifupdown/mapping.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ifupdown/mapping.h	2009-04-17 16:46:43.468696354 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IFUPDOWN_MAPPING
diff -rupN busybox-1.2.0/include/config/config/feature/inetd/rpc.h busybox-1.2.0solaris/include/config/config/feature/inetd/rpc.h
--- busybox-1.2.0/include/config/config/feature/inetd/rpc.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/inetd/rpc.h	2009-04-17 16:46:43.465466023 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INETD_RPC
diff -rupN busybox-1.2.0/include/config/config/feature/inetd/support/builtin/chargen.h busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/chargen.h
--- busybox-1.2.0/include/config/config/feature/inetd/support/builtin/chargen.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/chargen.h	2009-04-17 16:46:43.466176527 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN
diff -rupN busybox-1.2.0/include/config/config/feature/inetd/support/builtin/daytime.h busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/daytime.h
--- busybox-1.2.0/include/config/config/feature/inetd/support/builtin/daytime.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/daytime.h	2009-04-17 16:46:43.466633082 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DAYTIME
diff -rupN busybox-1.2.0/include/config/config/feature/inetd/support/builtin/discard.h busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/discard.h
--- busybox-1.2.0/include/config/config/feature/inetd/support/builtin/discard.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/discard.h	2009-04-17 16:46:43.467440485 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_DISCARD
diff -rupN busybox-1.2.0/include/config/config/feature/inetd/support/builtin/echo.h busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/echo.h
--- busybox-1.2.0/include/config/config/feature/inetd/support/builtin/echo.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/echo.h	2009-04-17 16:46:43.467884894 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_ECHO
diff -rupN busybox-1.2.0/include/config/config/feature/inetd/support/builtin/time.h busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/time.h
--- busybox-1.2.0/include/config/config/feature/inetd/support/builtin/time.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/inetd/support/builtin/time.h	2009-04-17 16:46:43.467037964 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INETD_SUPPORT_BUILTIN_TIME
diff -rupN busybox-1.2.0/include/config/config/feature/init/coredumps.h busybox-1.2.0solaris/include/config/config/feature/init/coredumps.h
--- busybox-1.2.0/include/config/config/feature/init/coredumps.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/init/coredumps.h	2009-04-17 16:46:43.719614135 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INIT_COREDUMPS
diff -rupN busybox-1.2.0/include/config/config/feature/init/sctty.h busybox-1.2.0solaris/include/config/config/feature/init/sctty.h
--- busybox-1.2.0/include/config/config/feature/init/sctty.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/init/sctty.h	2009-04-17 16:46:43.720677046 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INIT_SCTTY
diff -rupN busybox-1.2.0/include/config/config/feature/insmod/ksymoops/symbols.h busybox-1.2.0solaris/include/config/config/feature/insmod/ksymoops/symbols.h
--- busybox-1.2.0/include/config/config/feature/insmod/ksymoops/symbols.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/insmod/ksymoops/symbols.h	2009-04-17 16:46:43.707158110 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS
diff -rupN busybox-1.2.0/include/config/config/feature/insmod/load/map/full.h busybox-1.2.0solaris/include/config/config/feature/insmod/load/map/full.h
--- busybox-1.2.0/include/config/config/feature/insmod/load/map/full.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/insmod/load/map/full.h	2009-04-17 16:46:43.705878347 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL
diff -rupN busybox-1.2.0/include/config/config/feature/insmod/load/map.h busybox-1.2.0solaris/include/config/config/feature/insmod/load/map.h
--- busybox-1.2.0/include/config/config/feature/insmod/load/map.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/insmod/load/map.h	2009-04-17 16:46:43.706294793 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INSMOD_LOAD_MAP
diff -rupN busybox-1.2.0/include/config/config/feature/insmod/loadinkmem.h busybox-1.2.0solaris/include/config/config/feature/insmod/loadinkmem.h
--- busybox-1.2.0/include/config/config/feature/insmod/loadinkmem.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/insmod/loadinkmem.h	2009-04-17 16:46:43.706657566 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INSMOD_LOADINKMEM
diff -rupN busybox-1.2.0/include/config/config/feature/insmod/version/checking.h busybox-1.2.0solaris/include/config/config/feature/insmod/version/checking.h
--- busybox-1.2.0/include/config/config/feature/insmod/version/checking.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/insmod/version/checking.h	2009-04-17 16:46:43.707685740 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INSMOD_VERSION_CHECKING
diff -rupN busybox-1.2.0/include/config/config/feature/installer.h busybox-1.2.0solaris/include/config/config/feature/installer.h
--- busybox-1.2.0/include/config/config/feature/installer.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/installer.h	2009-04-17 16:46:43.834364506 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_INSTALLER
diff -rupN busybox-1.2.0/include/config/config/feature/ip/address.h busybox-1.2.0solaris/include/config/config/feature/ip/address.h
--- busybox-1.2.0/include/config/config/feature/ip/address.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ip/address.h	2009-04-17 16:46:43.464672038 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IP_ADDRESS
diff -rupN busybox-1.2.0/include/config/config/feature/ip/link.h busybox-1.2.0solaris/include/config/config/feature/ip/link.h
--- busybox-1.2.0/include/config/config/feature/ip/link.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ip/link.h	2009-04-17 16:46:43.464310209 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IP_LINK
diff -rupN busybox-1.2.0/include/config/config/feature/ip/route.h busybox-1.2.0solaris/include/config/config/feature/ip/route.h
--- busybox-1.2.0/include/config/config/feature/ip/route.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ip/route.h	2009-04-17 16:46:43.463927628 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IP_ROUTE
diff -rupN busybox-1.2.0/include/config/config/feature/ip/tunnel.h busybox-1.2.0solaris/include/config/config/feature/ip/tunnel.h
--- busybox-1.2.0/include/config/config/feature/ip/tunnel.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ip/tunnel.h	2009-04-17 16:46:43.463593460 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IP_TUNNEL
diff -rupN busybox-1.2.0/include/config/config/feature/ipc/syslog/buffer/size.h busybox-1.2.0solaris/include/config/config/feature/ipc/syslog/buffer/size.h
--- busybox-1.2.0/include/config/config/feature/ipc/syslog/buffer/size.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ipc/syslog/buffer/size.h	2009-04-17 16:46:43.416920363 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_IPC_SYSLOG_BUFFER_SIZE
diff -rupN busybox-1.2.0/include/config/config/feature/ipc/syslog.h busybox-1.2.0solaris/include/config/config/feature/ipc/syslog.h
--- busybox-1.2.0/include/config/config/feature/ipc/syslog.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ipc/syslog.h	2009-04-17 16:46:43.417232966 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IPC_SYSLOG
diff -rupN busybox-1.2.0/include/config/config/feature/ipcalc/fancy.h busybox-1.2.0solaris/include/config/config/feature/ipcalc/fancy.h
--- busybox-1.2.0/include/config/config/feature/ipcalc/fancy.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ipcalc/fancy.h	2009-04-17 16:46:43.461672525 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IPCALC_FANCY
diff -rupN busybox-1.2.0/include/config/config/feature/ipv6.h busybox-1.2.0solaris/include/config/config/feature/ipv6.h
--- busybox-1.2.0/include/config/config/feature/ipv6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ipv6.h	2009-04-17 16:46:43.491749280 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_IPV6
diff -rupN busybox-1.2.0/include/config/config/feature/less/brackets.h busybox-1.2.0solaris/include/config/config/feature/less/brackets.h
--- busybox-1.2.0/include/config/config/feature/less/brackets.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/less/brackets.h	2009-04-17 16:46:43.509284849 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LESS_BRACKETS 1
diff -rupN busybox-1.2.0/include/config/config/feature/less/flagcs.h busybox-1.2.0solaris/include/config/config/feature/less/flagcs.h
--- busybox-1.2.0/include/config/config/feature/less/flagcs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/less/flagcs.h	2009-04-17 16:46:43.508625751 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_LESS_FLAGCS
diff -rupN busybox-1.2.0/include/config/config/feature/less/flags.h busybox-1.2.0solaris/include/config/config/feature/less/flags.h
--- busybox-1.2.0/include/config/config/feature/less/flags.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/less/flags.h	2009-04-17 16:46:43.508952892 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LESS_FLAGS 1
diff -rupN busybox-1.2.0/include/config/config/feature/less/marks.h busybox-1.2.0solaris/include/config/config/feature/less/marks.h
--- busybox-1.2.0/include/config/config/feature/less/marks.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/less/marks.h	2009-04-17 16:46:43.508296930 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_LESS_MARKS
diff -rupN busybox-1.2.0/include/config/config/feature/less/regexp.h busybox-1.2.0solaris/include/config/config/feature/less/regexp.h
--- busybox-1.2.0/include/config/config/feature/less/regexp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/less/regexp.h	2009-04-17 16:46:43.507964939 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_LESS_REGEXP
diff -rupN busybox-1.2.0/include/config/config/feature/logread/reduced/locking.h busybox-1.2.0solaris/include/config/config/feature/logread/reduced/locking.h
--- busybox-1.2.0/include/config/config/feature/logread/reduced/locking.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/logread/reduced/locking.h	2009-04-17 16:46:43.415873913 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_LOGREAD_REDUCED_LOCKING
diff -rupN busybox-1.2.0/include/config/config/feature/ls/color/is/default.h busybox-1.2.0solaris/include/config/config/feature/ls/color/is/default.h
--- busybox-1.2.0/include/config/config/feature/ls/color/is/default.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ls/color/is/default.h	2009-04-17 16:46:43.781859778 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_LS_COLOR_IS_DEFAULT
diff -rupN busybox-1.2.0/include/config/config/feature/ls/color.h busybox-1.2.0solaris/include/config/config/feature/ls/color.h
--- busybox-1.2.0/include/config/config/feature/ls/color.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ls/color.h	2009-04-17 16:46:43.782246051 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LS_COLOR 1
diff -rupN busybox-1.2.0/include/config/config/feature/ls/filetypes.h busybox-1.2.0solaris/include/config/config/feature/ls/filetypes.h
--- busybox-1.2.0/include/config/config/feature/ls/filetypes.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ls/filetypes.h	2009-04-17 16:46:43.786037260 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LS_FILETYPES 1
diff -rupN busybox-1.2.0/include/config/config/feature/ls/followlinks.h busybox-1.2.0solaris/include/config/config/feature/ls/followlinks.h
--- busybox-1.2.0/include/config/config/feature/ls/followlinks.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ls/followlinks.h	2009-04-17 16:46:43.785692461 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LS_FOLLOWLINKS 1
diff -rupN busybox-1.2.0/include/config/config/feature/ls/recursive.h busybox-1.2.0solaris/include/config/config/feature/ls/recursive.h
--- busybox-1.2.0/include/config/config/feature/ls/recursive.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ls/recursive.h	2009-04-17 16:46:43.785333200 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LS_RECURSIVE 1
diff -rupN busybox-1.2.0/include/config/config/feature/ls/sortfiles.h busybox-1.2.0solaris/include/config/config/feature/ls/sortfiles.h
--- busybox-1.2.0/include/config/config/feature/ls/sortfiles.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ls/sortfiles.h	2009-04-17 16:46:43.784630260 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LS_SORTFILES 1
diff -rupN busybox-1.2.0/include/config/config/feature/ls/timestamps.h busybox-1.2.0solaris/include/config/config/feature/ls/timestamps.h
--- busybox-1.2.0/include/config/config/feature/ls/timestamps.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ls/timestamps.h	2009-04-17 16:46:43.783460377 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LS_TIMESTAMPS 1
diff -rupN busybox-1.2.0/include/config/config/feature/ls/username.h busybox-1.2.0solaris/include/config/config/feature/ls/username.h
--- busybox-1.2.0/include/config/config/feature/ls/username.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/ls/username.h	2009-04-17 16:46:43.782614940 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_LS_USERNAME 1
diff -rupN busybox-1.2.0/include/config/config/feature/lsmod/pretty_2_6/output.h busybox-1.2.0solaris/include/config/config/feature/lsmod/pretty_2_6/output.h
--- busybox-1.2.0/include/config/config/feature/lsmod/pretty_2_6/output.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/lsmod/pretty_2_6/output.h	2009-04-17 16:46:43.704428369 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_LSMOD_PRETTY_2_6_OUTPUT
diff -rupN busybox-1.2.0/include/config/config/feature/lzma/fast.h busybox-1.2.0solaris/include/config/config/feature/lzma/fast.h
--- busybox-1.2.0/include/config/config/feature/lzma/fast.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/lzma/fast.h	2009-04-17 16:46:43.809551062 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_LZMA_FAST
diff -rupN busybox-1.2.0/include/config/config/feature/makedevs/leaf.h busybox-1.2.0solaris/include/config/config/feature/makedevs/leaf.h
--- busybox-1.2.0/include/config/config/feature/makedevs/leaf.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/makedevs/leaf.h	2009-04-17 16:46:43.497821427 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_MAKEDEVS_LEAF
diff -rupN busybox-1.2.0/include/config/config/feature/makedevs/table.h busybox-1.2.0solaris/include/config/config/feature/makedevs/table.h
--- busybox-1.2.0/include/config/config/feature/makedevs/table.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/makedevs/table.h	2009-04-17 16:46:43.497477922 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_MAKEDEVS_TABLE
diff -rupN busybox-1.2.0/include/config/config/feature/md5/sha1/sum/check.h busybox-1.2.0solaris/include/config/config/feature/md5/sha1/sum/check.h
--- busybox-1.2.0/include/config/config/feature/md5/sha1/sum/check.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/md5/sha1/sum/check.h	2009-04-17 16:46:43.754680929 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_MD5_SHA1_SUM_CHECK
diff -rupN busybox-1.2.0/include/config/config/feature/minix2.h busybox-1.2.0solaris/include/config/config/feature/minix2.h
--- busybox-1.2.0/include/config/config/feature/minix2.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/minix2.h	2009-04-17 16:46:43.529557820 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_MINIX2
diff -rupN busybox-1.2.0/include/config/config/feature/mount/loop.h busybox-1.2.0solaris/include/config/config/feature/mount/loop.h
--- busybox-1.2.0/include/config/config/feature/mount/loop.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/mount/loop.h	2009-04-17 16:46:43.518783185 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_MOUNT_LOOP
diff -rupN busybox-1.2.0/include/config/config/feature/mtab/support.h busybox-1.2.0solaris/include/config/config/feature/mtab/support.h
--- busybox-1.2.0/include/config/config/feature/mtab/support.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/mtab/support.h	2009-04-17 16:46:43.517812543 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_MTAB_SUPPORT
diff -rupN busybox-1.2.0/include/config/config/feature/osf/label.h busybox-1.2.0solaris/include/config/config/feature/osf/label.h
--- busybox-1.2.0/include/config/config/feature/osf/label.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/osf/label.h	2009-04-17 16:46:43.532412919 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_OSF_LABEL
diff -rupN busybox-1.2.0/include/config/config/feature/query/module/interface.h busybox-1.2.0solaris/include/config/config/feature/query/module/interface.h
--- busybox-1.2.0/include/config/config/feature/query/module/interface.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/query/module/interface.h	2009-04-17 16:46:43.537662967 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_QUERY_MODULE_INTERFACE
diff -rupN busybox-1.2.0/include/config/config/feature/readlink/follow.h busybox-1.2.0solaris/include/config/config/feature/readlink/follow.h
--- busybox-1.2.0/include/config/config/feature/readlink/follow.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/readlink/follow.h	2009-04-17 16:46:43.747755188 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_READLINK_FOLLOW
diff -rupN busybox-1.2.0/include/config/config/feature/remote/log.h busybox-1.2.0solaris/include/config/config/feature/remote/log.h
--- busybox-1.2.0/include/config/config/feature/remote/log.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/remote/log.h	2009-04-17 16:46:43.417661066 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_REMOTE_LOG
diff -rupN busybox-1.2.0/include/config/config/feature/rotate/logfile.h busybox-1.2.0solaris/include/config/config/feature/rotate/logfile.h
--- busybox-1.2.0/include/config/config/feature/rotate/logfile.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/rotate/logfile.h	2009-04-17 16:46:43.418102437 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_ROTATE_LOGFILE
diff -rupN busybox-1.2.0/include/config/config/feature/securetty.h busybox-1.2.0solaris/include/config/config/feature/securetty.h
--- busybox-1.2.0/include/config/config/feature/securetty.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/securetty.h	2009-04-17 16:46:43.713104132 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SECURETTY
diff -rupN busybox-1.2.0/include/config/config/feature/sgi/label.h busybox-1.2.0solaris/include/config/config/feature/sgi/label.h
--- busybox-1.2.0/include/config/config/feature/sgi/label.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/sgi/label.h	2009-04-17 16:46:43.533558065 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SGI_LABEL
diff -rupN busybox-1.2.0/include/config/config/feature/sh/extra/quiet.h busybox-1.2.0solaris/include/config/config/feature/sh/extra/quiet.h
--- busybox-1.2.0/include/config/config/feature/sh/extra/quiet.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/sh/extra/quiet.h	2009-04-17 16:46:43.424297250 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SH_EXTRA_QUIET
diff -rupN busybox-1.2.0/include/config/config/feature/sh/fancy/prompt.h busybox-1.2.0solaris/include/config/config/feature/sh/fancy/prompt.h
--- busybox-1.2.0/include/config/config/feature/sh/fancy/prompt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/sh/fancy/prompt.h	2009-04-17 16:46:43.419221075 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SH_FANCY_PROMPT
diff -rupN busybox-1.2.0/include/config/config/feature/sh/standalone/shell.h busybox-1.2.0solaris/include/config/config/feature/sh/standalone/shell.h
--- busybox-1.2.0/include/config/config/feature/sh/standalone/shell.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/sh/standalone/shell.h	2009-04-17 16:46:43.423794142 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SH_STANDALONE_SHELL
diff -rupN busybox-1.2.0/include/config/config/feature/shadowpasswds.h busybox-1.2.0solaris/include/config/config/feature/shadowpasswds.h
--- busybox-1.2.0/include/config/config/feature/shadowpasswds.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/shadowpasswds.h	2009-04-17 16:46:43.717872301 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SHADOWPASSWDS
diff -rupN busybox-1.2.0/include/config/config/feature/sort/big.h busybox-1.2.0solaris/include/config/config/feature/sort/big.h
--- busybox-1.2.0/include/config/config/feature/sort/big.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/sort/big.h	2009-04-17 16:46:43.769906763 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_SORT_BIG 1
diff -rupN busybox-1.2.0/include/config/config/feature/stat/format.h busybox-1.2.0solaris/include/config/config/feature/stat/format.h
--- busybox-1.2.0/include/config/config/feature/stat/format.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/stat/format.h	2009-04-17 16:46:43.768634734 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_STAT_FORMAT
diff -rupN busybox-1.2.0/include/config/config/feature/suid/config/quiet.h busybox-1.2.0solaris/include/config/config/feature/suid/config/quiet.h
--- busybox-1.2.0/include/config/config/feature/suid/config/quiet.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/suid/config/quiet.h	2009-04-17 16:46:43.828266874 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SUID_CONFIG_QUIET
diff -rupN busybox-1.2.0/include/config/config/feature/suid/config.h busybox-1.2.0solaris/include/config/config/feature/suid/config.h
--- busybox-1.2.0/include/config/config/feature/suid/config.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/suid/config.h	2009-04-17 16:46:43.829176334 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SUID_CONFIG
diff -rupN busybox-1.2.0/include/config/config/feature/suid.h busybox-1.2.0solaris/include/config/config/feature/suid.h
--- busybox-1.2.0/include/config/config/feature/suid.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/suid.h	2009-04-17 16:46:43.829795800 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SUID
diff -rupN busybox-1.2.0/include/config/config/feature/sun/label.h busybox-1.2.0solaris/include/config/config/feature/sun/label.h
--- busybox-1.2.0/include/config/config/feature/sun/label.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/sun/label.h	2009-04-17 16:46:43.532887959 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_SUN_LABEL
diff -rupN busybox-1.2.0/include/config/config/feature/tar/bzip2.h busybox-1.2.0solaris/include/config/config/feature/tar/bzip2.h
--- busybox-1.2.0/include/config/config/feature/tar/bzip2.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/bzip2.h	2009-04-17 16:46:43.816896930 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TAR_BZIP2
diff -rupN busybox-1.2.0/include/config/config/feature/tar/compress.h busybox-1.2.0solaris/include/config/config/feature/tar/compress.h
--- busybox-1.2.0/include/config/config/feature/tar/compress.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/compress.h	2009-04-17 16:46:43.813861300 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TAR_COMPRESS
diff -rupN busybox-1.2.0/include/config/config/feature/tar/create.h busybox-1.2.0solaris/include/config/config/feature/tar/create.h
--- busybox-1.2.0/include/config/config/feature/tar/create.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/create.h	2009-04-17 16:46:43.817608724 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_TAR_CREATE 1
diff -rupN busybox-1.2.0/include/config/config/feature/tar/from.h busybox-1.2.0solaris/include/config/config/feature/tar/from.h
--- busybox-1.2.0/include/config/config/feature/tar/from.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/from.h	2009-04-17 16:46:43.815262864 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TAR_FROM
diff -rupN busybox-1.2.0/include/config/config/feature/tar/gnu/extensions.h busybox-1.2.0solaris/include/config/config/feature/tar/gnu/extensions.h
--- busybox-1.2.0/include/config/config/feature/tar/gnu/extensions.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/gnu/extensions.h	2009-04-17 16:46:43.812649568 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_TAR_GNU_EXTENSIONS 1
diff -rupN busybox-1.2.0/include/config/config/feature/tar/gzip.h busybox-1.2.0solaris/include/config/config/feature/tar/gzip.h
--- busybox-1.2.0/include/config/config/feature/tar/gzip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/gzip.h	2009-04-17 16:46:43.814544733 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_TAR_GZIP 1
diff -rupN busybox-1.2.0/include/config/config/feature/tar/long/options.h busybox-1.2.0solaris/include/config/config/feature/tar/long/options.h
--- busybox-1.2.0/include/config/config/feature/tar/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/long/options.h	2009-04-17 16:46:43.812089445 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TAR_LONG_OPTIONS
diff -rupN busybox-1.2.0/include/config/config/feature/tar/lzma.h busybox-1.2.0solaris/include/config/config/feature/tar/lzma.h
--- busybox-1.2.0/include/config/config/feature/tar/lzma.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/lzma.h	2009-04-17 16:46:43.816016327 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TAR_LZMA
diff -rupN busybox-1.2.0/include/config/config/feature/tar/oldgnu/compatibility.h busybox-1.2.0solaris/include/config/config/feature/tar/oldgnu/compatibility.h
--- busybox-1.2.0/include/config/config/feature/tar/oldgnu/compatibility.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tar/oldgnu/compatibility.h	2009-04-17 16:46:43.813179165 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TAR_OLDGNU_COMPATIBILITY
diff -rupN busybox-1.2.0/include/config/config/feature/tee/use/block/io.h busybox-1.2.0solaris/include/config/config/feature/tee/use/block/io.h
--- busybox-1.2.0/include/config/config/feature/tee/use/block/io.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tee/use/block/io.h	2009-04-17 16:46:43.765170831 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TEE_USE_BLOCK_IO
diff -rupN busybox-1.2.0/include/config/config/feature/telnet/autologin.h busybox-1.2.0solaris/include/config/config/feature/telnet/autologin.h
--- busybox-1.2.0/include/config/config/feature/telnet/autologin.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/telnet/autologin.h	2009-04-17 16:46:43.454372281 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TELNET_AUTOLOGIN
diff -rupN busybox-1.2.0/include/config/config/feature/telnet/ttype.h busybox-1.2.0solaris/include/config/config/feature/telnet/ttype.h
--- busybox-1.2.0/include/config/config/feature/telnet/ttype.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/telnet/ttype.h	2009-04-17 16:46:43.454752602 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TELNET_TTYPE
diff -rupN busybox-1.2.0/include/config/config/feature/telnetd/inetd.h busybox-1.2.0solaris/include/config/config/feature/telnetd/inetd.h
--- busybox-1.2.0/include/config/config/feature/telnetd/inetd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/telnetd/inetd.h	2009-04-17 16:46:43.453628314 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TELNETD_INETD
diff -rupN busybox-1.2.0/include/config/config/feature/test_64.h busybox-1.2.0solaris/include/config/config/feature/test_64.h
--- busybox-1.2.0/include/config/config/feature/test_64.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/test_64.h	2009-04-17 16:46:43.763927222 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TEST_64
diff -rupN busybox-1.2.0/include/config/config/feature/tftp/blocksize.h busybox-1.2.0solaris/include/config/config/feature/tftp/blocksize.h
--- busybox-1.2.0/include/config/config/feature/tftp/blocksize.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tftp/blocksize.h	2009-04-17 16:46:43.451358538 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TFTP_BLOCKSIZE
diff -rupN busybox-1.2.0/include/config/config/feature/tftp/get.h busybox-1.2.0solaris/include/config/config/feature/tftp/get.h
--- busybox-1.2.0/include/config/config/feature/tftp/get.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tftp/get.h	2009-04-17 16:46:43.452888062 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TFTP_GET
diff -rupN busybox-1.2.0/include/config/config/feature/tftp/put.h busybox-1.2.0solaris/include/config/config/feature/tftp/put.h
--- busybox-1.2.0/include/config/config/feature/tftp/put.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/tftp/put.h	2009-04-17 16:46:43.452236742 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TFTP_PUT
diff -rupN busybox-1.2.0/include/config/config/feature/top/cpu/usage/percentage.h busybox-1.2.0solaris/include/config/config/feature/top/cpu/usage/percentage.h
--- busybox-1.2.0/include/config/config/feature/top/cpu/usage/percentage.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/top/cpu/usage/percentage.h	2009-04-17 16:46:43.437633182 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TOP_CPU_USAGE_PERCENTAGE
diff -rupN busybox-1.2.0/include/config/config/feature/traceroute/source/route.h busybox-1.2.0solaris/include/config/config/feature/traceroute/source/route.h
--- busybox-1.2.0/include/config/config/feature/traceroute/source/route.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/traceroute/source/route.h	2009-04-17 16:46:43.448337352 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TRACEROUTE_SOURCE_ROUTE
diff -rupN busybox-1.2.0/include/config/config/feature/traceroute/use/icmp.h busybox-1.2.0solaris/include/config/config/feature/traceroute/use/icmp.h
--- busybox-1.2.0/include/config/config/feature/traceroute/use/icmp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/traceroute/use/icmp.h	2009-04-17 16:46:43.447773615 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TRACEROUTE_USE_ICMP
diff -rupN busybox-1.2.0/include/config/config/feature/traceroute/verbose.h busybox-1.2.0solaris/include/config/config/feature/traceroute/verbose.h
--- busybox-1.2.0/include/config/config/feature/traceroute/verbose.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/traceroute/verbose.h	2009-04-17 16:46:43.448661207 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_TRACEROUTE_VERBOSE
diff -rupN busybox-1.2.0/include/config/config/feature/udhcp/debug.h busybox-1.2.0solaris/include/config/config/feature/udhcp/debug.h
--- busybox-1.2.0/include/config/config/feature/udhcp/debug.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/udhcp/debug.h	2009-04-17 16:46:43.445390756 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_UDHCP_DEBUG
diff -rupN busybox-1.2.0/include/config/config/feature/udhcp/syslog.h busybox-1.2.0solaris/include/config/config/feature/udhcp/syslog.h
--- busybox-1.2.0/include/config/config/feature/udhcp/syslog.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/udhcp/syslog.h	2009-04-17 16:46:43.446028955 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_UDHCP_SYSLOG
diff -rupN busybox-1.2.0/include/config/config/feature/unarchive/tape.h busybox-1.2.0solaris/include/config/config/feature/unarchive/tape.h
--- busybox-1.2.0/include/config/config/feature/unarchive/tape.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/unarchive/tape.h	2009-04-17 16:46:43.808761877 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_UNARCHIVE_TAPE
diff -rupN busybox-1.2.0/include/config/config/feature/use/inittab.h busybox-1.2.0solaris/include/config/config/feature/use/inittab.h
--- busybox-1.2.0/include/config/config/feature/use/inittab.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/use/inittab.h	2009-04-17 16:46:43.721028086 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_USE_INITTAB
diff -rupN busybox-1.2.0/include/config/config/feature/use/termios.h busybox-1.2.0solaris/include/config/config/feature/use/termios.h
--- busybox-1.2.0/include/config/config/feature/use/termios.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/use/termios.h	2009-04-17 16:46:43.523335394 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_USE_TERMIOS
diff -rupN busybox-1.2.0/include/config/config/feature/utmp.h busybox-1.2.0solaris/include/config/config/feature/utmp.h
--- busybox-1.2.0/include/config/config/feature/utmp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/utmp.h	2009-04-17 16:46:43.714340090 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_UTMP
diff -rupN busybox-1.2.0/include/config/config/feature/verbose/usage.h busybox-1.2.0solaris/include/config/config/feature/verbose/usage.h
--- busybox-1.2.0/include/config/config/feature/verbose/usage.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/verbose/usage.h	2009-04-17 16:46:43.835455899 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_VERBOSE_USAGE
diff -rupN busybox-1.2.0/include/config/config/feature/vi/colon.h busybox-1.2.0solaris/include/config/config/feature/vi/colon.h
--- busybox-1.2.0/include/config/config/feature/vi/colon.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/colon.h	2009-04-17 16:46:43.739878560 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_COLON 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/dot/cmd.h busybox-1.2.0solaris/include/config/config/feature/vi/dot/cmd.h
--- busybox-1.2.0/include/config/config/feature/vi/dot/cmd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/dot/cmd.h	2009-04-17 16:46:43.738230145 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_DOT_CMD 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/optimize/cursor.h busybox-1.2.0solaris/include/config/config/feature/vi/optimize/cursor.h
--- busybox-1.2.0/include/config/config/feature/vi/optimize/cursor.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/optimize/cursor.h	2009-04-17 16:46:43.735425430 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_OPTIMIZE_CURSOR 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/readonly.h busybox-1.2.0solaris/include/config/config/feature/vi/readonly.h
--- busybox-1.2.0/include/config/config/feature/vi/readonly.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/readonly.h	2009-04-17 16:46:43.737711349 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_READONLY 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/search.h busybox-1.2.0solaris/include/config/config/feature/vi/search.h
--- busybox-1.2.0/include/config/config/feature/vi/search.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/search.h	2009-04-17 16:46:43.739153662 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_SEARCH 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/set.h busybox-1.2.0solaris/include/config/config/feature/vi/set.h
--- busybox-1.2.0/include/config/config/feature/vi/set.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/set.h	2009-04-17 16:46:43.737030007 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_SET 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/setopts.h busybox-1.2.0solaris/include/config/config/feature/vi/setopts.h
--- busybox-1.2.0/include/config/config/feature/vi/setopts.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/setopts.h	2009-04-17 16:46:43.737378997 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_SETOPTS 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/use/signals.h busybox-1.2.0solaris/include/config/config/feature/vi/use/signals.h
--- busybox-1.2.0/include/config/config/feature/vi/use/signals.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/use/signals.h	2009-04-17 16:46:43.738751652 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_USE_SIGNALS 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/win/resize.h busybox-1.2.0solaris/include/config/config/feature/vi/win/resize.h
--- busybox-1.2.0/include/config/config/feature/vi/win/resize.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/win/resize.h	2009-04-17 16:46:43.736660888 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_WIN_RESIZE 1
diff -rupN busybox-1.2.0/include/config/config/feature/vi/yankmark.h busybox-1.2.0solaris/include/config/config/feature/vi/yankmark.h
--- busybox-1.2.0/include/config/config/feature/vi/yankmark.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/vi/yankmark.h	2009-04-17 16:46:43.739502036 +0400
@@ -0,0 +1 @@
+#define CONFIG_FEATURE_VI_YANKMARK 1
diff -rupN busybox-1.2.0/include/config/config/feature/wget/authentication.h busybox-1.2.0solaris/include/config/config/feature/wget/authentication.h
--- busybox-1.2.0/include/config/config/feature/wget/authentication.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/wget/authentication.h	2009-04-17 16:46:43.443528250 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_WGET_AUTHENTICATION
diff -rupN busybox-1.2.0/include/config/config/feature/wget/ip6/literal.h busybox-1.2.0solaris/include/config/config/feature/wget/ip6/literal.h
--- busybox-1.2.0/include/config/config/feature/wget/ip6/literal.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/wget/ip6/literal.h	2009-04-17 16:46:43.443205992 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_WGET_IP6_LITERAL
diff -rupN busybox-1.2.0/include/config/config/feature/wget/statusbar.h busybox-1.2.0solaris/include/config/config/feature/wget/statusbar.h
--- busybox-1.2.0/include/config/config/feature/wget/statusbar.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/wget/statusbar.h	2009-04-17 16:46:43.443852785 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_WGET_STATUSBAR
diff -rupN busybox-1.2.0/include/config/config/feature/wtmp.h busybox-1.2.0solaris/include/config/config/feature/wtmp.h
--- busybox-1.2.0/include/config/config/feature/wtmp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/wtmp.h	2009-04-17 16:46:43.714010614 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_WTMP
diff -rupN busybox-1.2.0/include/config/config/feature/xargs/support/confirmation.h busybox-1.2.0solaris/include/config/config/feature/xargs/support/confirmation.h
--- busybox-1.2.0/include/config/config/feature/xargs/support/confirmation.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/xargs/support/confirmation.h	2009-04-17 16:46:43.724276499 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_XARGS_SUPPORT_CONFIRMATION
diff -rupN busybox-1.2.0/include/config/config/feature/xargs/support/quotes.h busybox-1.2.0solaris/include/config/config/feature/xargs/support/quotes.h
--- busybox-1.2.0/include/config/config/feature/xargs/support/quotes.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/xargs/support/quotes.h	2009-04-17 16:46:43.723903685 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_XARGS_SUPPORT_QUOTES
diff -rupN busybox-1.2.0/include/config/config/feature/xargs/support/termopt.h busybox-1.2.0solaris/include/config/config/feature/xargs/support/termopt.h
--- busybox-1.2.0/include/config/config/feature/xargs/support/termopt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/xargs/support/termopt.h	2009-04-17 16:46:43.723549119 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_XARGS_SUPPORT_TERMOPT
diff -rupN busybox-1.2.0/include/config/config/feature/xargs/support/zero/term.h busybox-1.2.0solaris/include/config/config/feature/xargs/support/zero/term.h
--- busybox-1.2.0/include/config/config/feature/xargs/support/zero/term.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature/xargs/support/zero/term.h	2009-04-17 16:46:43.723177136 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_XARGS_SUPPORT_ZERO_TERM
diff -rupN busybox-1.2.0/include/config/config/feature_2_4/modules.h busybox-1.2.0solaris/include/config/config/feature_2_4/modules.h
--- busybox-1.2.0/include/config/config/feature_2_4/modules.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature_2_4/modules.h	2009-04-17 16:46:43.539525508 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_2_4_MODULES
diff -rupN busybox-1.2.0/include/config/config/feature_2_6/modules.h busybox-1.2.0solaris/include/config/config/feature_2_6/modules.h
--- busybox-1.2.0/include/config/config/feature_2_6/modules.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/feature_2_6/modules.h	2009-04-17 16:46:43.538600837 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FEATURE_2_6_MODULES
diff -rupN busybox-1.2.0/include/config/config/findfs.h busybox-1.2.0solaris/include/config/config/findfs.h
--- busybox-1.2.0/include/config/config/findfs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/findfs.h	2009-04-17 16:46:43.708794938 +0400
@@ -0,0 +1 @@
+#undef CONFIG_FINDFS
diff -rupN busybox-1.2.0/include/config/config/gunzip.h busybox-1.2.0solaris/include/config/config/gunzip.h
--- busybox-1.2.0/include/config/config/gunzip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/gunzip.h	2009-04-17 16:46:43.820564315 +0400
@@ -0,0 +1 @@
+#define CONFIG_GUNZIP 1
diff -rupN busybox-1.2.0/include/config/config/init.h busybox-1.2.0solaris/include/config/config/init.h
--- busybox-1.2.0/include/config/config/init.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/init.h	2009-04-20 13:24:10.079208498 +0400
@@ -0,0 +1 @@
+#define CONFIG_INIT 1
diff -rupN busybox-1.2.0/include/config/config/install/no/usr.h busybox-1.2.0solaris/include/config/config/install/no/usr.h
--- busybox-1.2.0/include/config/config/install/no/usr.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/install/no/usr.h	2009-04-17 16:46:43.824841426 +0400
@@ -0,0 +1 @@
+#undef CONFIG_INSTALL_NO_USR
diff -rupN busybox-1.2.0/include/config/config/killall.h busybox-1.2.0solaris/include/config/config/killall.h
--- busybox-1.2.0/include/config/config/killall.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/killall.h	2009-04-17 16:46:43.441507685 +0400
@@ -0,0 +1 @@
+#undef CONFIG_KILLALL
diff -rupN busybox-1.2.0/include/config/config/lfs.h busybox-1.2.0solaris/include/config/config/lfs.h
--- busybox-1.2.0/include/config/config/lfs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/lfs.h	2009-04-17 16:46:43.826370811 +0400
@@ -0,0 +1 @@
+#undef CONFIG_LFS
diff -rupN busybox-1.2.0/include/config/config/locale/support.h busybox-1.2.0solaris/include/config/config/locale/support.h
--- busybox-1.2.0/include/config/config/locale/support.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/locale/support.h	2009-04-17 16:46:43.833721168 +0400
@@ -0,0 +1 @@
+#undef CONFIG_LOCALE_SUPPORT
diff -rupN busybox-1.2.0/include/config/config/login.h busybox-1.2.0solaris/include/config/config/login.h
--- busybox-1.2.0/include/config/config/login.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/login.h	2009-04-17 16:46:43.713670146 +0400
@@ -0,0 +1 @@
+#undef CONFIG_LOGIN
diff -rupN busybox-1.2.0/include/config/config/md5/size/vs/speed.h busybox-1.2.0solaris/include/config/config/md5/size/vs/speed.h
--- busybox-1.2.0/include/config/config/md5/size/vs/speed.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/md5/size/vs/speed.h	2009-04-17 16:46:43.824172791 +0400
@@ -0,0 +1 @@
+#define CONFIG_MD5_SIZE_VS_SPEED 2
diff -rupN busybox-1.2.0/include/config/config/md5sum.h busybox-1.2.0solaris/include/config/config/md5sum.h
--- busybox-1.2.0/include/config/config/md5sum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/md5sum.h	2009-04-17 16:46:43.780998258 +0400
@@ -0,0 +1 @@
+#define CONFIG_MD5SUM 1
diff -rupN busybox-1.2.0/include/config/config/nc/gaping/security/hole.h busybox-1.2.0solaris/include/config/config/nc/gaping/security/hole.h
--- busybox-1.2.0/include/config/config/nc/gaping/security/hole.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/nc/gaping/security/hole.h	2009-04-17 16:46:43.458468172 +0400
@@ -0,0 +1 @@
+#undef CONFIG_NC_GAPING_SECURITY_HOLE
diff -rupN busybox-1.2.0/include/config/config/ps.h busybox-1.2.0solaris/include/config/config/ps.h
--- busybox-1.2.0/include/config/config/ps.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/ps.h	2009-04-20 14:06:34.516494983 +0400
@@ -0,0 +1 @@
+#define CONFIG_PS 1
diff -rupN busybox-1.2.0/include/config/config/route.h busybox-1.2.0solaris/include/config/config/route.h
--- busybox-1.2.0/include/config/config/route.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/route.h	2009-04-18 11:38:16.989271852 +0400
@@ -0,0 +1 @@
+#undef CONFIG_ROUTE
diff -rupN busybox-1.2.0/include/config/config/selinux.h busybox-1.2.0solaris/include/config/config/selinux.h
--- busybox-1.2.0/include/config/config/selinux.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/selinux.h	2009-04-17 16:46:43.827579735 +0400
@@ -0,0 +1 @@
+#undef CONFIG_SELINUX
diff -rupN busybox-1.2.0/include/config/config/sha1sum.h busybox-1.2.0solaris/include/config/config/sha1sum.h
--- busybox-1.2.0/include/config/config/sha1sum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/sha1sum.h	2009-04-17 16:46:43.771865549 +0400
@@ -0,0 +1 @@
+#undef CONFIG_SHA1SUM
diff -rupN busybox-1.2.0/include/config/config/syslogd.h busybox-1.2.0solaris/include/config/config/syslogd.h
--- busybox-1.2.0/include/config/config/syslogd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/syslogd.h	2009-04-17 16:46:43.418609008 +0400
@@ -0,0 +1 @@
+#undef CONFIG_SYSLOGD
diff -rupN busybox-1.2.0/include/config/config/tar.h busybox-1.2.0solaris/include/config/config/tar.h
--- busybox-1.2.0/include/config/config/tar.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/tar.h	2009-04-17 16:46:43.818220821 +0400
@@ -0,0 +1 @@
+#define CONFIG_TAR 1
diff -rupN busybox-1.2.0/include/config/config/use/bb/pwd/grp.h busybox-1.2.0solaris/include/config/config/use/bb/pwd/grp.h
--- busybox-1.2.0/include/config/config/use/bb/pwd/grp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/use/bb/pwd/grp.h	2009-04-17 16:46:43.716889360 +0400
@@ -0,0 +1 @@
+#undef CONFIG_USE_BB_PWD_GRP
diff -rupN busybox-1.2.0/include/config/config/use/bb/shadow.h busybox-1.2.0solaris/include/config/config/use/bb/shadow.h
--- busybox-1.2.0/include/config/config/use/bb/shadow.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/config/use/bb/shadow.h	2009-04-17 16:46:43.717249159 +0400
@@ -0,0 +1 @@
+#undef CONFIG_USE_BB_SHADOW
diff -rupN busybox-1.2.0/include/config/enable/ash/alias.h busybox-1.2.0solaris/include/config/enable/ash/alias.h
--- busybox-1.2.0/include/config/enable/ash/alias.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/ash/alias.h	2009-04-18 09:28:20.892540467 +0400
@@ -0,0 +1 @@
+#define ENABLE_ASH_ALIAS 0
diff -rupN busybox-1.2.0/include/config/enable/ash/builtin/echo.h busybox-1.2.0solaris/include/config/enable/ash/builtin/echo.h
--- busybox-1.2.0/include/config/enable/ash/builtin/echo.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/ash/builtin/echo.h	2009-04-18 09:28:20.891717143 +0400
@@ -0,0 +1 @@
+#define ENABLE_ASH_BUILTIN_ECHO 0
diff -rupN busybox-1.2.0/include/config/enable/ash/builtin/test.h busybox-1.2.0solaris/include/config/enable/ash/builtin/test.h
--- busybox-1.2.0/include/config/enable/ash/builtin/test.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/ash/builtin/test.h	2009-04-17 16:46:43.428109813 +0400
@@ -0,0 +1 @@
+#define ENABLE_ASH_BUILTIN_TEST 0
diff -rupN busybox-1.2.0/include/config/enable/ash/cmdcmd.h busybox-1.2.0solaris/include/config/enable/ash/cmdcmd.h
--- busybox-1.2.0/include/config/enable/ash/cmdcmd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/ash/cmdcmd.h	2009-04-18 09:26:07.539593826 +0400
@@ -0,0 +1 @@
+#define ENABLE_ASH_CMDCMD 0
diff -rupN busybox-1.2.0/include/config/enable/ash/job/control.h busybox-1.2.0solaris/include/config/enable/ash/job/control.h
--- busybox-1.2.0/include/config/enable/ash/job/control.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/ash/job/control.h	2009-04-18 09:28:20.893190282 +0400
@@ -0,0 +1 @@
+#define ENABLE_ASH_JOB_CONTROL 0
diff -rupN busybox-1.2.0/include/config/enable/debug/crond/option.h busybox-1.2.0solaris/include/config/enable/debug/crond/option.h
--- busybox-1.2.0/include/config/enable/debug/crond/option.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/debug/crond/option.h	2009-04-17 16:46:43.515309755 +0400
@@ -0,0 +1 @@
+#define ENABLE_DEBUG_CROND_OPTION 0
diff -rupN busybox-1.2.0/include/config/enable/debug/init.h busybox-1.2.0solaris/include/config/enable/debug/init.h
--- busybox-1.2.0/include/config/enable/debug/init.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/debug/init.h	2009-04-17 16:46:43.721335190 +0400
@@ -0,0 +1 @@
+#define ENABLE_DEBUG_INIT 0
diff -rupN busybox-1.2.0/include/config/enable/debug/yank/susv2.h busybox-1.2.0solaris/include/config/enable/debug/yank/susv2.h
--- busybox-1.2.0/include/config/enable/debug/yank/susv2.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/debug/yank/susv2.h	2009-04-17 16:46:43.825437114 +0400
@@ -0,0 +1 @@
+#define ENABLE_DEBUG_YANK_SUSv2 1
diff -rupN busybox-1.2.0/include/config/enable/debug.h busybox-1.2.0solaris/include/config/enable/debug.h
--- busybox-1.2.0/include/config/enable/debug.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/debug.h	2009-04-17 16:46:43.825750935 +0400
@@ -0,0 +1 @@
+#define ENABLE_DEBUG 0
diff -rupN busybox-1.2.0/include/config/enable/deluser.h busybox-1.2.0solaris/include/config/enable/deluser.h
--- busybox-1.2.0/include/config/enable/deluser.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/deluser.h	2009-04-17 16:46:43.715177471 +0400
@@ -0,0 +1 @@
+#define ENABLE_DELUSER 0
diff -rupN busybox-1.2.0/include/config/enable/devfsd/fg/np.h busybox-1.2.0solaris/include/config/enable/devfsd/fg/np.h
--- busybox-1.2.0/include/config/enable/devfsd/fg/np.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/devfsd/fg/np.h	2009-04-17 16:46:43.512830628 +0400
@@ -0,0 +1 @@
+#define ENABLE_DEVFSD_FG_NP 0
diff -rupN busybox-1.2.0/include/config/enable/devfsd/modload.h busybox-1.2.0solaris/include/config/enable/devfsd/modload.h
--- busybox-1.2.0/include/config/enable/devfsd/modload.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/devfsd/modload.h	2009-04-17 16:46:43.513130615 +0400
@@ -0,0 +1 @@
+#define ENABLE_DEVFSD_MODLOAD 0
diff -rupN busybox-1.2.0/include/config/enable/devfsd/verbose.h busybox-1.2.0solaris/include/config/enable/devfsd/verbose.h
--- busybox-1.2.0/include/config/enable/devfsd/verbose.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/devfsd/verbose.h	2009-04-17 16:46:43.511277045 +0400
@@ -0,0 +1 @@
+#define ENABLE_DEVFSD_VERBOSE 0
diff -rupN busybox-1.2.0/include/config/enable/e2label.h busybox-1.2.0solaris/include/config/enable/e2label.h
--- busybox-1.2.0/include/config/enable/e2label.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/e2label.h	2009-04-17 16:46:43.709405788 +0400
@@ -0,0 +1 @@
+#define ENABLE_E2LABEL 0
diff -rupN busybox-1.2.0/include/config/enable/expr/math/support_64.h busybox-1.2.0solaris/include/config/enable/expr/math/support_64.h
--- busybox-1.2.0/include/config/enable/expr/math/support_64.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/expr/math/support_64.h	2009-04-17 16:46:43.791499941 +0400
@@ -0,0 +1 @@
+#define ENABLE_EXPR_MATH_SUPPORT_64 0
diff -rupN busybox-1.2.0/include/config/enable/fdflush.h busybox-1.2.0solaris/include/config/enable/fdflush.h
--- busybox-1.2.0/include/config/enable/fdflush.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/fdflush.h	2009-04-17 16:46:43.535525038 +0400
@@ -0,0 +1 @@
+#define ENABLE_FDFLUSH 0
diff -rupN busybox-1.2.0/include/config/enable/feature/autowidth.h busybox-1.2.0solaris/include/config/enable/feature/autowidth.h
--- busybox-1.2.0/include/config/enable/feature/autowidth.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/autowidth.h	2009-04-17 16:46:43.756589158 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_AUTOWIDTH 1
diff -rupN busybox-1.2.0/include/config/enable/feature/check/tainted/module.h busybox-1.2.0solaris/include/config/enable/feature/check/tainted/module.h
--- busybox-1.2.0/include/config/enable/feature/check/tainted/module.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/check/tainted/module.h	2009-04-17 16:46:43.701846328 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_CHECK_TAINTED_MODULE 0
diff -rupN busybox-1.2.0/include/config/enable/feature/clean/up.h busybox-1.2.0solaris/include/config/enable/feature/clean/up.h
--- busybox-1.2.0/include/config/enable/feature/clean/up.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/clean/up.h	2009-04-17 16:46:43.831425572 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_CLEAN_UP 0
diff -rupN busybox-1.2.0/include/config/enable/feature/compress/usage.h busybox-1.2.0solaris/include/config/enable/feature/compress/usage.h
--- busybox-1.2.0/include/config/enable/feature/compress/usage.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/compress/usage.h	2009-04-17 16:46:43.834921814 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_COMPRESS_USAGE 0
diff -rupN busybox-1.2.0/include/config/enable/feature/crond/call/sendmail.h busybox-1.2.0solaris/include/config/enable/feature/crond/call/sendmail.h
--- busybox-1.2.0/include/config/enable/feature/crond/call/sendmail.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/crond/call/sendmail.h	2009-04-17 16:46:43.514689691 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_CROND_CALL_SENDMAIL 0
diff -rupN busybox-1.2.0/include/config/enable/feature/date/isofmt.h busybox-1.2.0solaris/include/config/enable/feature/date/isofmt.h
--- busybox-1.2.0/include/config/enable/feature/date/isofmt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/date/isofmt.h	2009-04-17 16:46:43.802213979 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_DATE_ISOFMT 1
diff -rupN busybox-1.2.0/include/config/enable/feature/dd/ibs/obs.h busybox-1.2.0solaris/include/config/enable/feature/dd/ibs/obs.h
--- busybox-1.2.0/include/config/enable/feature/dd/ibs/obs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/dd/ibs/obs.h	2009-04-17 16:46:43.800365108 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_DD_IBS_OBS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/dd/signal/handling.h busybox-1.2.0solaris/include/config/enable/feature/dd/signal/handling.h
--- busybox-1.2.0/include/config/enable/feature/dd/signal/handling.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/dd/signal/handling.h	2009-04-17 16:46:43.800907036 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_DD_SIGNAL_HANDLING 1
diff -rupN busybox-1.2.0/include/config/enable/feature/deb/tar/lzma.h busybox-1.2.0solaris/include/config/enable/feature/deb/tar/lzma.h
--- busybox-1.2.0/include/config/enable/feature/deb/tar/lzma.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/deb/tar/lzma.h	2009-04-17 16:46:43.807120823 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_DEB_TAR_LZMA 0
diff -rupN busybox-1.2.0/include/config/enable/feature/diff/binary.h busybox-1.2.0solaris/include/config/enable/feature/diff/binary.h
--- busybox-1.2.0/include/config/enable/feature/diff/binary.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/diff/binary.h	2009-04-17 16:46:43.798269156 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_DIFF_BINARY 0
diff -rupN busybox-1.2.0/include/config/enable/feature/diff/dir.h busybox-1.2.0solaris/include/config/enable/feature/diff/dir.h
--- busybox-1.2.0/include/config/enable/feature/diff/dir.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/diff/dir.h	2009-04-17 16:46:43.797868996 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_DIFF_DIR 0
diff -rupN busybox-1.2.0/include/config/enable/feature/diff/minimal.h busybox-1.2.0solaris/include/config/enable/feature/diff/minimal.h
--- busybox-1.2.0/include/config/enable/feature/diff/minimal.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/diff/minimal.h	2009-04-17 16:46:43.797413866 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_DIFF_MINIMAL 0
diff -rupN busybox-1.2.0/include/config/enable/feature/env/long/options.h busybox-1.2.0solaris/include/config/enable/feature/env/long/options.h
--- busybox-1.2.0/include/config/enable/feature/env/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/env/long/options.h	2009-04-17 16:46:43.792468492 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_ENV_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/fancy/head.h busybox-1.2.0solaris/include/config/enable/feature/fancy/head.h
--- busybox-1.2.0/include/config/enable/feature/fancy/head.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/fancy/head.h	2009-04-17 16:46:43.789742999 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_FANCY_HEAD 0
diff -rupN busybox-1.2.0/include/config/enable/feature/fancy/tail.h busybox-1.2.0solaris/include/config/enable/feature/fancy/tail.h
--- busybox-1.2.0/include/config/enable/feature/fancy/tail.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/fancy/tail.h	2009-04-17 16:46:43.766011869 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_FANCY_TAIL 0
diff -rupN busybox-1.2.0/include/config/enable/feature/ftpgetput/long/options.h busybox-1.2.0solaris/include/config/enable/feature/ftpgetput/long/options.h
--- busybox-1.2.0/include/config/enable/feature/ftpgetput/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ftpgetput/long/options.h	2009-04-17 16:46:43.488929550 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_FTPGETPUT_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/grep/context.h busybox-1.2.0solaris/include/config/enable/feature/grep/context.h
--- busybox-1.2.0/include/config/enable/feature/grep/context.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/grep/context.h	2009-04-17 16:46:43.725540401 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_GREP_CONTEXT 1
diff -rupN busybox-1.2.0/include/config/enable/feature/grep/egrep/alias.h busybox-1.2.0solaris/include/config/enable/feature/grep/egrep/alias.h
--- busybox-1.2.0/include/config/enable/feature/grep/egrep/alias.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/grep/egrep/alias.h	2009-04-17 16:46:43.727694225 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_GREP_EGREP_ALIAS 1
diff -rupN busybox-1.2.0/include/config/enable/feature/grep/fgrep/alias.h busybox-1.2.0solaris/include/config/enable/feature/grep/fgrep/alias.h
--- busybox-1.2.0/include/config/enable/feature/grep/fgrep/alias.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/grep/fgrep/alias.h	2009-04-17 16:46:43.726618817 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_GREP_FGREP_ALIAS 1
diff -rupN busybox-1.2.0/include/config/enable/feature/hdparm/get/identity.h busybox-1.2.0solaris/include/config/enable/feature/hdparm/get/identity.h
--- busybox-1.2.0/include/config/enable/feature/hdparm/get/identity.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/hdparm/get/identity.h	2009-04-17 16:46:43.506558191 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_HDPARM_GET_IDENTITY 0
diff -rupN busybox-1.2.0/include/config/enable/feature/hdparm/hdio/scan/hwif.h busybox-1.2.0solaris/include/config/enable/feature/hdparm/hdio/scan/hwif.h
--- busybox-1.2.0/include/config/enable/feature/hdparm/hdio/scan/hwif.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/hdparm/hdio/scan/hwif.h	2009-04-17 16:46:43.504935001 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_HDPARM_HDIO_SCAN_HWIF 0
diff -rupN busybox-1.2.0/include/config/enable/feature/hwclock/long/options.h busybox-1.2.0solaris/include/config/enable/feature/hwclock/long/options.h
--- busybox-1.2.0/include/config/enable/feature/hwclock/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/hwclock/long/options.h	2009-04-17 16:46:43.528354039 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_HWCLOCK_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/ifupdown/ipv4.h busybox-1.2.0solaris/include/config/enable/feature/ifupdown/ipv4.h
--- busybox-1.2.0/include/config/enable/feature/ifupdown/ipv4.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ifupdown/ipv4.h	2009-04-17 16:46:43.470168512 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_IFUPDOWN_IPV4 0
diff -rupN busybox-1.2.0/include/config/enable/feature/ifupdown/ipv6.h busybox-1.2.0solaris/include/config/enable/feature/ifupdown/ipv6.h
--- busybox-1.2.0/include/config/enable/feature/ifupdown/ipv6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ifupdown/ipv6.h	2009-04-17 16:46:43.469412053 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_IFUPDOWN_IPV6 0
diff -rupN busybox-1.2.0/include/config/enable/feature/initrd.h busybox-1.2.0solaris/include/config/enable/feature/initrd.h
--- busybox-1.2.0/include/config/enable/feature/initrd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/initrd.h	2009-04-17 16:46:43.719067684 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_INITRD 0
diff -rupN busybox-1.2.0/include/config/enable/feature/install/long/options.h busybox-1.2.0solaris/include/config/enable/feature/install/long/options.h
--- busybox-1.2.0/include/config/enable/feature/install/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/install/long/options.h	2009-04-17 16:46:43.787818575 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_INSTALL_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/installer.h busybox-1.2.0solaris/include/config/enable/feature/installer.h
--- busybox-1.2.0/include/config/enable/feature/installer.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/installer.h	2009-04-17 16:46:43.834046997 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_INSTALLER 0
diff -rupN busybox-1.2.0/include/config/enable/feature/ipcalc/fancy.h busybox-1.2.0solaris/include/config/enable/feature/ipcalc/fancy.h
--- busybox-1.2.0/include/config/enable/feature/ipcalc/fancy.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ipcalc/fancy.h	2009-04-17 16:46:43.461148800 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_IPCALC_FANCY 0
diff -rupN busybox-1.2.0/include/config/enable/feature/ipcalc/long/options.h busybox-1.2.0solaris/include/config/enable/feature/ipcalc/long/options.h
--- busybox-1.2.0/include/config/enable/feature/ipcalc/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ipcalc/long/options.h	2009-04-17 16:46:43.459842345 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_IPCALC_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/ls/recursive.h busybox-1.2.0solaris/include/config/enable/feature/ls/recursive.h
--- busybox-1.2.0/include/config/enable/feature/ls/recursive.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ls/recursive.h	2009-04-17 16:46:43.784959096 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_LS_RECURSIVE 1
diff -rupN busybox-1.2.0/include/config/enable/feature/ls/sortfiles.h busybox-1.2.0solaris/include/config/enable/feature/ls/sortfiles.h
--- busybox-1.2.0/include/config/enable/feature/ls/sortfiles.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ls/sortfiles.h	2009-04-17 16:46:43.784297220 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_LS_SORTFILES 1
diff -rupN busybox-1.2.0/include/config/enable/feature/ls/timestamps.h busybox-1.2.0solaris/include/config/enable/feature/ls/timestamps.h
--- busybox-1.2.0/include/config/enable/feature/ls/timestamps.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ls/timestamps.h	2009-04-17 16:46:43.783124097 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_LS_TIMESTAMPS 1
diff -rupN busybox-1.2.0/include/config/enable/feature/md5/sha1/sum/check.h busybox-1.2.0solaris/include/config/enable/feature/md5/sha1/sum/check.h
--- busybox-1.2.0/include/config/enable/feature/md5/sha1/sum/check.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/md5/sha1/sum/check.h	2009-04-17 16:46:43.753771909 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MD5_SHA1_SUM_CHECK 0
diff -rupN busybox-1.2.0/include/config/enable/feature/mdev/conf.h busybox-1.2.0solaris/include/config/enable/feature/mdev/conf.h
--- busybox-1.2.0/include/config/enable/feature/mdev/conf.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/mdev/conf.h	2009-04-17 16:46:43.525851397 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MDEV_CONF 0
diff -rupN busybox-1.2.0/include/config/enable/feature/mdev/exec.h busybox-1.2.0solaris/include/config/enable/feature/mdev/exec.h
--- busybox-1.2.0/include/config/enable/feature/mdev/exec.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/mdev/exec.h	2009-04-17 16:46:43.525521264 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MDEV_EXEC 0
diff -rupN busybox-1.2.0/include/config/enable/feature/mkdir/long/options.h busybox-1.2.0solaris/include/config/enable/feature/mkdir/long/options.h
--- busybox-1.2.0/include/config/enable/feature/mkdir/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/mkdir/long/options.h	2009-04-17 16:46:43.779691785 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MKDIR_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/mkswap/v0.h busybox-1.2.0solaris/include/config/enable/feature/mkswap/v0.h
--- busybox-1.2.0/include/config/enable/feature/mkswap/v0.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/mkswap/v0.h	2009-04-17 16:46:43.524105301 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MKSWAP_V0 0
diff -rupN busybox-1.2.0/include/config/enable/feature/modprobe/multiple/options.h busybox-1.2.0solaris/include/config/enable/feature/modprobe/multiple/options.h
--- busybox-1.2.0/include/config/enable/feature/modprobe/multiple/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/modprobe/multiple/options.h	2009-04-17 16:46:43.703428333 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MODPROBE_MULTIPLE_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/mount/loop.h busybox-1.2.0solaris/include/config/enable/feature/mount/loop.h
--- busybox-1.2.0/include/config/enable/feature/mount/loop.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/mount/loop.h	2009-04-17 16:46:43.518296155 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MOUNT_LOOP 0
diff -rupN busybox-1.2.0/include/config/enable/feature/mount/nfs.h busybox-1.2.0solaris/include/config/enable/feature/mount/nfs.h
--- busybox-1.2.0/include/config/enable/feature/mount/nfs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/mount/nfs.h	2009-04-17 16:46:43.522535781 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MOUNT_NFS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/mtab/support.h busybox-1.2.0solaris/include/config/enable/feature/mtab/support.h
--- busybox-1.2.0/include/config/enable/feature/mtab/support.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/mtab/support.h	2009-04-17 16:46:43.517334973 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MTAB_SUPPORT 0
diff -rupN busybox-1.2.0/include/config/enable/feature/mv/long/options.h busybox-1.2.0solaris/include/config/enable/feature/mv/long/options.h
--- busybox-1.2.0/include/config/enable/feature/mv/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/mv/long/options.h	2009-04-17 16:46:43.778022847 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_MV_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/pidof/omit.h busybox-1.2.0solaris/include/config/enable/feature/pidof/omit.h
--- busybox-1.2.0/include/config/enable/feature/pidof/omit.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/pidof/omit.h	2009-04-17 16:46:43.440211377 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_PIDOF_OMIT 0
diff -rupN busybox-1.2.0/include/config/enable/feature/pidof/single.h busybox-1.2.0solaris/include/config/enable/feature/pidof/single.h
--- busybox-1.2.0/include/config/enable/feature/pidof/single.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/pidof/single.h	2009-04-17 16:46:43.440540586 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_PIDOF_SINGLE 0
diff -rupN busybox-1.2.0/include/config/enable/feature/preserve/hardlinks.h busybox-1.2.0solaris/include/config/enable/feature/preserve/hardlinks.h
--- busybox-1.2.0/include/config/enable/feature/preserve/hardlinks.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/preserve/hardlinks.h	2009-04-17 16:46:43.757362899 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_PRESERVE_HARDLINKS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/ps/wide.h busybox-1.2.0solaris/include/config/enable/feature/ps/wide.h
--- busybox-1.2.0/include/config/enable/feature/ps/wide.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/ps/wide.h	2009-04-17 16:46:43.439107431 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_PS_WIDE 0
diff -rupN busybox-1.2.0/include/config/enable/feature/readlink/follow.h busybox-1.2.0solaris/include/config/enable/feature/readlink/follow.h
--- busybox-1.2.0/include/config/enable/feature/readlink/follow.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/readlink/follow.h	2009-04-17 16:46:43.747246188 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_READLINK_FOLLOW 0
diff -rupN busybox-1.2.0/include/config/enable/feature/setconsole/long/options.h busybox-1.2.0solaris/include/config/enable/feature/setconsole/long/options.h
--- busybox-1.2.0/include/config/enable/feature/setconsole/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/setconsole/long/options.h	2009-04-17 16:46:43.750317521 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_SETCONSOLE_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/sh/standalone/shell.h busybox-1.2.0solaris/include/config/enable/feature/sh/standalone/shell.h
--- busybox-1.2.0/include/config/enable/feature/sh/standalone/shell.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/sh/standalone/shell.h	2009-04-17 16:46:43.423333001 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_SH_STANDALONE_SHELL 0
diff -rupN busybox-1.2.0/include/config/enable/feature/shadowpasswds.h busybox-1.2.0solaris/include/config/enable/feature/shadowpasswds.h
--- busybox-1.2.0/include/config/enable/feature/shadowpasswds.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/shadowpasswds.h	2009-04-17 16:46:43.717564059 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_SHADOWPASSWDS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/sort/big.h busybox-1.2.0solaris/include/config/enable/feature/sort/big.h
--- busybox-1.2.0/include/config/enable/feature/sort/big.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/sort/big.h	2009-04-17 16:46:43.769402817 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_SORT_BIG 1
diff -rupN busybox-1.2.0/include/config/enable/feature/start/stop/daemon/fancy.h busybox-1.2.0solaris/include/config/enable/feature/start/stop/daemon/fancy.h
--- busybox-1.2.0/include/config/enable/feature/start/stop/daemon/fancy.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/start/stop/daemon/fancy.h	2009-04-17 16:46:43.745577314 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_START_STOP_DAEMON_FANCY 0
diff -rupN busybox-1.2.0/include/config/enable/feature/start/stop/daemon/long/options.h busybox-1.2.0solaris/include/config/enable/feature/start/stop/daemon/long/options.h
--- busybox-1.2.0/include/config/enable/feature/start/stop/daemon/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/start/stop/daemon/long/options.h	2009-04-17 16:46:43.743413261 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_START_STOP_DAEMON_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/suid/config.h busybox-1.2.0solaris/include/config/enable/feature/suid/config.h
--- busybox-1.2.0/include/config/enable/feature/suid/config.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/suid/config.h	2009-04-17 16:46:43.828807155 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_SUID_CONFIG 0
diff -rupN busybox-1.2.0/include/config/enable/feature/suid.h busybox-1.2.0solaris/include/config/enable/feature/suid.h
--- busybox-1.2.0/include/config/enable/feature/suid.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/suid.h	2009-04-17 16:46:43.829488441 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_SUID 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tar/bzip2.h busybox-1.2.0solaris/include/config/enable/feature/tar/bzip2.h
--- busybox-1.2.0/include/config/enable/feature/tar/bzip2.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tar/bzip2.h	2009-04-17 16:46:43.816369378 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TAR_BZIP2 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tar/compress.h busybox-1.2.0solaris/include/config/enable/feature/tar/compress.h
--- busybox-1.2.0/include/config/enable/feature/tar/compress.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tar/compress.h	2009-04-17 16:46:43.813518892 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TAR_COMPRESS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tar/create.h busybox-1.2.0solaris/include/config/enable/feature/tar/create.h
--- busybox-1.2.0/include/config/enable/feature/tar/create.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tar/create.h	2009-04-17 16:46:43.817259079 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TAR_CREATE 1
diff -rupN busybox-1.2.0/include/config/enable/feature/tar/from.h busybox-1.2.0solaris/include/config/enable/feature/tar/from.h
--- busybox-1.2.0/include/config/enable/feature/tar/from.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tar/from.h	2009-04-17 16:46:43.814884039 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TAR_FROM 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tar/gzip.h busybox-1.2.0solaris/include/config/enable/feature/tar/gzip.h
--- busybox-1.2.0/include/config/enable/feature/tar/gzip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tar/gzip.h	2009-04-17 16:46:43.814208945 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TAR_GZIP 1
diff -rupN busybox-1.2.0/include/config/enable/feature/tar/long/options.h busybox-1.2.0solaris/include/config/enable/feature/tar/long/options.h
--- busybox-1.2.0/include/config/enable/feature/tar/long/options.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tar/long/options.h	2009-04-17 16:46:43.811327365 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TAR_LONG_OPTIONS 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tar/lzma.h busybox-1.2.0solaris/include/config/enable/feature/tar/lzma.h
--- busybox-1.2.0/include/config/enable/feature/tar/lzma.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tar/lzma.h	2009-04-17 16:46:43.815625314 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TAR_LZMA 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tftp/get.h busybox-1.2.0solaris/include/config/enable/feature/tftp/get.h
--- busybox-1.2.0/include/config/enable/feature/tftp/get.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tftp/get.h	2009-04-17 16:46:43.452565549 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TFTP_GET 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tftp/put.h busybox-1.2.0solaris/include/config/enable/feature/tftp/put.h
--- busybox-1.2.0/include/config/enable/feature/tftp/put.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tftp/put.h	2009-04-17 16:46:43.451887518 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TFTP_PUT 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tr/classes.h busybox-1.2.0solaris/include/config/enable/feature/tr/classes.h
--- busybox-1.2.0/include/config/enable/feature/tr/classes.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tr/classes.h	2009-04-17 16:46:43.763022168 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TR_CLASSES 0
diff -rupN busybox-1.2.0/include/config/enable/feature/tr/equiv.h busybox-1.2.0solaris/include/config/enable/feature/tr/equiv.h
--- busybox-1.2.0/include/config/enable/feature/tr/equiv.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/tr/equiv.h	2009-04-17 16:46:43.762685497 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_TR_EQUIV 0
diff -rupN busybox-1.2.0/include/config/enable/feature/udhcp/debug.h busybox-1.2.0solaris/include/config/enable/feature/udhcp/debug.h
--- busybox-1.2.0/include/config/enable/feature/udhcp/debug.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/udhcp/debug.h	2009-04-17 16:46:43.444929336 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_UDHCP_DEBUG 0
diff -rupN busybox-1.2.0/include/config/enable/feature/udhcp/syslog.h busybox-1.2.0solaris/include/config/enable/feature/udhcp/syslog.h
--- busybox-1.2.0/include/config/enable/feature/udhcp/syslog.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/udhcp/syslog.h	2009-04-17 16:46:43.445715412 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_UDHCP_SYSLOG 0
diff -rupN busybox-1.2.0/include/config/enable/feature/umount/all.h busybox-1.2.0solaris/include/config/enable/feature/umount/all.h
--- busybox-1.2.0/include/config/enable/feature/umount/all.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/umount/all.h	2009-04-17 16:46:43.519274511 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_UMOUNT_ALL 0
diff -rupN busybox-1.2.0/include/config/enable/feature/vi/win/resize.h busybox-1.2.0solaris/include/config/enable/feature/vi/win/resize.h
--- busybox-1.2.0/include/config/enable/feature/vi/win/resize.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature/vi/win/resize.h	2009-04-17 16:46:43.736105746 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_VI_WIN_RESIZE 1
diff -rupN busybox-1.2.0/include/config/enable/feature_2_4/modules.h busybox-1.2.0solaris/include/config/enable/feature_2_4/modules.h
--- busybox-1.2.0/include/config/enable/feature_2_4/modules.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature_2_4/modules.h	2009-04-17 16:46:43.539054340 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_2_4_MODULES 0
diff -rupN busybox-1.2.0/include/config/enable/feature_2_6/modules.h busybox-1.2.0solaris/include/config/enable/feature_2_6/modules.h
--- busybox-1.2.0/include/config/enable/feature_2_6/modules.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/feature_2_6/modules.h	2009-04-17 16:46:43.538135974 +0400
@@ -0,0 +1 @@
+#define ENABLE_FEATURE_2_6_MODULES 0
diff -rupN busybox-1.2.0/include/config/enable/findfs.h busybox-1.2.0solaris/include/config/enable/findfs.h
--- busybox-1.2.0/include/config/enable/findfs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/findfs.h	2009-04-17 16:46:43.708520599 +0400
@@ -0,0 +1 @@
+#define ENABLE_FINDFS 0
diff -rupN busybox-1.2.0/include/config/enable/freeramdisk.h busybox-1.2.0solaris/include/config/enable/freeramdisk.h
--- busybox-1.2.0/include/config/enable/freeramdisk.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/freeramdisk.h	2009-04-17 16:46:43.531420203 +0400
@@ -0,0 +1 @@
+#define ENABLE_FREERAMDISK 0
diff -rupN busybox-1.2.0/include/config/enable/ftpget.h busybox-1.2.0solaris/include/config/enable/ftpget.h
--- busybox-1.2.0/include/config/enable/ftpget.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/ftpget.h	2009-04-17 16:46:43.490154350 +0400
@@ -0,0 +1 @@
+#define ENABLE_FTPGET 0
diff -rupN busybox-1.2.0/include/config/enable/ftpput.h busybox-1.2.0solaris/include/config/enable/ftpput.h
--- busybox-1.2.0/include/config/enable/ftpput.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/ftpput.h	2009-04-17 16:46:43.489519497 +0400
@@ -0,0 +1 @@
+#define ENABLE_FTPPUT 0
diff -rupN busybox-1.2.0/include/config/enable/getopt/long.h busybox-1.2.0solaris/include/config/enable/getopt/long.h
--- busybox-1.2.0/include/config/enable/getopt/long.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/getopt/long.h	2009-04-17 16:46:43.832720298 +0400
@@ -0,0 +1 @@
+#define ENABLE_GETOPT_LONG 1
diff -rupN busybox-1.2.0/include/config/enable/init.h busybox-1.2.0solaris/include/config/enable/init.h
--- busybox-1.2.0/include/config/enable/init.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/init.h	2009-04-20 13:24:10.078957249 +0400
@@ -0,0 +1 @@
+#define ENABLE_INIT 1
diff -rupN busybox-1.2.0/include/config/enable/locale/support.h busybox-1.2.0solaris/include/config/enable/locale/support.h
--- busybox-1.2.0/include/config/enable/locale/support.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/locale/support.h	2009-04-17 16:46:43.833236128 +0400
@@ -0,0 +1 @@
+#define ENABLE_LOCALE_SUPPORT 0
diff -rupN busybox-1.2.0/include/config/enable/md5sum.h busybox-1.2.0solaris/include/config/enable/md5sum.h
--- busybox-1.2.0/include/config/enable/md5sum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/md5sum.h	2009-04-17 16:46:43.780723140 +0400
@@ -0,0 +1 @@
+#define ENABLE_MD5SUM 1
diff -rupN busybox-1.2.0/include/config/enable/selinux.h busybox-1.2.0solaris/include/config/enable/selinux.h
--- busybox-1.2.0/include/config/enable/selinux.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/selinux.h	2009-04-17 16:46:43.827302278 +0400
@@ -0,0 +1 @@
+#define ENABLE_SELINUX 0
diff -rupN busybox-1.2.0/include/config/enable/sha1sum.h busybox-1.2.0solaris/include/config/enable/sha1sum.h
--- busybox-1.2.0/include/config/enable/sha1sum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/sha1sum.h	2009-04-17 16:46:43.771584863 +0400
@@ -0,0 +1 @@
+#define ENABLE_SHA1SUM 0
diff -rupN busybox-1.2.0/include/config/enable/show/usage.h busybox-1.2.0solaris/include/config/enable/show/usage.h
--- busybox-1.2.0/include/config/enable/show/usage.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/show/usage.h	2009-04-18 09:34:49.695655627 +0400
@@ -0,0 +1 @@
+#define ENABLE_SHOW_USAGE 1
diff -rupN busybox-1.2.0/include/config/enable/swaponoff.h busybox-1.2.0solaris/include/config/enable/swaponoff.h
--- busybox-1.2.0/include/config/enable/swaponoff.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/enable/swaponoff.h	2009-04-17 16:46:43.520940463 +0400
@@ -0,0 +1 @@
+#define ENABLE_SWAPONOFF 0
diff -rupN busybox-1.2.0/include/config/skip/feature/du/default/blocksize_1k.h busybox-1.2.0solaris/include/config/skip/feature/du/default/blocksize_1k.h
--- busybox-1.2.0/include/config/skip/feature/du/default/blocksize_1k.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/skip/feature/du/default/blocksize_1k.h	2009-04-18 09:51:41.628717980 +0400
@@ -0,0 +1 @@
+#define SKIP_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(...)
diff -rupN busybox-1.2.0/include/config/skip/feature/httpd/auth/md5.h busybox-1.2.0solaris/include/config/skip/feature/httpd/auth/md5.h
--- busybox-1.2.0/include/config/skip/feature/httpd/auth/md5.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/skip/feature/httpd/auth/md5.h	2009-04-17 16:46:43.481300932 +0400
@@ -0,0 +1 @@
+#define SKIP_FEATURE_HTTPD_AUTH_MD5(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/skip/feature/httpd/basic/auth.h busybox-1.2.0solaris/include/config/skip/feature/httpd/basic/auth.h
--- busybox-1.2.0/include/config/skip/feature/httpd/basic/auth.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/skip/feature/httpd/basic/auth.h	2009-04-17 16:46:43.482978434 +0400
@@ -0,0 +1 @@
+#define SKIP_FEATURE_HTTPD_BASIC_AUTH(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/skip/feature/httpd/encode/url/str.h busybox-1.2.0solaris/include/config/skip/feature/httpd/encode/url/str.h
--- busybox-1.2.0/include/config/skip/feature/httpd/encode/url/str.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/skip/feature/httpd/encode/url/str.h	2009-04-17 16:46:43.475054250 +0400
@@ -0,0 +1 @@
+#define SKIP_FEATURE_HTTPD_ENCODE_URL_STR(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/skip/feature/httpd/setuid.h busybox-1.2.0solaris/include/config/skip/feature/httpd/setuid.h
--- busybox-1.2.0/include/config/skip/feature/httpd/setuid.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/skip/feature/httpd/setuid.h	2009-04-17 16:46:43.484475657 +0400
@@ -0,0 +1 @@
+#define SKIP_FEATURE_HTTPD_SETUID(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/skip/feature/httpd/without/inetd.h busybox-1.2.0solaris/include/config/skip/feature/httpd/without/inetd.h
--- busybox-1.2.0/include/config/skip/feature/httpd/without/inetd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/skip/feature/httpd/without/inetd.h	2009-04-17 16:46:43.486494642 +0400
@@ -0,0 +1 @@
+#define SKIP_FEATURE_HTTPD_WITHOUT_INETD(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/skip/feature/human/readable.h busybox-1.2.0solaris/include/config/skip/feature/human/readable.h
--- busybox-1.2.0/include/config/skip/feature/human/readable.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/skip/feature/human/readable.h	2009-04-17 16:46:43.755205425 +0400
@@ -0,0 +1 @@
+#define SKIP_FEATURE_HUMAN_READABLE(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/skip/feature/start/stop/daemon/fancy.h busybox-1.2.0solaris/include/config/skip/feature/start/stop/daemon/fancy.h
--- busybox-1.2.0/include/config/skip/feature/start/stop/daemon/fancy.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/skip/feature/start/stop/daemon/fancy.h	2009-04-17 16:46:43.744290330 +0400
@@ -0,0 +1 @@
+#define SKIP_FEATURE_START_STOP_DAEMON_FANCY(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/addgroup.h busybox-1.2.0solaris/include/config/use/addgroup.h
--- busybox-1.2.0/include/config/use/addgroup.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/addgroup.h	2009-04-17 16:46:43.715998201 +0400
@@ -0,0 +1 @@
+#define USE_ADDGROUP(...)
diff -rupN busybox-1.2.0/include/config/use/adduser.h busybox-1.2.0solaris/include/config/use/adduser.h
--- busybox-1.2.0/include/config/use/adduser.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/adduser.h	2009-04-17 16:46:43.715454239 +0400
@@ -0,0 +1 @@
+#define USE_ADDUSER(...)
diff -rupN busybox-1.2.0/include/config/use/adjtimex.h busybox-1.2.0solaris/include/config/use/adjtimex.h
--- busybox-1.2.0/include/config/use/adjtimex.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/adjtimex.h	2009-04-17 16:46:43.516265441 +0400
@@ -0,0 +1 @@
+#define USE_ADJTIMEX(...)
diff -rupN busybox-1.2.0/include/config/use/app/dumpleases.h busybox-1.2.0solaris/include/config/use/app/dumpleases.h
--- busybox-1.2.0/include/config/use/app/dumpleases.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/app/dumpleases.h	2009-04-17 16:46:43.446466961 +0400
@@ -0,0 +1 @@
+#define USE_APP_DUMPLEASES(...)
diff -rupN busybox-1.2.0/include/config/use/app/udhcpc.h busybox-1.2.0solaris/include/config/use/app/udhcpc.h
--- busybox-1.2.0/include/config/use/app/udhcpc.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/app/udhcpc.h	2009-04-17 16:46:43.446761828 +0400
@@ -0,0 +1 @@
+#define USE_APP_UDHCPC(...)
diff -rupN busybox-1.2.0/include/config/use/app/udhcpd.h busybox-1.2.0solaris/include/config/use/app/udhcpd.h
--- busybox-1.2.0/include/config/use/app/udhcpd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/app/udhcpd.h	2009-04-17 16:46:43.447097236 +0400
@@ -0,0 +1 @@
+#define USE_APP_UDHCPD(...)
diff -rupN busybox-1.2.0/include/config/use/ar.h busybox-1.2.0solaris/include/config/use/ar.h
--- busybox-1.2.0/include/config/use/ar.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ar.h	2009-04-17 16:46:43.823045469 +0400
@@ -0,0 +1 @@
+#define USE_AR(...)
diff -rupN busybox-1.2.0/include/config/use/arping.h busybox-1.2.0solaris/include/config/use/arping.h
--- busybox-1.2.0/include/config/use/arping.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/arping.h	2009-04-17 16:46:43.491445113 +0400
@@ -0,0 +1 @@
+#define USE_ARPING(...)
diff -rupN busybox-1.2.0/include/config/use/ash.h busybox-1.2.0solaris/include/config/use/ash.h
--- busybox-1.2.0/include/config/use/ash.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ash.h	2009-04-18 09:28:20.893552364 +0400
@@ -0,0 +1 @@
+#define USE_ASH(...)
diff -rupN busybox-1.2.0/include/config/use/awk.h busybox-1.2.0solaris/include/config/use/awk.h
--- busybox-1.2.0/include/config/use/awk.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/awk.h	2009-04-17 16:46:43.742048253 +0400
@@ -0,0 +1 @@
+#define USE_AWK(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/basename.h busybox-1.2.0solaris/include/config/use/basename.h
--- busybox-1.2.0/include/config/use/basename.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/basename.h	2009-04-17 16:46:43.806325468 +0400
@@ -0,0 +1 @@
+#define USE_BASENAME(...)
diff -rupN busybox-1.2.0/include/config/use/bb/sysctl.h busybox-1.2.0solaris/include/config/use/bb/sysctl.h
--- busybox-1.2.0/include/config/use/bb/sysctl.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/bb/sysctl.h	2009-04-17 16:46:43.438315822 +0400
@@ -0,0 +1 @@
+#define USE_BB_SYSCTL(...)
diff -rupN busybox-1.2.0/include/config/use/bbconfig.h busybox-1.2.0solaris/include/config/use/bbconfig.h
--- busybox-1.2.0/include/config/use/bbconfig.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/bbconfig.h	2009-04-17 16:46:43.515971289 +0400
@@ -0,0 +1 @@
+#define USE_BBCONFIG(...)
diff -rupN busybox-1.2.0/include/config/use/bunzip2.h busybox-1.2.0solaris/include/config/use/bunzip2.h
--- busybox-1.2.0/include/config/use/bunzip2.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/bunzip2.h	2009-04-17 16:46:43.821966485 +0400
@@ -0,0 +1 @@
+#define USE_BUNZIP2(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/cal.h busybox-1.2.0solaris/include/config/use/cal.h
--- busybox-1.2.0/include/config/use/cal.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/cal.h	2009-04-17 16:46:43.806047971 +0400
@@ -0,0 +1 @@
+#define USE_CAL(...)
diff -rupN busybox-1.2.0/include/config/use/cat.h busybox-1.2.0solaris/include/config/use/cat.h
--- busybox-1.2.0/include/config/use/cat.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/cat.h	2009-04-17 16:46:43.805767454 +0400
@@ -0,0 +1 @@
+#define USE_CAT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/catv.h busybox-1.2.0solaris/include/config/use/catv.h
--- busybox-1.2.0/include/config/use/catv.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/catv.h	2009-04-17 16:46:43.805472806 +0400
@@ -0,0 +1 @@
+#define USE_CATV(...)
diff -rupN busybox-1.2.0/include/config/use/chattr.h busybox-1.2.0solaris/include/config/use/chattr.h
--- busybox-1.2.0/include/config/use/chattr.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/chattr.h	2009-04-17 16:46:43.711514935 +0400
@@ -0,0 +1 @@
+#define USE_CHATTR(...)
diff -rupN busybox-1.2.0/include/config/use/chgrp.h busybox-1.2.0solaris/include/config/use/chgrp.h
--- busybox-1.2.0/include/config/use/chgrp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/chgrp.h	2009-04-17 16:46:43.805165127 +0400
@@ -0,0 +1 @@
+#define USE_CHGRP(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/chmod.h busybox-1.2.0solaris/include/config/use/chmod.h
--- busybox-1.2.0/include/config/use/chmod.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/chmod.h	2009-04-17 16:46:43.804883528 +0400
@@ -0,0 +1 @@
+#define USE_CHMOD(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/chown.h busybox-1.2.0solaris/include/config/use/chown.h
--- busybox-1.2.0/include/config/use/chown.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/chown.h	2009-04-17 16:46:43.804572402 +0400
@@ -0,0 +1 @@
+#define USE_CHOWN(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/chroot.h busybox-1.2.0solaris/include/config/use/chroot.h
--- busybox-1.2.0/include/config/use/chroot.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/chroot.h	2009-04-17 16:46:43.804244769 +0400
@@ -0,0 +1 @@
+#define USE_CHROOT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/chvt.h busybox-1.2.0solaris/include/config/use/chvt.h
--- busybox-1.2.0/include/config/use/chvt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/chvt.h	2009-04-17 16:59:15.270350613 +0400
@@ -0,0 +1 @@
+#define USE_CHVT(...)
diff -rupN busybox-1.2.0/include/config/use/cksum.h busybox-1.2.0solaris/include/config/use/cksum.h
--- busybox-1.2.0/include/config/use/cksum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/cksum.h	2009-04-17 16:46:43.803954940 +0400
@@ -0,0 +1 @@
+#define USE_CKSUM(...)
diff -rupN busybox-1.2.0/include/config/use/clear.h busybox-1.2.0solaris/include/config/use/clear.h
--- busybox-1.2.0/include/config/use/clear.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/clear.h	2009-04-17 16:46:43.752621467 +0400
@@ -0,0 +1 @@
+#define USE_CLEAR(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/cmp.h busybox-1.2.0solaris/include/config/use/cmp.h
--- busybox-1.2.0/include/config/use/cmp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/cmp.h	2009-04-17 16:46:43.803676769 +0400
@@ -0,0 +1 @@
+#define USE_CMP(...)
diff -rupN busybox-1.2.0/include/config/use/comm.h busybox-1.2.0solaris/include/config/use/comm.h
--- busybox-1.2.0/include/config/use/comm.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/comm.h	2009-04-17 16:46:43.803399523 +0400
@@ -0,0 +1 @@
+#define USE_COMM(...)
diff -rupN busybox-1.2.0/include/config/use/cp.h busybox-1.2.0solaris/include/config/use/cp.h
--- busybox-1.2.0/include/config/use/cp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/cp.h	2009-04-17 16:46:43.803108221 +0400
@@ -0,0 +1 @@
+#define USE_CP(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/cpio.h busybox-1.2.0solaris/include/config/use/cpio.h
--- busybox-1.2.0/include/config/use/cpio.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/cpio.h	2009-04-17 16:46:43.821680371 +0400
@@ -0,0 +1 @@
+#define USE_CPIO(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/crond.h busybox-1.2.0solaris/include/config/use/crond.h
--- busybox-1.2.0/include/config/use/crond.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/crond.h	2009-04-17 16:46:43.515586305 +0400
@@ -0,0 +1 @@
+#define USE_CROND(...)
diff -rupN busybox-1.2.0/include/config/use/crontab.h busybox-1.2.0solaris/include/config/use/crontab.h
--- busybox-1.2.0/include/config/use/crontab.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/crontab.h	2009-04-17 16:46:43.514019537 +0400
@@ -0,0 +1 @@
+#define USE_CRONTAB(...)
diff -rupN busybox-1.2.0/include/config/use/cut.h busybox-1.2.0solaris/include/config/use/cut.h
--- busybox-1.2.0/include/config/use/cut.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/cut.h	2009-04-17 16:46:43.802793366 +0400
@@ -0,0 +1 @@
+#define USE_CUT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/date.h busybox-1.2.0solaris/include/config/use/date.h
--- busybox-1.2.0/include/config/use/date.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/date.h	2009-04-17 16:46:43.802516669 +0400
@@ -0,0 +1 @@
+#define USE_DATE(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/dc.h busybox-1.2.0solaris/include/config/use/dc.h
--- busybox-1.2.0/include/config/use/dc.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dc.h	2009-04-17 16:46:43.513744998 +0400
@@ -0,0 +1 @@
+#define USE_DC(...)
diff -rupN busybox-1.2.0/include/config/use/dd.h busybox-1.2.0solaris/include/config/use/dd.h
--- busybox-1.2.0/include/config/use/dd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dd.h	2009-04-17 16:46:43.801196090 +0400
@@ -0,0 +1 @@
+#define USE_DD(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/deallocvt.h busybox-1.2.0solaris/include/config/use/deallocvt.h
--- busybox-1.2.0/include/config/use/deallocvt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/deallocvt.h	2009-04-17 16:46:43.752334834 +0400
@@ -0,0 +1 @@
+#define USE_DEALLOCVT(...)
diff -rupN busybox-1.2.0/include/config/use/delgroup.h busybox-1.2.0solaris/include/config/use/delgroup.h
--- busybox-1.2.0/include/config/use/delgroup.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/delgroup.h	2009-04-17 16:46:43.715728346 +0400
@@ -0,0 +1 @@
+#define USE_DELGROUP(...)
diff -rupN busybox-1.2.0/include/config/use/deluser.h busybox-1.2.0solaris/include/config/use/deluser.h
--- busybox-1.2.0/include/config/use/deluser.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/deluser.h	2009-04-17 16:46:43.714892856 +0400
@@ -0,0 +1 @@
+#define USE_DELUSER(...)
diff -rupN busybox-1.2.0/include/config/use/devfsd/fg/np.h busybox-1.2.0solaris/include/config/use/devfsd/fg/np.h
--- busybox-1.2.0/include/config/use/devfsd/fg/np.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/devfsd/fg/np.h	2009-04-17 16:46:43.512357159 +0400
@@ -0,0 +1 @@
+#define USE_DEVFSD_FG_NP(...)
diff -rupN busybox-1.2.0/include/config/use/devfsd.h busybox-1.2.0solaris/include/config/use/devfsd.h
--- busybox-1.2.0/include/config/use/devfsd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/devfsd.h	2009-04-17 16:46:43.513454508 +0400
@@ -0,0 +1 @@
+#define USE_DEVFSD(...)
diff -rupN busybox-1.2.0/include/config/use/df.h busybox-1.2.0solaris/include/config/use/df.h
--- busybox-1.2.0/include/config/use/df.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/df.h	2009-04-20 10:50:14.405572529 +0400
@@ -0,0 +1 @@
+#define USE_DF(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/diff.h busybox-1.2.0solaris/include/config/use/diff.h
--- busybox-1.2.0/include/config/use/diff.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/diff.h	2009-04-17 16:46:43.798573846 +0400
@@ -0,0 +1 @@
+#define USE_DIFF(...)
diff -rupN busybox-1.2.0/include/config/use/dirname.h busybox-1.2.0solaris/include/config/use/dirname.h
--- busybox-1.2.0/include/config/use/dirname.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dirname.h	2009-04-17 16:46:43.796918212 +0400
@@ -0,0 +1 @@
+#define USE_DIRNAME(...)
diff -rupN busybox-1.2.0/include/config/use/dmesg.h busybox-1.2.0solaris/include/config/use/dmesg.h
--- busybox-1.2.0/include/config/use/dmesg.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dmesg.h	2009-04-17 16:46:43.536975388 +0400
@@ -0,0 +1 @@
+#define USE_DMESG(...)
diff -rupN busybox-1.2.0/include/config/use/dnsd.h busybox-1.2.0solaris/include/config/use/dnsd.h
--- busybox-1.2.0/include/config/use/dnsd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dnsd.h	2009-04-17 16:46:43.491170999 +0400
@@ -0,0 +1 @@
+#define USE_DNSD(...)
diff -rupN busybox-1.2.0/include/config/use/dos2unix.h busybox-1.2.0solaris/include/config/use/dos2unix.h
--- busybox-1.2.0/include/config/use/dos2unix.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dos2unix.h	2009-04-17 16:46:43.796645925 +0400
@@ -0,0 +1 @@
+#define USE_DOS2UNIX(...)
diff -rupN busybox-1.2.0/include/config/use/dpkg/deb.h busybox-1.2.0solaris/include/config/use/dpkg/deb.h
--- busybox-1.2.0/include/config/use/dpkg/deb.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dpkg/deb.h	2009-04-17 16:46:43.821037984 +0400
@@ -0,0 +1 @@
+#define USE_DPKG_DEB(...)
diff -rupN busybox-1.2.0/include/config/use/dpkg.h busybox-1.2.0solaris/include/config/use/dpkg.h
--- busybox-1.2.0/include/config/use/dpkg.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dpkg.h	2009-04-17 16:46:43.821376290 +0400
@@ -0,0 +1 @@
+#define USE_DPKG(...)
diff -rupN busybox-1.2.0/include/config/use/du.h busybox-1.2.0solaris/include/config/use/du.h
--- busybox-1.2.0/include/config/use/du.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/du.h	2009-04-18 09:51:41.629336006 +0400
@@ -0,0 +1 @@
+#define USE_DU(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/dumpkmap.h busybox-1.2.0solaris/include/config/use/dumpkmap.h
--- busybox-1.2.0/include/config/use/dumpkmap.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/dumpkmap.h	2009-04-17 16:46:43.752030009 +0400
@@ -0,0 +1 @@
+#define USE_DUMPKMAP(...)
diff -rupN busybox-1.2.0/include/config/use/e2fsck.h busybox-1.2.0solaris/include/config/use/e2fsck.h
--- busybox-1.2.0/include/config/use/e2fsck.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/e2fsck.h	2009-04-17 16:46:43.711171907 +0400
@@ -0,0 +1 @@
+#define USE_E2FSCK(...)
diff -rupN busybox-1.2.0/include/config/use/e2label.h busybox-1.2.0solaris/include/config/use/e2label.h
--- busybox-1.2.0/include/config/use/e2label.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/e2label.h	2009-04-17 16:46:43.709110767 +0400
@@ -0,0 +1 @@
+#define USE_E2LABEL(...)
diff -rupN busybox-1.2.0/include/config/use/echo.h busybox-1.2.0solaris/include/config/use/echo.h
--- busybox-1.2.0/include/config/use/echo.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/echo.h	2009-04-17 16:46:43.793688642 +0400
@@ -0,0 +1 @@
+#define USE_ECHO(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/ed.h busybox-1.2.0solaris/include/config/use/ed.h
--- busybox-1.2.0/include/config/use/ed.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ed.h	2009-04-17 16:46:43.741265572 +0400
@@ -0,0 +1 @@
+#define USE_ED(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/eject.h busybox-1.2.0solaris/include/config/use/eject.h
--- busybox-1.2.0/include/config/use/eject.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/eject.h	2009-04-17 16:46:43.510506540 +0400
@@ -0,0 +1 @@
+#define USE_EJECT(...)
diff -rupN busybox-1.2.0/include/config/use/env.h busybox-1.2.0solaris/include/config/use/env.h
--- busybox-1.2.0/include/config/use/env.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/env.h	2009-04-18 09:53:11.491564545 +0400
@@ -0,0 +1 @@
+#define USE_ENV(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/ether/wake.h busybox-1.2.0solaris/include/config/use/ether/wake.h
--- busybox-1.2.0/include/config/use/ether/wake.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ether/wake.h	2009-04-17 16:46:43.490885501 +0400
@@ -0,0 +1 @@
+#define USE_ETHER_WAKE(...)
diff -rupN busybox-1.2.0/include/config/use/expr.h busybox-1.2.0solaris/include/config/use/expr.h
--- busybox-1.2.0/include/config/use/expr.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/expr.h	2009-04-17 16:46:43.791795315 +0400
@@ -0,0 +1 @@
+#define USE_EXPR(...)
diff -rupN busybox-1.2.0/include/config/use/fakeidentd.h busybox-1.2.0solaris/include/config/use/fakeidentd.h
--- busybox-1.2.0/include/config/use/fakeidentd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fakeidentd.h	2009-04-17 16:46:43.490441442 +0400
@@ -0,0 +1 @@
+#define USE_FAKEIDENTD(...)
diff -rupN busybox-1.2.0/include/config/use/false.h busybox-1.2.0solaris/include/config/use/false.h
--- busybox-1.2.0/include/config/use/false.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/false.h	2009-04-17 16:46:43.790825847 +0400
@@ -0,0 +1 @@
+#define USE_FALSE(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/fbset.h busybox-1.2.0solaris/include/config/use/fbset.h
--- busybox-1.2.0/include/config/use/fbset.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fbset.h	2009-04-17 16:46:43.536669695 +0400
@@ -0,0 +1 @@
+#define USE_FBSET(...)
diff -rupN busybox-1.2.0/include/config/use/fdflush.h busybox-1.2.0solaris/include/config/use/fdflush.h
--- busybox-1.2.0/include/config/use/fdflush.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fdflush.h	2009-04-17 16:46:43.535250631 +0400
@@ -0,0 +1 @@
+#define USE_FDFLUSH(...)
diff -rupN busybox-1.2.0/include/config/use/fdformat.h busybox-1.2.0solaris/include/config/use/fdformat.h
--- busybox-1.2.0/include/config/use/fdformat.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fdformat.h	2009-04-17 16:46:43.534972151 +0400
@@ -0,0 +1 @@
+#define USE_FDFORMAT(...)
diff -rupN busybox-1.2.0/include/config/use/fdisk.h busybox-1.2.0solaris/include/config/use/fdisk.h
--- busybox-1.2.0/include/config/use/fdisk.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fdisk.h	2009-04-17 16:46:43.534693601 +0400
@@ -0,0 +1 @@
+#define USE_FDISK(...)
diff -rupN busybox-1.2.0/include/config/use/feature/command/editing.h busybox-1.2.0solaris/include/config/use/feature/command/editing.h
--- busybox-1.2.0/include/config/use/feature/command/editing.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/command/editing.h	2009-04-17 16:46:43.422193633 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_COMMAND_EDITING(...)
diff -rupN busybox-1.2.0/include/config/use/feature/date/isofmt.h busybox-1.2.0solaris/include/config/use/feature/date/isofmt.h
--- busybox-1.2.0/include/config/use/feature/date/isofmt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/date/isofmt.h	2009-04-17 16:46:43.801675765 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_DATE_ISOFMT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/dd/ibs/obs.h busybox-1.2.0solaris/include/config/use/feature/dd/ibs/obs.h
--- busybox-1.2.0/include/config/use/feature/dd/ibs/obs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/dd/ibs/obs.h	2009-04-17 16:46:43.799530660 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_DD_IBS_OBS(...)
diff -rupN busybox-1.2.0/include/config/use/feature/du/default/blocksize_1k.h busybox-1.2.0solaris/include/config/use/feature/du/default/blocksize_1k.h
--- busybox-1.2.0/include/config/use/feature/du/default/blocksize_1k.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/du/default/blocksize_1k.h	2009-04-18 09:51:41.628945429 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/fancy/echo.h busybox-1.2.0solaris/include/config/use/feature/fancy/echo.h
--- busybox-1.2.0/include/config/use/feature/fancy/echo.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/fancy/echo.h	2009-04-17 16:46:43.793085518 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FANCY_ECHO(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/fancy/head.h busybox-1.2.0solaris/include/config/use/feature/fancy/head.h
--- busybox-1.2.0/include/config/use/feature/fancy/head.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/fancy/head.h	2009-04-17 16:46:43.789397294 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FANCY_HEAD(...)
diff -rupN busybox-1.2.0/include/config/use/feature/find/exec.h busybox-1.2.0solaris/include/config/use/feature/find/exec.h
--- busybox-1.2.0/include/config/use/feature/find/exec.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/find/exec.h	2009-04-17 16:46:43.728477752 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FIND_EXEC(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/find/inum.h busybox-1.2.0solaris/include/config/use/feature/find/inum.h
--- busybox-1.2.0/include/config/use/feature/find/inum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/find/inum.h	2009-04-17 16:46:43.729371900 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FIND_INUM(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/find/mmin.h busybox-1.2.0solaris/include/config/use/feature/find/mmin.h
--- busybox-1.2.0/include/config/use/feature/find/mmin.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/find/mmin.h	2009-04-17 16:46:43.732706885 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FIND_MMIN(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/find/mtime.h busybox-1.2.0solaris/include/config/use/feature/find/mtime.h
--- busybox-1.2.0/include/config/use/feature/find/mtime.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/find/mtime.h	2009-04-17 16:46:43.733444363 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FIND_MTIME(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/find/newer.h busybox-1.2.0solaris/include/config/use/feature/find/newer.h
--- busybox-1.2.0/include/config/use/feature/find/newer.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/find/newer.h	2009-04-17 16:46:43.730172596 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FIND_NEWER(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/find/perm.h busybox-1.2.0solaris/include/config/use/feature/find/perm.h
--- busybox-1.2.0/include/config/use/feature/find/perm.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/find/perm.h	2009-04-17 16:46:43.732031373 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FIND_PERM(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/find/print0.h busybox-1.2.0solaris/include/config/use/feature/find/print0.h
--- busybox-1.2.0/include/config/use/feature/find/print0.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/find/print0.h	2009-04-17 16:46:43.734139961 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FIND_PRINT0(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/find/type.h busybox-1.2.0solaris/include/config/use/feature/find/type.h
--- busybox-1.2.0/include/config/use/feature/find/type.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/find/type.h	2009-04-17 16:46:43.731321659 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_FIND_TYPE(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/grep/context.h busybox-1.2.0solaris/include/config/use/feature/grep/context.h
--- busybox-1.2.0/include/config/use/feature/grep/context.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/grep/context.h	2009-04-17 16:46:43.725049857 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_GREP_CONTEXT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/grep/egrep/alias.h busybox-1.2.0solaris/include/config/use/feature/grep/egrep/alias.h
--- busybox-1.2.0/include/config/use/feature/grep/egrep/alias.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/grep/egrep/alias.h	2009-04-17 16:46:43.727160241 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_GREP_EGREP_ALIAS(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/grep/fgrep/alias.h busybox-1.2.0solaris/include/config/use/feature/grep/fgrep/alias.h
--- busybox-1.2.0/include/config/use/feature/grep/fgrep/alias.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/grep/fgrep/alias.h	2009-04-17 16:46:43.726060750 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_GREP_FGREP_ALIAS(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/hdparm/get/identity.h busybox-1.2.0solaris/include/config/use/feature/hdparm/get/identity.h
--- busybox-1.2.0/include/config/use/feature/hdparm/get/identity.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/hdparm/get/identity.h	2009-04-17 16:46:43.506024034 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HDPARM_GET_IDENTITY(...)
diff -rupN busybox-1.2.0/include/config/use/feature/hdparm/hdio/drive/reset.h busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/drive/reset.h
--- busybox-1.2.0/include/config/use/feature/hdparm/hdio/drive/reset.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/drive/reset.h	2009-04-17 16:46:43.501736510 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HDPARM_HDIO_DRIVE_RESET(...)
diff -rupN busybox-1.2.0/include/config/use/feature/hdparm/hdio/getset/dma.h busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/getset/dma.h
--- busybox-1.2.0/include/config/use/feature/hdparm/hdio/getset/dma.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/getset/dma.h	2009-04-17 16:46:43.499082735 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HDPARM_HDIO_GETSET_DMA(...)
diff -rupN busybox-1.2.0/include/config/use/feature/hdparm/hdio/scan/hwif.h busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/scan/hwif.h
--- busybox-1.2.0/include/config/use/feature/hdparm/hdio/scan/hwif.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/scan/hwif.h	2009-04-17 16:46:43.504068643 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HDPARM_HDIO_SCAN_HWIF(...)
diff -rupN busybox-1.2.0/include/config/use/feature/hdparm/hdio/tristate/hwif.h busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/tristate/hwif.h
--- busybox-1.2.0/include/config/use/feature/hdparm/hdio/tristate/hwif.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/tristate/hwif.h	2009-04-17 16:46:43.500612048 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF(...)
diff -rupN busybox-1.2.0/include/config/use/feature/hdparm/hdio/unregister/hwif.h busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/unregister/hwif.h
--- busybox-1.2.0/include/config/use/feature/hdparm/hdio/unregister/hwif.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/hdparm/hdio/unregister/hwif.h	2009-04-17 16:46:43.502939464 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HDPARM_HDIO_UNREGISTER_HWIF(...)
diff -rupN busybox-1.2.0/include/config/use/feature/httpd/auth/md5.h busybox-1.2.0solaris/include/config/use/feature/httpd/auth/md5.h
--- busybox-1.2.0/include/config/use/feature/httpd/auth/md5.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/httpd/auth/md5.h	2009-04-17 16:46:43.481896165 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HTTPD_AUTH_MD5(...)
diff -rupN busybox-1.2.0/include/config/use/feature/httpd/basic/auth.h busybox-1.2.0solaris/include/config/use/feature/httpd/basic/auth.h
--- busybox-1.2.0/include/config/use/feature/httpd/basic/auth.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/httpd/basic/auth.h	2009-04-17 16:46:43.483518959 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HTTPD_BASIC_AUTH(...)
diff -rupN busybox-1.2.0/include/config/use/feature/httpd/cgi.h busybox-1.2.0solaris/include/config/use/feature/httpd/cgi.h
--- busybox-1.2.0/include/config/use/feature/httpd/cgi.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/httpd/cgi.h	2009-04-17 16:46:43.479652190 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HTTPD_CGI(...)
diff -rupN busybox-1.2.0/include/config/use/feature/httpd/encode/url/str.h busybox-1.2.0solaris/include/config/use/feature/httpd/encode/url/str.h
--- busybox-1.2.0/include/config/use/feature/httpd/encode/url/str.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/httpd/encode/url/str.h	2009-04-17 16:46:43.476031647 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HTTPD_ENCODE_URL_STR(...)
diff -rupN busybox-1.2.0/include/config/use/feature/httpd/setuid.h busybox-1.2.0solaris/include/config/use/feature/httpd/setuid.h
--- busybox-1.2.0/include/config/use/feature/httpd/setuid.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/httpd/setuid.h	2009-04-17 16:46:43.484817523 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HTTPD_SETUID(...)
diff -rupN busybox-1.2.0/include/config/use/feature/httpd/without/inetd.h busybox-1.2.0solaris/include/config/use/feature/httpd/without/inetd.h
--- busybox-1.2.0/include/config/use/feature/httpd/without/inetd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/httpd/without/inetd.h	2009-04-17 16:46:43.487145127 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HTTPD_WITHOUT_INETD(...)
diff -rupN busybox-1.2.0/include/config/use/feature/human/readable.h busybox-1.2.0solaris/include/config/use/feature/human/readable.h
--- busybox-1.2.0/include/config/use/feature/human/readable.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/human/readable.h	2009-04-17 16:46:43.755770361 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_HUMAN_READABLE(...)
diff -rupN busybox-1.2.0/include/config/use/feature/initrd.h busybox-1.2.0solaris/include/config/use/feature/initrd.h
--- busybox-1.2.0/include/config/use/feature/initrd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/initrd.h	2009-04-17 16:46:43.718761686 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_INITRD(...)
diff -rupN busybox-1.2.0/include/config/use/feature/ipcalc/fancy.h busybox-1.2.0solaris/include/config/use/feature/ipcalc/fancy.h
--- busybox-1.2.0/include/config/use/feature/ipcalc/fancy.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/ipcalc/fancy.h	2009-04-17 16:46:43.460799974 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_IPCALC_FANCY(...)
diff -rupN busybox-1.2.0/include/config/use/feature/ls/sortfiles.h busybox-1.2.0solaris/include/config/use/feature/ls/sortfiles.h
--- busybox-1.2.0/include/config/use/feature/ls/sortfiles.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/ls/sortfiles.h	2009-04-17 16:46:43.783960512 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_LS_SORTFILES(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/mdev/exec.h busybox-1.2.0solaris/include/config/use/feature/mdev/exec.h
--- busybox-1.2.0/include/config/use/feature/mdev/exec.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/mdev/exec.h	2009-04-17 16:46:43.525022238 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_MDEV_EXEC(...)
diff -rupN busybox-1.2.0/include/config/use/feature/mtab/support.h busybox-1.2.0solaris/include/config/use/feature/mtab/support.h
--- busybox-1.2.0/include/config/use/feature/mtab/support.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/mtab/support.h	2009-04-17 16:46:43.516807376 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_MTAB_SUPPORT(...)
diff -rupN busybox-1.2.0/include/config/use/feature/sh/is/ash.h busybox-1.2.0solaris/include/config/use/feature/sh/is/ash.h
--- busybox-1.2.0/include/config/use/feature/sh/is/ash.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/sh/is/ash.h	2009-04-18 09:26:07.543136734 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_SH_IS_ASH(...)
diff -rupN busybox-1.2.0/include/config/use/feature/sh/is/hush.h busybox-1.2.0solaris/include/config/use/feature/sh/is/hush.h
--- busybox-1.2.0/include/config/use/feature/sh/is/hush.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/sh/is/hush.h	2009-04-18 09:31:38.991459275 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_SH_IS_HUSH(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/feature/sh/is/lash.h busybox-1.2.0solaris/include/config/use/feature/sh/is/lash.h
--- busybox-1.2.0/include/config/use/feature/sh/is/lash.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/sh/is/lash.h	2009-04-18 09:30:26.867706696 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_SH_IS_LASH(...)
diff -rupN busybox-1.2.0/include/config/use/feature/sh/is/msh.h busybox-1.2.0solaris/include/config/use/feature/sh/is/msh.h
--- busybox-1.2.0/include/config/use/feature/sh/is/msh.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/sh/is/msh.h	2009-04-18 09:31:38.991139702 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_SH_IS_MSH(...)
diff -rupN busybox-1.2.0/include/config/use/feature/start/stop/daemon/fancy.h busybox-1.2.0solaris/include/config/use/feature/start/stop/daemon/fancy.h
--- busybox-1.2.0/include/config/use/feature/start/stop/daemon/fancy.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/start/stop/daemon/fancy.h	2009-04-17 16:46:43.745169692 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_START_STOP_DAEMON_FANCY(...)
diff -rupN busybox-1.2.0/include/config/use/feature/stat/format.h busybox-1.2.0solaris/include/config/use/feature/stat/format.h
--- busybox-1.2.0/include/config/use/feature/stat/format.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/stat/format.h	2009-04-17 16:46:43.768125983 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_STAT_FORMAT(...)
diff -rupN busybox-1.2.0/include/config/use/feature/tftp/blocksize.h busybox-1.2.0solaris/include/config/use/feature/tftp/blocksize.h
--- busybox-1.2.0/include/config/use/feature/tftp/blocksize.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/tftp/blocksize.h	2009-04-17 16:46:43.450057737 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_TFTP_BLOCKSIZE(...)
diff -rupN busybox-1.2.0/include/config/use/feature/top/cpu/usage/percentage.h busybox-1.2.0solaris/include/config/use/feature/top/cpu/usage/percentage.h
--- busybox-1.2.0/include/config/use/feature/top/cpu/usage/percentage.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/feature/top/cpu/usage/percentage.h	2009-04-17 16:46:43.436831779 +0400
@@ -0,0 +1 @@
+#define USE_FEATURE_TOP_CPU_USAGE_PERCENTAGE(...)
diff -rupN busybox-1.2.0/include/config/use/find.h busybox-1.2.0solaris/include/config/use/find.h
--- busybox-1.2.0/include/config/use/find.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/find.h	2009-04-17 16:46:43.734750415 +0400
@@ -0,0 +1 @@
+#define USE_FIND(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/findfs.h busybox-1.2.0solaris/include/config/use/findfs.h
--- busybox-1.2.0/include/config/use/findfs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/findfs.h	2009-04-17 16:46:43.708241131 +0400
@@ -0,0 +1 @@
+#define USE_FINDFS(...)
diff -rupN busybox-1.2.0/include/config/use/fold.h busybox-1.2.0solaris/include/config/use/fold.h
--- busybox-1.2.0/include/config/use/fold.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fold.h	2009-04-17 16:46:43.790538068 +0400
@@ -0,0 +1 @@
+#define USE_FOLD(...)
diff -rupN busybox-1.2.0/include/config/use/free.h busybox-1.2.0solaris/include/config/use/free.h
--- busybox-1.2.0/include/config/use/free.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/free.h	2009-04-17 16:46:43.442295987 +0400
@@ -0,0 +1 @@
+#define USE_FREE(...)
diff -rupN busybox-1.2.0/include/config/use/freeramdisk.h busybox-1.2.0solaris/include/config/use/freeramdisk.h
--- busybox-1.2.0/include/config/use/freeramdisk.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/freeramdisk.h	2009-04-17 16:46:43.531130329 +0400
@@ -0,0 +1 @@
+#define USE_FREERAMDISK(...)
diff -rupN busybox-1.2.0/include/config/use/fsck/minix.h busybox-1.2.0solaris/include/config/use/fsck/minix.h
--- busybox-1.2.0/include/config/use/fsck/minix.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fsck/minix.h	2009-04-17 16:46:43.530847057 +0400
@@ -0,0 +1 @@
+#define USE_FSCK_MINIX(...)
diff -rupN busybox-1.2.0/include/config/use/fsck.h busybox-1.2.0solaris/include/config/use/fsck.h
--- busybox-1.2.0/include/config/use/fsck.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fsck.h	2009-04-17 16:46:43.710905653 +0400
@@ -0,0 +1 @@
+#define USE_FSCK(...)
diff -rupN busybox-1.2.0/include/config/use/ftpget.h busybox-1.2.0solaris/include/config/use/ftpget.h
--- busybox-1.2.0/include/config/use/ftpget.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ftpget.h	2009-04-17 16:46:43.489814976 +0400
@@ -0,0 +1 @@
+#define USE_FTPGET(...)
diff -rupN busybox-1.2.0/include/config/use/ftpput.h busybox-1.2.0solaris/include/config/use/ftpput.h
--- busybox-1.2.0/include/config/use/ftpput.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ftpput.h	2009-04-17 16:46:43.489203548 +0400
@@ -0,0 +1 @@
+#define USE_FTPPUT(...)
diff -rupN busybox-1.2.0/include/config/use/fuser.h busybox-1.2.0solaris/include/config/use/fuser.h
--- busybox-1.2.0/include/config/use/fuser.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/fuser.h	2009-04-17 16:46:43.442043515 +0400
@@ -0,0 +1 @@
+#define USE_FUSER(...)
diff -rupN busybox-1.2.0/include/config/use/getopt.h busybox-1.2.0solaris/include/config/use/getopt.h
--- busybox-1.2.0/include/config/use/getopt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/getopt.h	2009-04-17 16:46:43.529209988 +0400
@@ -0,0 +1 @@
+#define USE_GETOPT(...)
diff -rupN busybox-1.2.0/include/config/use/getty.h busybox-1.2.0solaris/include/config/use/getty.h
--- busybox-1.2.0/include/config/use/getty.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/getty.h	2009-04-17 16:46:43.714617621 +0400
@@ -0,0 +1 @@
+#define USE_GETTY(...)
diff -rupN busybox-1.2.0/include/config/use/grep.h busybox-1.2.0solaris/include/config/use/grep.h
--- busybox-1.2.0/include/config/use/grep.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/grep.h	2009-04-17 16:46:43.727979460 +0400
@@ -0,0 +1 @@
+#define USE_GREP(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/gunzip.h busybox-1.2.0solaris/include/config/use/gunzip.h
--- busybox-1.2.0/include/config/use/gunzip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/gunzip.h	2009-04-17 16:46:43.820082189 +0400
@@ -0,0 +1 @@
+#define USE_GUNZIP(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/gzip.h busybox-1.2.0solaris/include/config/use/gzip.h
--- busybox-1.2.0/include/config/use/gzip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/gzip.h	2009-04-17 16:46:43.819207947 +0400
@@ -0,0 +1 @@
+#define USE_GZIP(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/halt.h busybox-1.2.0solaris/include/config/use/halt.h
--- busybox-1.2.0/include/config/use/halt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/halt.h	2009-04-18 09:38:01.580081601 +0400
@@ -0,0 +1 @@
+#define USE_HALT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/hdparm.h busybox-1.2.0solaris/include/config/use/hdparm.h
--- busybox-1.2.0/include/config/use/hdparm.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/hdparm.h	2009-04-17 16:46:43.507464876 +0400
@@ -0,0 +1 @@
+#define USE_HDPARM(...)
diff -rupN busybox-1.2.0/include/config/use/head.h busybox-1.2.0solaris/include/config/use/head.h
--- busybox-1.2.0/include/config/use/head.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/head.h	2009-04-17 16:46:43.790090054 +0400
@@ -0,0 +1 @@
+#define USE_HEAD(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/hexdump.h busybox-1.2.0solaris/include/config/use/hexdump.h
--- busybox-1.2.0/include/config/use/hexdump.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/hexdump.h	2009-04-17 16:46:43.528912557 +0400
@@ -0,0 +1 @@
+#define USE_HEXDUMP(...)
diff -rupN busybox-1.2.0/include/config/use/hostid.h busybox-1.2.0solaris/include/config/use/hostid.h
--- busybox-1.2.0/include/config/use/hostid.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/hostid.h	2009-04-17 16:46:43.788761118 +0400
@@ -0,0 +1 @@
+#define USE_HOSTID(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/hostname.h busybox-1.2.0solaris/include/config/use/hostname.h
--- busybox-1.2.0/include/config/use/hostname.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/hostname.h	2009-04-18 09:54:07.523459808 +0400
@@ -0,0 +1 @@
+#define USE_HOSTNAME(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/httpd.h busybox-1.2.0solaris/include/config/use/httpd.h
--- busybox-1.2.0/include/config/use/httpd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/httpd.h	2009-04-17 16:46:43.487958831 +0400
@@ -0,0 +1 @@
+#define USE_HTTPD(...)
diff -rupN busybox-1.2.0/include/config/use/hush.h busybox-1.2.0solaris/include/config/use/hush.h
--- busybox-1.2.0/include/config/use/hush.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/hush.h	2009-04-18 09:31:38.988631120 +0400
@@ -0,0 +1 @@
+#define USE_HUSH(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/hwclock.h busybox-1.2.0solaris/include/config/use/hwclock.h
--- busybox-1.2.0/include/config/use/hwclock.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/hwclock.h	2009-04-17 16:46:43.528637774 +0400
@@ -0,0 +1 @@
+#define USE_HWCLOCK(...)
diff -rupN busybox-1.2.0/include/config/use/id.h busybox-1.2.0solaris/include/config/use/id.h
--- busybox-1.2.0/include/config/use/id.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/id.h	2009-04-17 16:46:43.788452199 +0400
@@ -0,0 +1 @@
+#define USE_ID(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/ifconfig.h busybox-1.2.0solaris/include/config/use/ifconfig.h
--- busybox-1.2.0/include/config/use/ifconfig.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ifconfig.h	2009-04-17 16:46:43.473889496 +0400
@@ -0,0 +1 @@
+#define USE_IFCONFIG(...)
diff -rupN busybox-1.2.0/include/config/use/ifupdown.h busybox-1.2.0solaris/include/config/use/ifupdown.h
--- busybox-1.2.0/include/config/use/ifupdown.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ifupdown.h	2009-04-17 16:46:43.471191405 +0400
@@ -0,0 +1 @@
+#define USE_IFUPDOWN(...)
diff -rupN busybox-1.2.0/include/config/use/inetd.h busybox-1.2.0solaris/include/config/use/inetd.h
--- busybox-1.2.0/include/config/use/inetd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/inetd.h	2009-04-17 16:46:43.468187268 +0400
@@ -0,0 +1 @@
+#define USE_INETD(...)
diff -rupN busybox-1.2.0/include/config/use/init.h busybox-1.2.0solaris/include/config/use/init.h
--- busybox-1.2.0/include/config/use/init.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/init.h	2009-04-20 13:24:10.078327335 +0400
@@ -0,0 +1 @@
+#define USE_INIT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/insmod.h busybox-1.2.0solaris/include/config/use/insmod.h
--- busybox-1.2.0/include/config/use/insmod.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/insmod.h	2009-04-17 16:46:43.707965208 +0400
@@ -0,0 +1 @@
+#define USE_INSMOD(...)
diff -rupN busybox-1.2.0/include/config/use/install.h busybox-1.2.0solaris/include/config/use/install.h
--- busybox-1.2.0/include/config/use/install.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/install.h	2009-04-17 16:46:43.788145408 +0400
@@ -0,0 +1 @@
+#define USE_INSTALL(...)
diff -rupN busybox-1.2.0/include/config/use/ip.h busybox-1.2.0solaris/include/config/use/ip.h
--- busybox-1.2.0/include/config/use/ip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ip.h	2009-04-17 16:46:43.464966190 +0400
@@ -0,0 +1 @@
+#define USE_IP(...)
diff -rupN busybox-1.2.0/include/config/use/ipaddr.h busybox-1.2.0solaris/include/config/use/ipaddr.h
--- busybox-1.2.0/include/config/use/ipaddr.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ipaddr.h	2009-04-17 16:46:43.463092021 +0400
@@ -0,0 +1 @@
+#define USE_IPADDR(...)
diff -rupN busybox-1.2.0/include/config/use/ipcalc.h busybox-1.2.0solaris/include/config/use/ipcalc.h
--- busybox-1.2.0/include/config/use/ipcalc.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ipcalc.h	2009-04-17 16:46:43.461986211 +0400
@@ -0,0 +1 @@
+#define USE_IPCALC(...)
diff -rupN busybox-1.2.0/include/config/use/ipcrm.h busybox-1.2.0solaris/include/config/use/ipcrm.h
--- busybox-1.2.0/include/config/use/ipcrm.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ipcrm.h	2009-04-17 16:46:43.527000385 +0400
@@ -0,0 +1 @@
+#define USE_IPCRM(...)
diff -rupN busybox-1.2.0/include/config/use/ipcs.h busybox-1.2.0solaris/include/config/use/ipcs.h
--- busybox-1.2.0/include/config/use/ipcs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ipcs.h	2009-04-17 16:46:43.526732872 +0400
@@ -0,0 +1 @@
+#define USE_IPCS(...)
diff -rupN busybox-1.2.0/include/config/use/iplink.h busybox-1.2.0solaris/include/config/use/iplink.h
--- busybox-1.2.0/include/config/use/iplink.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/iplink.h	2009-04-17 16:46:43.462815125 +0400
@@ -0,0 +1 @@
+#define USE_IPLINK(...)
diff -rupN busybox-1.2.0/include/config/use/iproute.h busybox-1.2.0solaris/include/config/use/iproute.h
--- busybox-1.2.0/include/config/use/iproute.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/iproute.h	2009-04-17 16:46:43.462536793 +0400
@@ -0,0 +1 @@
+#define USE_IPROUTE(...)
diff -rupN busybox-1.2.0/include/config/use/iptunnel.h busybox-1.2.0solaris/include/config/use/iptunnel.h
--- busybox-1.2.0/include/config/use/iptunnel.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/iptunnel.h	2009-04-17 16:46:43.462263836 +0400
@@ -0,0 +1 @@
+#define USE_IPTUNNEL(...)
diff -rupN busybox-1.2.0/include/config/use/kill.h busybox-1.2.0solaris/include/config/use/kill.h
--- busybox-1.2.0/include/config/use/kill.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/kill.h	2009-04-20 13:50:40.286741432 +0400
@@ -0,0 +1 @@
+#define USE_KILL(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/killall.h busybox-1.2.0solaris/include/config/use/killall.h
--- busybox-1.2.0/include/config/use/killall.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/killall.h	2009-04-17 16:46:43.441207440 +0400
@@ -0,0 +1 @@
+#define USE_KILLALL(...)
diff -rupN busybox-1.2.0/include/config/use/klogd.h busybox-1.2.0solaris/include/config/use/klogd.h
--- busybox-1.2.0/include/config/use/klogd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/klogd.h	2009-04-17 16:46:43.415055924 +0400
@@ -0,0 +1 @@
+#define USE_KLOGD(...)
diff -rupN busybox-1.2.0/include/config/use/lash.h busybox-1.2.0solaris/include/config/use/lash.h
--- busybox-1.2.0/include/config/use/lash.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/lash.h	2009-04-18 09:30:26.865219735 +0400
@@ -0,0 +1 @@
+#define USE_LASH(...)
diff -rupN busybox-1.2.0/include/config/use/last.h busybox-1.2.0solaris/include/config/use/last.h
--- busybox-1.2.0/include/config/use/last.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/last.h	2009-04-17 16:46:43.509882251 +0400
@@ -0,0 +1 @@
+#define USE_LAST(...)
diff -rupN busybox-1.2.0/include/config/use/length.h busybox-1.2.0solaris/include/config/use/length.h
--- busybox-1.2.0/include/config/use/length.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/length.h	2009-04-17 16:46:43.787137669 +0400
@@ -0,0 +1 @@
+#define USE_LENGTH(...)
diff -rupN busybox-1.2.0/include/config/use/less.h busybox-1.2.0solaris/include/config/use/less.h
--- busybox-1.2.0/include/config/use/less.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/less.h	2009-04-17 16:46:43.509564915 +0400
@@ -0,0 +1 @@
+#define USE_LESS(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/ln.h busybox-1.2.0solaris/include/config/use/ln.h
--- busybox-1.2.0/include/config/use/ln.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ln.h	2009-04-17 16:46:43.786871408 +0400
@@ -0,0 +1 @@
+#define USE_LN(...)
diff -rupN busybox-1.2.0/include/config/use/loadfont.h busybox-1.2.0solaris/include/config/use/loadfont.h
--- busybox-1.2.0/include/config/use/loadfont.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/loadfont.h	2009-04-17 16:46:43.751761108 +0400
@@ -0,0 +1 @@
+#define USE_LOADFONT(...)
diff -rupN busybox-1.2.0/include/config/use/loadkmap.h busybox-1.2.0solaris/include/config/use/loadkmap.h
--- busybox-1.2.0/include/config/use/loadkmap.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/loadkmap.h	2009-04-17 16:46:43.751488224 +0400
@@ -0,0 +1 @@
+#define USE_LOADKMAP(...)
diff -rupN busybox-1.2.0/include/config/use/logger.h busybox-1.2.0solaris/include/config/use/logger.h
--- busybox-1.2.0/include/config/use/logger.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/logger.h	2009-04-17 16:46:43.414793497 +0400
@@ -0,0 +1 @@
+#define USE_LOGGER(...)
diff -rupN busybox-1.2.0/include/config/use/login.h busybox-1.2.0solaris/include/config/use/login.h
--- busybox-1.2.0/include/config/use/login.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/login.h	2009-04-17 16:46:43.713384562 +0400
@@ -0,0 +1 @@
+#define USE_LOGIN(...)
diff -rupN busybox-1.2.0/include/config/use/logname.h busybox-1.2.0solaris/include/config/use/logname.h
--- busybox-1.2.0/include/config/use/logname.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/logname.h	2009-04-17 16:46:43.786585613 +0400
@@ -0,0 +1 @@
+#define USE_LOGNAME(...)
diff -rupN busybox-1.2.0/include/config/use/logread.h busybox-1.2.0solaris/include/config/use/logread.h
--- busybox-1.2.0/include/config/use/logread.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/logread.h	2009-04-17 16:46:43.416126915 +0400
@@ -0,0 +1 @@
+#define USE_LOGREAD(...)
diff -rupN busybox-1.2.0/include/config/use/losetup.h busybox-1.2.0solaris/include/config/use/losetup.h
--- busybox-1.2.0/include/config/use/losetup.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/losetup.h	2009-04-17 16:46:43.526444145 +0400
@@ -0,0 +1 @@
+#define USE_LOSETUP(...)
diff -rupN busybox-1.2.0/include/config/use/ls.h busybox-1.2.0solaris/include/config/use/ls.h
--- busybox-1.2.0/include/config/use/ls.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ls.h	2009-04-17 16:46:43.786310980 +0400
@@ -0,0 +1 @@
+#define USE_LS(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/lsattr.h busybox-1.2.0solaris/include/config/use/lsattr.h
--- busybox-1.2.0/include/config/use/lsattr.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/lsattr.h	2009-04-17 16:46:43.710624317 +0400
@@ -0,0 +1 @@
+#define USE_LSATTR(...)
diff -rupN busybox-1.2.0/include/config/use/lsmod.h busybox-1.2.0solaris/include/config/use/lsmod.h
--- busybox-1.2.0/include/config/use/lsmod.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/lsmod.h	2009-04-17 16:46:43.704706671 +0400
@@ -0,0 +1 @@
+#define USE_LSMOD(...)
diff -rupN busybox-1.2.0/include/config/use/makedevs.h busybox-1.2.0solaris/include/config/use/makedevs.h
--- busybox-1.2.0/include/config/use/makedevs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/makedevs.h	2009-04-17 16:46:43.498098963 +0400
@@ -0,0 +1 @@
+#define USE_MAKEDEVS(...)
diff -rupN busybox-1.2.0/include/config/use/md5sum.h busybox-1.2.0solaris/include/config/use/md5sum.h
--- busybox-1.2.0/include/config/use/md5sum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/md5sum.h	2009-04-17 16:46:43.780450627 +0400
@@ -0,0 +1 @@
+#define USE_MD5SUM(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/mdev.h busybox-1.2.0solaris/include/config/use/mdev.h
--- busybox-1.2.0/include/config/use/mdev.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mdev.h	2009-04-17 16:46:43.526128072 +0400
@@ -0,0 +1 @@
+#define USE_MDEV(...)
diff -rupN busybox-1.2.0/include/config/use/mesg.h busybox-1.2.0solaris/include/config/use/mesg.h
--- busybox-1.2.0/include/config/use/mesg.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mesg.h	2009-04-17 16:46:43.718155029 +0400
@@ -0,0 +1 @@
+#define USE_MESG(...)
diff -rupN busybox-1.2.0/include/config/use/mkdir.h busybox-1.2.0solaris/include/config/use/mkdir.h
--- busybox-1.2.0/include/config/use/mkdir.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mkdir.h	2009-04-17 16:46:43.780096659 +0400
@@ -0,0 +1 @@
+#define USE_MKDIR(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/mke2fs.h busybox-1.2.0solaris/include/config/use/mke2fs.h
--- busybox-1.2.0/include/config/use/mke2fs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mke2fs.h	2009-04-17 16:46:43.710341815 +0400
@@ -0,0 +1 @@
+#define USE_MKE2FS(...)
diff -rupN busybox-1.2.0/include/config/use/mkfifo.h busybox-1.2.0solaris/include/config/use/mkfifo.h
--- busybox-1.2.0/include/config/use/mkfifo.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mkfifo.h	2009-04-17 16:46:43.778914942 +0400
@@ -0,0 +1 @@
+#define USE_MKFIFO(...)
diff -rupN busybox-1.2.0/include/config/use/mkfs/minix.h busybox-1.2.0solaris/include/config/use/mkfs/minix.h
--- busybox-1.2.0/include/config/use/mkfs/minix.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mkfs/minix.h	2009-04-17 16:46:43.530118455 +0400
@@ -0,0 +1 @@
+#define USE_MKFS_MINIX(...)
diff -rupN busybox-1.2.0/include/config/use/mknod.h busybox-1.2.0solaris/include/config/use/mknod.h
--- busybox-1.2.0/include/config/use/mknod.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mknod.h	2009-04-17 16:46:43.778620384 +0400
@@ -0,0 +1 @@
+#define USE_MKNOD(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/mkswap.h busybox-1.2.0solaris/include/config/use/mkswap.h
--- busybox-1.2.0/include/config/use/mkswap.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mkswap.h	2009-04-17 16:46:43.524379727 +0400
@@ -0,0 +1 @@
+#define USE_MKSWAP(...)
diff -rupN busybox-1.2.0/include/config/use/mktemp.h busybox-1.2.0solaris/include/config/use/mktemp.h
--- busybox-1.2.0/include/config/use/mktemp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mktemp.h	2009-04-17 16:46:43.748844491 +0400
@@ -0,0 +1 @@
+#define USE_MKTEMP(...)
diff -rupN busybox-1.2.0/include/config/use/modprobe.h busybox-1.2.0solaris/include/config/use/modprobe.h
--- busybox-1.2.0/include/config/use/modprobe.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/modprobe.h	2009-04-17 16:46:43.703730244 +0400
@@ -0,0 +1 @@
+#define USE_MODPROBE(...)
diff -rupN busybox-1.2.0/include/config/use/more.h busybox-1.2.0solaris/include/config/use/more.h
--- busybox-1.2.0/include/config/use/more.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/more.h	2009-04-17 16:46:43.523634182 +0400
@@ -0,0 +1 @@
+#define USE_MORE(...)
diff -rupN busybox-1.2.0/include/config/use/mount.h busybox-1.2.0solaris/include/config/use/mount.h
--- busybox-1.2.0/include/config/use/mount.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mount.h	2009-04-20 11:22:32.726679306 +0400
@@ -0,0 +1 @@
+#define USE_MOUNT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/mountpoint.h busybox-1.2.0solaris/include/config/use/mountpoint.h
--- busybox-1.2.0/include/config/use/mountpoint.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mountpoint.h	2009-04-17 16:46:43.496943411 +0400
@@ -0,0 +1 @@
+#define USE_MOUNTPOINT(...)
diff -rupN busybox-1.2.0/include/config/use/msh.h busybox-1.2.0solaris/include/config/use/msh.h
--- busybox-1.2.0/include/config/use/msh.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/msh.h	2009-04-18 09:31:38.988335464 +0400
@@ -0,0 +1 @@
+#define USE_MSH(...)
diff -rupN busybox-1.2.0/include/config/use/mt.h busybox-1.2.0solaris/include/config/use/mt.h
--- busybox-1.2.0/include/config/use/mt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mt.h	2009-04-17 16:46:43.496668128 +0400
@@ -0,0 +1 @@
+#define USE_MT(...)
diff -rupN busybox-1.2.0/include/config/use/mv.h busybox-1.2.0solaris/include/config/use/mv.h
--- busybox-1.2.0/include/config/use/mv.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/mv.h	2009-04-17 16:46:43.778305055 +0400
@@ -0,0 +1 @@
+#define USE_MV(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/nameif.h busybox-1.2.0solaris/include/config/use/nameif.h
--- busybox-1.2.0/include/config/use/nameif.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/nameif.h	2009-04-17 16:46:43.459156338 +0400
@@ -0,0 +1 @@
+#define USE_NAMEIF(...)
diff -rupN busybox-1.2.0/include/config/use/nc.h busybox-1.2.0solaris/include/config/use/nc.h
--- busybox-1.2.0/include/config/use/nc.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/nc.h	2009-04-18 10:15:46.143737425 +0400
@@ -0,0 +1 @@
+#define USE_NC(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/netstat.h busybox-1.2.0solaris/include/config/use/netstat.h
--- busybox-1.2.0/include/config/use/netstat.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/netstat.h	2009-04-18 10:38:16.646045668 +0400
@@ -0,0 +1 @@
+#define USE_NETSTAT(...)
diff -rupN busybox-1.2.0/include/config/use/nice.h busybox-1.2.0solaris/include/config/use/nice.h
--- busybox-1.2.0/include/config/use/nice.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/nice.h	2009-04-17 16:46:43.777282512 +0400
@@ -0,0 +1 @@
+#define USE_NICE(...)
diff -rupN busybox-1.2.0/include/config/use/nohup.h busybox-1.2.0solaris/include/config/use/nohup.h
--- busybox-1.2.0/include/config/use/nohup.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/nohup.h	2009-04-17 16:46:43.774455120 +0400
@@ -0,0 +1 @@
+#define USE_NOHUP(...)
diff -rupN busybox-1.2.0/include/config/use/nslookup.h busybox-1.2.0solaris/include/config/use/nslookup.h
--- busybox-1.2.0/include/config/use/nslookup.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/nslookup.h	2009-04-18 10:38:16.645841584 +0400
@@ -0,0 +1 @@
+#define USE_NSLOOKUP(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/od.h busybox-1.2.0solaris/include/config/use/od.h
--- busybox-1.2.0/include/config/use/od.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/od.h	2009-04-17 16:46:43.774134524 +0400
@@ -0,0 +1 @@
+#define USE_OD(...)
diff -rupN busybox-1.2.0/include/config/use/openvt.h busybox-1.2.0solaris/include/config/use/openvt.h
--- busybox-1.2.0/include/config/use/openvt.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/openvt.h	2009-04-17 16:46:43.751185489 +0400
@@ -0,0 +1 @@
+#define USE_OPENVT(...)
diff -rupN busybox-1.2.0/include/config/use/passwd.h busybox-1.2.0solaris/include/config/use/passwd.h
--- busybox-1.2.0/include/config/use/passwd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/passwd.h	2009-04-17 16:46:43.712771389 +0400
@@ -0,0 +1 @@
+#define USE_PASSWD(...)
diff -rupN busybox-1.2.0/include/config/use/patch.h busybox-1.2.0solaris/include/config/use/patch.h
--- busybox-1.2.0/include/config/use/patch.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/patch.h	2009-04-17 16:46:43.740851044 +0400
@@ -0,0 +1 @@
+#define USE_PATCH(...)
diff -rupN busybox-1.2.0/include/config/use/pidof.h busybox-1.2.0solaris/include/config/use/pidof.h
--- busybox-1.2.0/include/config/use/pidof.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/pidof.h	2009-04-17 16:46:43.440915806 +0400
@@ -0,0 +1 @@
+#define USE_PIDOF(...)
diff -rupN busybox-1.2.0/include/config/use/ping.h busybox-1.2.0solaris/include/config/use/ping.h
--- busybox-1.2.0/include/config/use/ping.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ping.h	2009-04-18 10:44:12.878983001 +0400
@@ -0,0 +1 @@
+#define USE_PING(...)
diff -rupN busybox-1.2.0/include/config/use/ping6.h busybox-1.2.0solaris/include/config/use/ping6.h
--- busybox-1.2.0/include/config/use/ping6.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ping6.h	2009-04-17 16:46:43.456393044 +0400
@@ -0,0 +1 @@
+#define USE_PING6(...)
diff -rupN busybox-1.2.0/include/config/use/pipe/progress.h busybox-1.2.0solaris/include/config/use/pipe/progress.h
--- busybox-1.2.0/include/config/use/pipe/progress.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/pipe/progress.h	2009-04-17 16:46:43.748562519 +0400
@@ -0,0 +1 @@
+#define USE_PIPE_PROGRESS(...)
diff -rupN busybox-1.2.0/include/config/use/pivot/root.h busybox-1.2.0solaris/include/config/use/pivot/root.h
--- busybox-1.2.0/include/config/use/pivot/root.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/pivot/root.h	2009-04-17 16:46:43.522195865 +0400
@@ -0,0 +1 @@
+#define USE_PIVOT_ROOT(...)
diff -rupN busybox-1.2.0/include/config/use/printenv.h busybox-1.2.0solaris/include/config/use/printenv.h
--- busybox-1.2.0/include/config/use/printenv.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/printenv.h	2009-04-17 16:46:43.773867763 +0400
@@ -0,0 +1 @@
+#define USE_PRINTENV(...)
diff -rupN busybox-1.2.0/include/config/use/printf.h busybox-1.2.0solaris/include/config/use/printf.h
--- busybox-1.2.0/include/config/use/printf.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/printf.h	2009-04-17 16:46:43.773606529 +0400
@@ -0,0 +1 @@
+#define USE_PRINTF(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/ps.h busybox-1.2.0solaris/include/config/use/ps.h
--- busybox-1.2.0/include/config/use/ps.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/ps.h	2009-04-20 14:06:34.516306963 +0400
@@ -0,0 +1 @@
+#define USE_PS(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/pwd.h busybox-1.2.0solaris/include/config/use/pwd.h
--- busybox-1.2.0/include/config/use/pwd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/pwd.h	2009-04-17 16:46:43.773301252 +0400
@@ -0,0 +1 @@
+#define USE_PWD(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/rdate.h busybox-1.2.0solaris/include/config/use/rdate.h
--- busybox-1.2.0/include/config/use/rdate.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/rdate.h	2009-04-17 16:46:43.521756209 +0400
@@ -0,0 +1 @@
+#define USE_RDATE(...)
diff -rupN busybox-1.2.0/include/config/use/readlink.h busybox-1.2.0solaris/include/config/use/readlink.h
--- busybox-1.2.0/include/config/use/readlink.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/readlink.h	2009-04-17 16:46:43.748082174 +0400
@@ -0,0 +1 @@
+#define USE_READLINK(...)
diff -rupN busybox-1.2.0/include/config/use/readprofile.h busybox-1.2.0solaris/include/config/use/readprofile.h
--- busybox-1.2.0/include/config/use/readprofile.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/readprofile.h	2009-04-17 16:46:43.521489639 +0400
@@ -0,0 +1 @@
+#define USE_READPROFILE(...)
diff -rupN busybox-1.2.0/include/config/use/realpath.h busybox-1.2.0solaris/include/config/use/realpath.h
--- busybox-1.2.0/include/config/use/realpath.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/realpath.h	2009-04-17 16:46:43.772977754 +0400
@@ -0,0 +1 @@
+#define USE_REALPATH(...)
diff -rupN busybox-1.2.0/include/config/use/renice.h busybox-1.2.0solaris/include/config/use/renice.h
--- busybox-1.2.0/include/config/use/renice.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/renice.h	2009-04-17 16:46:43.438622169 +0400
@@ -0,0 +1 @@
+#define USE_RENICE(...)
diff -rupN busybox-1.2.0/include/config/use/reset.h busybox-1.2.0solaris/include/config/use/reset.h
--- busybox-1.2.0/include/config/use/reset.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/reset.h	2009-04-17 16:46:43.750874559 +0400
@@ -0,0 +1 @@
+#define USE_RESET(...)
diff -rupN busybox-1.2.0/include/config/use/rm.h busybox-1.2.0solaris/include/config/use/rm.h
--- busybox-1.2.0/include/config/use/rm.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/rm.h	2009-04-17 16:46:43.772684832 +0400
@@ -0,0 +1 @@
+#define USE_RM(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/rmdir.h busybox-1.2.0solaris/include/config/use/rmdir.h
--- busybox-1.2.0/include/config/use/rmdir.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/rmdir.h	2009-04-17 16:46:43.772414545 +0400
@@ -0,0 +1 @@
+#define USE_RMDIR(...)
diff -rupN busybox-1.2.0/include/config/use/rmmod.h busybox-1.2.0solaris/include/config/use/rmmod.h
--- busybox-1.2.0/include/config/use/rmmod.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/rmmod.h	2009-04-17 16:46:43.704980203 +0400
@@ -0,0 +1 @@
+#define USE_RMMOD(...)
diff -rupN busybox-1.2.0/include/config/use/route.h busybox-1.2.0solaris/include/config/use/route.h
--- busybox-1.2.0/include/config/use/route.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/route.h	2009-04-18 11:38:16.989065554 +0400
@@ -0,0 +1 @@
+#define USE_ROUTE(...)
diff -rupN busybox-1.2.0/include/config/use/rpm.h busybox-1.2.0solaris/include/config/use/rpm.h
--- busybox-1.2.0/include/config/use/rpm.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/rpm.h	2009-04-17 16:46:43.818623177 +0400
@@ -0,0 +1 @@
+#define USE_RPM(...)
diff -rupN busybox-1.2.0/include/config/use/rpm2cpio.h busybox-1.2.0solaris/include/config/use/rpm2cpio.h
--- busybox-1.2.0/include/config/use/rpm2cpio.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/rpm2cpio.h	2009-04-17 16:46:43.818929205 +0400
@@ -0,0 +1 @@
+#define USE_RPM2CPIO(...)
diff -rupN busybox-1.2.0/include/config/use/run/parts.h busybox-1.2.0solaris/include/config/use/run/parts.h
--- busybox-1.2.0/include/config/use/run/parts.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/run/parts.h	2009-04-17 16:46:43.746680603 +0400
@@ -0,0 +1 @@
+#define USE_RUN_PARTS(...)
diff -rupN busybox-1.2.0/include/config/use/runlevel.h busybox-1.2.0solaris/include/config/use/runlevel.h
--- busybox-1.2.0/include/config/use/runlevel.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/runlevel.h	2009-04-17 16:46:43.496398130 +0400
@@ -0,0 +1 @@
+#define USE_RUNLEVEL(...)
diff -rupN busybox-1.2.0/include/config/use/rx.h busybox-1.2.0solaris/include/config/use/rx.h
--- busybox-1.2.0/include/config/use/rx.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/rx.h	2009-04-17 16:46:43.496123689 +0400
@@ -0,0 +1 @@
+#define USE_RX(...)
diff -rupN busybox-1.2.0/include/config/use/sed.h busybox-1.2.0solaris/include/config/use/sed.h
--- busybox-1.2.0/include/config/use/sed.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/sed.h	2009-04-17 16:46:43.740570782 +0400
@@ -0,0 +1 @@
+#define USE_SED(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/seq.h busybox-1.2.0solaris/include/config/use/seq.h
--- busybox-1.2.0/include/config/use/seq.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/seq.h	2009-04-17 16:46:43.772140769 +0400
@@ -0,0 +1 @@
+#define USE_SEQ(...)
diff -rupN busybox-1.2.0/include/config/use/setarch.h busybox-1.2.0solaris/include/config/use/setarch.h
--- busybox-1.2.0/include/config/use/setarch.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/setarch.h	2009-04-17 16:46:43.521217472 +0400
@@ -0,0 +1 @@
+#define USE_SETARCH(...)
diff -rupN busybox-1.2.0/include/config/use/setconsole.h busybox-1.2.0solaris/include/config/use/setconsole.h
--- busybox-1.2.0/include/config/use/setconsole.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/setconsole.h	2009-04-17 16:46:43.750602358 +0400
@@ -0,0 +1 @@
+#define USE_SETCONSOLE(...)
diff -rupN busybox-1.2.0/include/config/use/setkeycodes.h busybox-1.2.0solaris/include/config/use/setkeycodes.h
--- busybox-1.2.0/include/config/use/setkeycodes.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/setkeycodes.h	2009-04-17 16:46:43.749556927 +0400
@@ -0,0 +1 @@
+#define USE_SETKEYCODES(...)
diff -rupN busybox-1.2.0/include/config/use/setlogcons.h busybox-1.2.0solaris/include/config/use/setlogcons.h
--- busybox-1.2.0/include/config/use/setlogcons.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/setlogcons.h	2009-04-17 16:46:43.749254921 +0400
@@ -0,0 +1 @@
+#define USE_SETLOGCONS(...)
diff -rupN busybox-1.2.0/include/config/use/setsid.h busybox-1.2.0solaris/include/config/use/setsid.h
--- busybox-1.2.0/include/config/use/setsid.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/setsid.h	2009-04-17 16:46:43.495496200 +0400
@@ -0,0 +1 @@
+#define USE_SETSID(...)
diff -rupN busybox-1.2.0/include/config/use/sha1sum.h busybox-1.2.0solaris/include/config/use/sha1sum.h
--- busybox-1.2.0/include/config/use/sha1sum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/sha1sum.h	2009-04-17 16:46:43.771281241 +0400
@@ -0,0 +1 @@
+#define USE_SHA1SUM(...)
diff -rupN busybox-1.2.0/include/config/use/sleep.h busybox-1.2.0solaris/include/config/use/sleep.h
--- busybox-1.2.0/include/config/use/sleep.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/sleep.h	2009-04-17 16:46:43.770985070 +0400
@@ -0,0 +1 @@
+#define USE_SLEEP(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/sort.h busybox-1.2.0solaris/include/config/use/sort.h
--- busybox-1.2.0/include/config/use/sort.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/sort.h	2009-04-17 16:46:43.770296972 +0400
@@ -0,0 +1 @@
+#define USE_SORT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/start/stop/daemon.h busybox-1.2.0solaris/include/config/use/start/stop/daemon.h
--- busybox-1.2.0/include/config/use/start/stop/daemon.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/start/stop/daemon.h	2009-04-17 16:46:43.746206743 +0400
@@ -0,0 +1 @@
+#define USE_START_STOP_DAEMON(...)
diff -rupN busybox-1.2.0/include/config/use/stat.h busybox-1.2.0solaris/include/config/use/stat.h
--- busybox-1.2.0/include/config/use/stat.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/stat.h	2009-04-17 16:46:43.768914171 +0400
@@ -0,0 +1 @@
+#define USE_STAT(...)
diff -rupN busybox-1.2.0/include/config/use/strings.h busybox-1.2.0solaris/include/config/use/strings.h
--- busybox-1.2.0/include/config/use/strings.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/strings.h	2009-04-17 16:46:43.495828176 +0400
@@ -0,0 +1 @@
+#define USE_STRINGS(...)
diff -rupN busybox-1.2.0/include/config/use/stty.h busybox-1.2.0solaris/include/config/use/stty.h
--- busybox-1.2.0/include/config/use/stty.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/stty.h	2009-04-17 16:46:43.767513272 +0400
@@ -0,0 +1 @@
+#define USE_STTY(...)
diff -rupN busybox-1.2.0/include/config/use/su.h busybox-1.2.0solaris/include/config/use/su.h
--- busybox-1.2.0/include/config/use/su.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/su.h	2009-04-17 16:46:43.712454568 +0400
@@ -0,0 +1 @@
+#define USE_SU(...)
diff -rupN busybox-1.2.0/include/config/use/sulogin.h busybox-1.2.0solaris/include/config/use/sulogin.h
--- busybox-1.2.0/include/config/use/sulogin.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/sulogin.h	2009-04-17 16:46:43.712089874 +0400
@@ -0,0 +1 @@
+#define USE_SULOGIN(...)
diff -rupN busybox-1.2.0/include/config/use/sum.h busybox-1.2.0solaris/include/config/use/sum.h
--- busybox-1.2.0/include/config/use/sum.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/sum.h	2009-04-17 16:46:43.767199350 +0400
@@ -0,0 +1 @@
+#define USE_SUM(...)
diff -rupN busybox-1.2.0/include/config/use/swaponoff.h busybox-1.2.0solaris/include/config/use/swaponoff.h
--- busybox-1.2.0/include/config/use/swaponoff.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/swaponoff.h	2009-04-17 16:46:43.520626902 +0400
@@ -0,0 +1 @@
+#define USE_SWAPONOFF(...)
diff -rupN busybox-1.2.0/include/config/use/switch/root.h busybox-1.2.0solaris/include/config/use/switch/root.h
--- busybox-1.2.0/include/config/use/switch/root.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/switch/root.h	2009-04-17 16:46:43.520103560 +0400
@@ -0,0 +1 @@
+#define USE_SWITCH_ROOT(...)
diff -rupN busybox-1.2.0/include/config/use/sync.h busybox-1.2.0solaris/include/config/use/sync.h
--- busybox-1.2.0/include/config/use/sync.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/sync.h	2009-04-17 16:46:43.766922032 +0400
@@ -0,0 +1 @@
+#define USE_SYNC(...)
diff -rupN busybox-1.2.0/include/config/use/syslogd.h busybox-1.2.0solaris/include/config/use/syslogd.h
--- busybox-1.2.0/include/config/use/syslogd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/syslogd.h	2009-04-17 16:46:43.418357923 +0400
@@ -0,0 +1 @@
+#define USE_SYSLOGD(...)
diff -rupN busybox-1.2.0/include/config/use/tail.h busybox-1.2.0solaris/include/config/use/tail.h
--- busybox-1.2.0/include/config/use/tail.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/tail.h	2009-04-17 16:46:43.766643550 +0400
@@ -0,0 +1 @@
+#define USE_TAIL(...)
diff -rupN busybox-1.2.0/include/config/use/tar.h busybox-1.2.0solaris/include/config/use/tar.h
--- busybox-1.2.0/include/config/use/tar.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/tar.h	2009-04-17 16:46:43.817896955 +0400
@@ -0,0 +1 @@
+#define USE_TAR(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/tee.h busybox-1.2.0solaris/include/config/use/tee.h
--- busybox-1.2.0/include/config/use/tee.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/tee.h	2009-04-17 16:46:43.765502772 +0400
@@ -0,0 +1 @@
+#define USE_TEE(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/telnet.h busybox-1.2.0solaris/include/config/use/telnet.h
--- busybox-1.2.0/include/config/use/telnet.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/telnet.h	2009-04-18 12:36:39.575719265 +0400
@@ -0,0 +1 @@
+#define USE_TELNET(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/telnetd.h busybox-1.2.0solaris/include/config/use/telnetd.h
--- busybox-1.2.0/include/config/use/telnetd.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/telnetd.h	2009-04-17 16:46:43.453901890 +0400
@@ -0,0 +1 @@
+#define USE_TELNETD(...)
diff -rupN busybox-1.2.0/include/config/use/test.h busybox-1.2.0solaris/include/config/use/test.h
--- busybox-1.2.0/include/config/use/test.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/test.h	2009-04-17 16:46:43.764257672 +0400
@@ -0,0 +1 @@
+#define USE_TEST(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/tftp.h busybox-1.2.0solaris/include/config/use/tftp.h
--- busybox-1.2.0/include/config/use/tftp.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/tftp.h	2009-04-17 16:46:43.453162387 +0400
@@ -0,0 +1 @@
+#define USE_TFTP(...)
diff -rupN busybox-1.2.0/include/config/use/time.h busybox-1.2.0solaris/include/config/use/time.h
--- busybox-1.2.0/include/config/use/time.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/time.h	2009-04-17 16:46:43.492374472 +0400
@@ -0,0 +1 @@
+#define USE_TIME(...)
diff -rupN busybox-1.2.0/include/config/use/top.h busybox-1.2.0solaris/include/config/use/top.h
--- busybox-1.2.0/include/config/use/top.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/top.h	2009-04-18 10:50:05.910743985 +0400
@@ -0,0 +1 @@
+#define USE_TOP(...)
diff -rupN busybox-1.2.0/include/config/use/touch.h busybox-1.2.0solaris/include/config/use/touch.h
--- busybox-1.2.0/include/config/use/touch.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/touch.h	2009-04-17 16:46:43.763605773 +0400
@@ -0,0 +1 @@
+#define USE_TOUCH(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/tr.h busybox-1.2.0solaris/include/config/use/tr.h
--- busybox-1.2.0/include/config/use/tr.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/tr.h	2009-04-17 16:46:43.763300666 +0400
@@ -0,0 +1 @@
+#define USE_TR(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/traceroute.h busybox-1.2.0solaris/include/config/use/traceroute.h
--- busybox-1.2.0/include/config/use/traceroute.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/traceroute.h	2009-04-17 16:46:43.448942528 +0400
@@ -0,0 +1 @@
+#define USE_TRACEROUTE(...)
diff -rupN busybox-1.2.0/include/config/use/true.h busybox-1.2.0solaris/include/config/use/true.h
--- busybox-1.2.0/include/config/use/true.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/true.h	2009-04-17 16:46:43.762188442 +0400
@@ -0,0 +1 @@
+#define USE_TRUE(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/tty.h busybox-1.2.0solaris/include/config/use/tty.h
--- busybox-1.2.0/include/config/use/tty.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/tty.h	2009-04-17 16:46:43.761915192 +0400
@@ -0,0 +1 @@
+#define USE_TTY(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/tune2fs.h busybox-1.2.0solaris/include/config/use/tune2fs.h
--- busybox-1.2.0/include/config/use/tune2fs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/tune2fs.h	2009-04-17 16:46:43.709965291 +0400
@@ -0,0 +1 @@
+#define USE_TUNE2FS(...)
diff -rupN busybox-1.2.0/include/config/use/umount.h busybox-1.2.0solaris/include/config/use/umount.h
--- busybox-1.2.0/include/config/use/umount.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/umount.h	2009-04-20 11:29:03.843762122 +0400
@@ -0,0 +1 @@
+#define USE_UMOUNT(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/uname.h busybox-1.2.0solaris/include/config/use/uname.h
--- busybox-1.2.0/include/config/use/uname.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/uname.h	2009-04-17 16:46:43.761612773 +0400
@@ -0,0 +1 @@
+#define USE_UNAME(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/uncompress.h busybox-1.2.0solaris/include/config/use/uncompress.h
--- busybox-1.2.0/include/config/use/uncompress.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/uncompress.h	2009-04-17 16:46:43.810569191 +0400
@@ -0,0 +1 @@
+#define USE_UNCOMPRESS(...)
diff -rupN busybox-1.2.0/include/config/use/uniq.h busybox-1.2.0solaris/include/config/use/uniq.h
--- busybox-1.2.0/include/config/use/uniq.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/uniq.h	2009-04-17 16:46:43.761212470 +0400
@@ -0,0 +1 @@
+#define USE_UNIQ(...)
diff -rupN busybox-1.2.0/include/config/use/unix2dos.h busybox-1.2.0solaris/include/config/use/unix2dos.h
--- busybox-1.2.0/include/config/use/unix2dos.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/unix2dos.h	2009-04-17 16:46:43.796364600 +0400
@@ -0,0 +1 @@
+#define USE_UNIX2DOS(...)
diff -rupN busybox-1.2.0/include/config/use/unlzma.h busybox-1.2.0solaris/include/config/use/unlzma.h
--- busybox-1.2.0/include/config/use/unlzma.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/unlzma.h	2009-04-17 16:46:43.809838450 +0400
@@ -0,0 +1 @@
+#define USE_UNLZMA(...)
diff -rupN busybox-1.2.0/include/config/use/unzip.h busybox-1.2.0solaris/include/config/use/unzip.h
--- busybox-1.2.0/include/config/use/unzip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/unzip.h	2009-04-17 16:46:43.809061769 +0400
@@ -0,0 +1 @@
+#define USE_UNZIP(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/uptime.h busybox-1.2.0solaris/include/config/use/uptime.h
--- busybox-1.2.0/include/config/use/uptime.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/uptime.h	2009-04-18 10:51:51.040345022 +0400
@@ -0,0 +1 @@
+#define USE_UPTIME(...)
diff -rupN busybox-1.2.0/include/config/use/usleep.h busybox-1.2.0solaris/include/config/use/usleep.h
--- busybox-1.2.0/include/config/use/usleep.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/usleep.h	2009-04-17 16:46:43.759843620 +0400
@@ -0,0 +1 @@
+#define USE_USLEEP(...)
diff -rupN busybox-1.2.0/include/config/use/uudecode.h busybox-1.2.0solaris/include/config/use/uudecode.h
--- busybox-1.2.0/include/config/use/uudecode.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/uudecode.h	2009-04-17 16:46:43.759566224 +0400
@@ -0,0 +1 @@
+#define USE_UUDECODE(...)
diff -rupN busybox-1.2.0/include/config/use/uuencode.h busybox-1.2.0solaris/include/config/use/uuencode.h
--- busybox-1.2.0/include/config/use/uuencode.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/uuencode.h	2009-04-17 16:46:43.759277888 +0400
@@ -0,0 +1 @@
+#define USE_UUENCODE(...)
diff -rupN busybox-1.2.0/include/config/use/vconfig.h busybox-1.2.0solaris/include/config/use/vconfig.h
--- busybox-1.2.0/include/config/use/vconfig.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/vconfig.h	2009-04-17 16:46:43.444455191 +0400
@@ -0,0 +1 @@
+#define USE_VCONFIG(...)
diff -rupN busybox-1.2.0/include/config/use/vi.h busybox-1.2.0solaris/include/config/use/vi.h
--- busybox-1.2.0/include/config/use/vi.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/vi.h	2009-04-17 16:46:43.740296736 +0400
@@ -0,0 +1 @@
+#define USE_VI(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/vlock.h busybox-1.2.0solaris/include/config/use/vlock.h
--- busybox-1.2.0/include/config/use/vlock.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/vlock.h	2009-04-17 16:46:43.711818452 +0400
@@ -0,0 +1 @@
+#define USE_VLOCK(...)
diff -rupN busybox-1.2.0/include/config/use/watch.h busybox-1.2.0solaris/include/config/use/watch.h
--- busybox-1.2.0/include/config/use/watch.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/watch.h	2009-04-17 16:46:43.758961239 +0400
@@ -0,0 +1 @@
+#define USE_WATCH(...)
diff -rupN busybox-1.2.0/include/config/use/watchdog.h busybox-1.2.0solaris/include/config/use/watchdog.h
--- busybox-1.2.0/include/config/use/watchdog.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/watchdog.h	2009-04-17 16:46:43.492074075 +0400
@@ -0,0 +1 @@
+#define USE_WATCHDOG(...)
diff -rupN busybox-1.2.0/include/config/use/wc.h busybox-1.2.0solaris/include/config/use/wc.h
--- busybox-1.2.0/include/config/use/wc.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/wc.h	2009-04-17 16:46:43.758682715 +0400
@@ -0,0 +1 @@
+#define USE_WC(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/wget.h busybox-1.2.0solaris/include/config/use/wget.h
--- busybox-1.2.0/include/config/use/wget.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/wget.h	2009-04-18 17:05:51.190372012 +0400
@@ -0,0 +1 @@
+#define USE_WGET(...)
diff -rupN busybox-1.2.0/include/config/use/which.h busybox-1.2.0solaris/include/config/use/which.h
--- busybox-1.2.0/include/config/use/which.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/which.h	2009-04-17 16:46:43.742332300 +0400
@@ -0,0 +1 @@
+#define USE_WHICH(...)
diff -rupN busybox-1.2.0/include/config/use/who.h busybox-1.2.0solaris/include/config/use/who.h
--- busybox-1.2.0/include/config/use/who.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/who.h	2009-04-17 16:46:43.758400917 +0400
@@ -0,0 +1 @@
+#define USE_WHO(...)
diff -rupN busybox-1.2.0/include/config/use/whoami.h busybox-1.2.0solaris/include/config/use/whoami.h
--- busybox-1.2.0/include/config/use/whoami.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/whoami.h	2009-04-17 16:46:43.758099392 +0400
@@ -0,0 +1 @@
+#define USE_WHOAMI(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/xargs.h busybox-1.2.0solaris/include/config/use/xargs.h
--- busybox-1.2.0/include/config/use/xargs.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/xargs.h	2009-04-17 16:46:43.724555174 +0400
@@ -0,0 +1 @@
+#define USE_XARGS(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/yes.h busybox-1.2.0solaris/include/config/use/yes.h
--- busybox-1.2.0/include/config/use/yes.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/yes.h	2009-04-17 16:46:43.757760139 +0400
@@ -0,0 +1 @@
+#define USE_YES(...)  __VA_ARGS__
diff -rupN busybox-1.2.0/include/config/use/zcip.h busybox-1.2.0solaris/include/config/use/zcip.h
--- busybox-1.2.0/include/config/use/zcip.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/include/config/use/zcip.h	2009-04-17 16:46:43.442555067 +0400
@@ -0,0 +1 @@
+#define USE_ZCIP(...)
diff -rupN busybox-1.2.0/include/libbb.h busybox-1.2.0solaris/include/libbb.h
--- busybox-1.2.0/include/libbb.h	2006-07-01 02:42:10.000000000 +0400
+++ busybox-1.2.0solaris/include/libbb.h	2009-04-18 17:07:36.629527487 +0400
@@ -326,9 +326,9 @@ extern struct hostent *xgethostbyname(co
 extern struct hostent *xgethostbyname2(const char *name, int af);
 extern int create_icmp_socket(void);
 extern int create_icmp6_socket(void);
-extern int xconnect(struct sockaddr_in *s_addr);
+extern int xconnect(struct sockaddr_in s_in, const char *host, const char *port);
 extern unsigned short bb_lookup_port(const char *port, const char *protocol, unsigned short default_port);
-extern void bb_lookup_host(struct sockaddr_in *s_in, const char *host);
+extern void bb_lookup_host(struct sockaddr_in s_in, const char *host);
 
 //#warning wrap this?
 char *dirname (char *path);
diff -rupN busybox-1.2.0/include/platform.h busybox-1.2.0solaris/include/platform.h
--- busybox-1.2.0/include/platform.h	2006-07-01 02:42:10.000000000 +0400
+++ busybox-1.2.0solaris/include/platform.h	2009-04-17 16:30:24.000000000 +0400
@@ -7,6 +7,8 @@
 #ifndef	__PLATFORM_H
 #define __PLATFORM_H	1
 
+#include <sys/byteorder.h>
+
 /* Convenience macros to test the version of gcc. */
 #undef __GNUC_PREREQ
 #if defined __GNUC__ && defined __GNUC_MINOR__
@@ -77,14 +79,14 @@
 
 /* ---- Endian Detection ------------------------------------ */
 
-#if (defined __digital__ && defined __unix__)
-# include <sex.h>
+//#if (defined __digital__ && defined __unix__)
+//# include <sex.h>
 # define __BIG_ENDIAN__ (BYTE_ORDER == BIG_ENDIAN)
 # define __BYTE_ORDER BYTE_ORDER
-#elif !defined __APPLE__
-# include <byteswap.h>
-# include <endian.h>
-#endif
+//#elif !defined __APPLE__
+//# include <byteswap.h>
+//# include <endian.h>
+//#endif
 
 #ifdef __BIG_ENDIAN__
 # define BB_BIG_ENDIAN 1
@@ -120,9 +122,9 @@
 # include <netinet/in.h>
 #endif
 
-#ifndef __socklen_t_defined
-typedef int socklen_t;
-#endif
+//#ifndef __socklen_t_defined
+//typedef int socklen_t;
+//#endif
 
 /* ---- Compiler dependent settings ------------------------- */
 #ifndef __GNUC__
@@ -160,7 +162,7 @@ __extension__ typedef unsigned long long
 #define HAVE_STDINT_H
 #else
 /* Largest integral types.  */
-#if __BIG_ENDIAN__
+/*#if __BIG_ENDIAN__
 typedef long int                intmax_t;
 typedef unsigned long int       uintmax_t;
 #else
@@ -169,6 +171,7 @@ typedef long long int           intmax_t
 __extension__
 typedef unsigned long long int  uintmax_t;
 #endif
+*/
 #endif
 
 /* uclibc does not implement daemon for no-mmu systems.
@@ -185,8 +188,7 @@ typedef unsigned long long int  uintmax_
 /* Platforms that haven't got dprintf need to implement fdprintf() in
  * libbb.  This would require a platform.c.  It's not going to be cleaned
  * out of the tree, so stop saying it should be. */
-#define fdprintf dprintf
-
+#define fdprintf dprintf  
 /* THIS SHOULD BE CLEANED OUT OF THE TREE ENTIRELY */
 /* FIXME: fix tar.c! */
 #ifndef FNM_LEADING_DIR
diff -rupN busybox-1.2.0/include/usage.h busybox-1.2.0solaris/include/usage.h
--- busybox-1.2.0/include/usage.h	2006-07-01 02:42:10.000000000 +0400
+++ busybox-1.2.0solaris/include/usage.h	2009-04-21 09:16:03.758403065 +0400
@@ -432,7 +432,7 @@ USE_FEATURE_DATE_ISOFMT( \
 	"\t\tDo not poll for events.")
 
 #define df_trivial_usage \
-	"[-" USE_FEATURE_HUMAN_READABLE("hm") "k] [FILESYSTEM ...]"
+	"[-F FSType] [flags] [OPTION] [DIRECTORY]"         
 #define df_full_usage \
 	"Print the filesystem space used and space available.\n\n" \
 	"Options:\n" \
@@ -2016,7 +2016,7 @@ USE_FEATURE_MDEV_CONFIG( \
 #  define USAGE_MTAB(a)
 #endif
 #define mount_trivial_usage \
-	"[flags] DEVICE NODE [-o options,more-options]"
+	"[flags] [OPTION] [MOUNT_POINT]"
 #define mount_full_usage \
 	"Mount a filesystem.  Filesystem autodetection requires /proc be mounted.\n\n" \
 	"Flags:\n"  \
@@ -2333,7 +2333,7 @@ USE_FEATURE_MDEV_CONFIG( \
 #endif
 
 #define ps_trivial_usage \
-	""
+	"[flags]"
 #define ps_full_usage \
 	"Report process status\n" \
 	USAGE_PS \
@@ -3200,7 +3200,7 @@ USE_FEATURE_START_STOP_DAEMON_FANCY( \
 #  define USAGE_MOUNT_FORCE(a)
 #endif
 #define umount_trivial_usage \
-	"[flags] FILESYSTEM|DIRECTORY"
+	"[flags] [OPTION] [MOUNT_POINT]"
 #define umount_full_usage \
 	"Unmount file systems\n" \
 	"\nFlags:\n" "\t-a\tUnmount all file systems" \
diff -rupN busybox-1.2.0/init/halt.c busybox-1.2.0solaris/init/halt.c
--- busybox-1.2.0/init/halt.c	2006-07-01 02:42:12.000000000 +0400
+++ busybox-1.2.0solaris/init/halt.c	2009-04-18 09:47:54.025885464 +0400
@@ -42,13 +42,13 @@ RB_AUTOBOOT
 
 	/* Perform action. */
 	if (ENABLE_INIT && !(flags & 4)) {
-		if (ENABLE_FEATURE_INITRD) {
+/*		if (ENABLE_FEATURE_INITRD) {
 			long *pidlist=find_pid_by_name("linuxrc");
 			if (*pidlist>0) rc = kill(*pidlist,signals[which]);
 			if (ENABLE_FEATURE_CLEAN_UP) free(pidlist);
 		}
-		if (rc) rc = kill(1,signals[which]);
-	} else rc = reboot(magic[which]);
+*/		if (rc) rc = kill(1,signals[which]);
+	} else rc = reboot(magic[which],NULL);
 
 	if (rc) bb_error_msg("No.");
 	return rc;
diff -rupN busybox-1.2.0/init/init.c busybox-1.2.0solaris/init/init.c
--- busybox-1.2.0/init/init.c	2006-07-01 02:42:12.000000000 +0400
+++ busybox-1.2.0solaris/init/init.c	2009-04-20 13:24:51.151688547 +0400
@@ -1,1162 +1,4605 @@
-/* vi: set sw=4 ts=4: */
 /*
- * Mini init implementation for busybox
+ * CDDL HEADER START
  *
- * Copyright (C) 1995, 1996 by Bruce Perens <bruce@pixar.com>.
- * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
- * Adjusted by so many folks, it's impossible to keep track.
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
  *
- * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
  */
 
-#include "busybox.h"
-#include <stdio.h>
-#include <stdlib.h>
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
+/*	  All Rights Reserved  	*/
+
+/*
+ * University Copyright- Copyright (c) 1982, 1986, 1988
+ * The Regents of the University of California
+ * All Rights Reserved
+ *
+ * University Acknowledgment- Portions of this document are derived from
+ * software developed by the University of California, Berkeley, and its
+ * contributors.
+ */
+
+/*
+ * init(1M) is the general process spawning program.  Its primary job is to
+ * start and restart svc.startd for smf(5).  For backwards-compatibility it also
+ * spawns and respawns processes according to /etc/inittab and the current
+ * run-level.  It reads /etc/default/inittab for general configuration.
+ *
+ * To change run-levels the system administrator runs init from the command
+ * line with a level name.  init signals svc.startd via libscf and directs the
+ * zone's init (pid 1 in the global zone) what to do by sending it a signal;
+ * these signal numbers are commonly refered to in the code as 'states'.  Valid
+ * run-levels are [sS0123456].  Additionally, init can be given directives
+ * [qQabc], which indicate actions to be taken pertaining to /etc/inittab.
+ *
+ * When init processes inittab entries, it finds processes that are to be
+ * spawned at various run-levels.  inittab contains the set of the levels for
+ * which each inittab entry is valid.
+ *
+ * State File and Restartability
+ *   Premature exit by init(1M) is handled as a special case by the kernel:
+ *   init(1M) will be immediately re-executed, retaining its original PID.  (PID
+ *   1 in the global zone.)  To track the processes it has previously spawned,
+ *   as well as other mutable state, init(1M) regularly updates a state file
+ *   such that its subsequent invocations have knowledge of its various
+ *   dependent processes and duties.
+ *
+ * Process Contracts
+ *   We start svc.startd(1M) in a contract and transfer inherited contracts when
+ *   restarting it.  Everything else is started using the legacy contract
+ *   template, and the created contracts are abandoned when they become empty.
+ *
+ * utmpx Entry Handling
+ *   Because init(1M) no longer governs the startup process, its knowledge of
+ *   when utmpx becomes writable is indirect.  However, spawned processes
+ *   expect to be constructed with valid utmpx entries.  As a result, attempts
+ *   to write normal entries will be retried until successful.
+ *
+ * Maintenance Mode
+ *   In certain failure scenarios, init(1M) will enter a maintenance mode, in
+ *   which it invokes sulogin(1M) to allow the operator an opportunity to
+ *   repair the system.  Normally, this operation is performed as a
+ *   fork(2)-exec(2)-waitpid(3C) sequence with the parent waiting for repair or
+ *   diagnosis to be completed.  In the cases that fork(2) requests themselves
+ *   fail, init(1M) will directly execute sulogin(1M), and allow the kernel to
+ *   restart init(1M) on exit from the operator session.
+ *
+ *   One scenario where init(1M) enters its maintenance mode is when
+ *   svc.startd(1M) begins to fail rapidly, defined as when the average time
+ *   between recent failures drops below a given threshold.
+ */
+
+#include <sys/contract/process.h>
+#include <sys/ctfs.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <sys/stropts.h>
+#include <sys/systeminfo.h>
+#include <sys/time.h>
+#include <sys/termios.h>
+#include <sys/tty.h>
+#include <sys/types.h>
+#include <sys/utsname.h>
+
+#include <bsm/adt_event.h>
+#include <bsm/libbsm.h>
+#include <security/pam_appl.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <dirent.h>
 #include <errno.h>
-#include <paths.h>
+#include <fcntl.h>
+#include <libcontract.h>
+#include "libcontract_priv.h"
+#include <libintl.h>
+#include <libscf.h>
+#include <libscf_priv.h>
+#include <poll.h>
+#include <procfs.h>
 #include <signal.h>
 #include <stdarg.h>
+#include <stdio.h>
+#include <stdio_ext.h>
+#include <stdlib.h>
 #include <string.h>
-#include <termios.h>
+#include <strings.h>
+#include <syslog.h>
+#include <time.h>
+#include <ulimit.h>
 #include <unistd.h>
-#include <limits.h>
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <sys/reboot.h>
+#include <utmpx.h>
+#include <wait.h>
+#include <zone.h>
+#include <ucontext.h>
+
+#undef	sleep
+
+#define	fioctl(p, sptr, cmd)	ioctl(fileno(p), sptr, cmd)
+#define	min(a, b)		(((a) < (b)) ? (a) : (b))
+
+#define	TRUE	1
+#define	FALSE	0
+#define	FAILURE	-1
+
+#define	UT_LINE_SZ	32	/* Size of a utmpx ut_line field */
+
+/*
+ * SLEEPTIME	The number of seconds "init" sleeps between wakeups if
+ *		nothing else requires this "init" wakeup.
+ */
+#define	SLEEPTIME	(5 * 60)
+
+/*
+ * MAXCMDL	The maximum length of a command string in inittab.
+ */
+#define	MAXCMDL	512
+
+/*
+ * EXEC		The length of the prefix string added to all comamnds
+ *		found in inittab.
+ */
+#define	EXEC	(sizeof ("exec ") - 1)
+
+/*
+ * TWARN	The amount of time between warning signal, SIGTERM,
+ *		and the fatal kill signal, SIGKILL.
+ */
+#define	TWARN	5
+
+#define	id_eq(x, y)	((x[0] == y[0] && x[1] == y[1] && x[2] == y[2] &&\
+			x[3] == y[3]) ? TRUE : FALSE)
+
+/*
+ * The kernel's default umask is 022 these days; since some processes inherit
+ * their umask from init, init will set it from CMASK in /etc/default/init.
+ * init gets the default umask from the kernel, it sets it to 022 whenever
+ * it wants to create a file and reverts to CMASK afterwards.
+ */
+
+static int cmask;
+
+/*
+ * The following definitions, concluding with the 'lvls' array, provide a
+ * common mapping between level-name (like 'S'), signal number (state),
+ * run-level mask, and specific properties associated with a run-level.
+ * This array should be accessed using the routines lvlname_to_state(),
+ * lvlname_to_mask(), state_to_mask(), and state_to_flags().
+ */
+
+/*
+ * Correspondence of signals to init actions.
+ */
+#define	LVLQ		SIGHUP
+#define	LVL0		SIGINT
+#define	LVL1		SIGQUIT
+#define	LVL2		SIGILL
+#define	LVL3		SIGTRAP
+#define	LVL4		SIGIOT
+#define	LVL5		SIGEMT
+#define	LVL6		SIGFPE
+#define	SINGLE_USER	SIGBUS
+#define	LVLa		SIGSEGV
+#define	LVLb		SIGSYS
+#define	LVLc		SIGPIPE
+
+/*
+ * Bit Mask for each level.  Used to determine legal levels.
+ */
+#define	MASK0	0x0001
+#define	MASK1	0x0002
+#define	MASK2	0x0004
+#define	MASK3	0x0008
+#define	MASK4	0x0010
+#define	MASK5	0x0020
+#define	MASK6	0x0040
+#define	MASKSU	0x0080
+#define	MASKa	0x0100
+#define	MASKb	0x0200
+#define	MASKc	0x0400
+
+#define	MASK_NUMERIC (MASK0 | MASK1 | MASK2 | MASK3 | MASK4 | MASK5 | MASK6)
+#define	MASK_abc (MASKa | MASKb | MASKc)
+
+/*
+ * Flags to indicate properties of various states.
+ */
+#define	LSEL_RUNLEVEL	0x0001	/* runlevels you can transition to */
+
+typedef struct lvl {
+	int	lvl_state;
+	int	lvl_mask;
+	char	lvl_name;
+	int	lvl_flags;
+} lvl_t;
+
+static lvl_t lvls[] = {
+	{ LVLQ,		0,	'Q', 0					},
+	{ LVLQ,		0,	'q', 0					},
+	{ LVL0,		MASK0,	'0', LSEL_RUNLEVEL			},
+	{ LVL1, 	MASK1,	'1', LSEL_RUNLEVEL			},
+	{ LVL2, 	MASK2,	'2', LSEL_RUNLEVEL			},
+	{ LVL3, 	MASK3,	'3', LSEL_RUNLEVEL			},
+	{ LVL4, 	MASK4,	'4', LSEL_RUNLEVEL			},
+	{ LVL5, 	MASK5,	'5', LSEL_RUNLEVEL			},
+	{ LVL6, 	MASK6, 	'6', LSEL_RUNLEVEL			},
+	{ SINGLE_USER, 	MASKSU, 'S', LSEL_RUNLEVEL			},
+	{ SINGLE_USER, 	MASKSU, 's', LSEL_RUNLEVEL			},
+	{ LVLa,		MASKa,	'a', 0					},
+	{ LVLb,		MASKb,	'b', 0					},
+	{ LVLc,		MASKc,	'c', 0					}
+};
+
+#define	LVL_NELEMS (sizeof (lvls) / sizeof (lvl_t))
+
+/*
+ * Legal action field values.
+ */
+#define	OFF		0	/* Kill process if on, else ignore */
+#define	RESPAWN		1	/* Continuously restart process when it dies */
+#define	ONDEMAND	RESPAWN	/* Respawn for a, b, c type processes */
+#define	ONCE		2	/* Start process, do not respawn when dead */
+#define	WAIT		3	/* Perform once and wait to complete */
+#define	BOOT		4	/* Start at boot time only */
+#define	BOOTWAIT	5	/* Start at boot time and wait to complete */
+#define	POWERFAIL	6	/* Start on powerfail */
+#define	POWERWAIT	7	/* Start and wait for complete on powerfail */
+#define	INITDEFAULT	8	/* Default level "init" should start at */
+#define	SYSINIT		9	/* Actions performed before init speaks */
+
+#define	M_OFF		0001
+#define	M_RESPAWN	0002
+#define	M_ONDEMAND	M_RESPAWN
+#define	M_ONCE		0004
+#define	M_WAIT		0010
+#define	M_BOOT		0020
+#define	M_BOOTWAIT	0040
+#define	M_PF		0100
+#define	M_PWAIT		0200
+#define	M_INITDEFAULT	0400
+#define	M_SYSINIT	01000
+
+/* States for the inittab parser in getcmd(). */
+#define	ID	1
+#define	LEVELS	2
+#define	ACTION	3
+#define	COMMAND	4
+#define	COMMENT	5
+
+/*
+ * inittab entry id constants
+ */
+#define	INITTAB_ENTRY_ID_SIZE 4
+#define	INITTAB_ENTRY_ID_STR_FORMAT "%.4s"	/* if INITTAB_ENTRY_ID_SIZE */
+						/* changes, this should */
+						/* change accordingly */
+
+/*
+ * Init can be in any of three main states, "normal" mode where it is
+ * processing entries for the lines file in a normal fashion, "boot" mode,
+ * where it is only interested in the boot actions, and "powerfail" mode,
+ * where it is only interested in powerfail related actions. The following
+ * masks declare the legal actions for each mode.
+ */
+#define	NORMAL_MODES	(M_OFF | M_RESPAWN | M_ONCE | M_WAIT)
+#define	BOOT_MODES	(M_BOOT | M_BOOTWAIT)
+#define	PF_MODES	(M_PF | M_PWAIT)
+
+struct PROC_TABLE {
+	char	p_id[INITTAB_ENTRY_ID_SIZE];	/* Four letter unique id of */
+						/* process */
+	pid_t	p_pid;		/* Process id */
+	short	p_count;	/* How many respawns of this command in */
+				/*   the current series */
+	long	p_time;		/* Start time for a series of respawns */
+	short	p_flags;
+	short	p_exit;		/* Exit status of a process which died */
+};
+
+/*
+ * Flags for the "p_flags" word of a PROC_TABLE entry:
+ *
+ *	OCCUPIED	This slot in init's proc table is in use.
+ *
+ *	LIVING		Process is alive.
+ *
+ *	NOCLEANUP	efork() is not allowed to cleanup this entry even
+ *			if process is dead.
+ *
+ *	NAMED		This process has a name, i.e. came from inittab.
+ *
+ *	DEMANDREQUEST	Process started by a "telinit [abc]" command.  Processes
+ *			formed this way are respawnable and immune to level
+ *			changes as long as their entry exists in inittab.
+ *
+ *	TOUCHED		Flag used by remv() to determine whether it has looked
+ *			at an entry while checking for processes to be killed.
+ *
+ *	WARNED		Flag used by remv() to mark processes that have been
+ *			sent the SIGTERM signal.  If they don't die in 5
+ *			seconds, they are sent the SIGKILL signal.
+ *
+ *	KILLED		Flag used by remv() to mark procs that have been sent
+ *			the SIGTERM and SIGKILL signals.
+ *
+ *	PF_MASK		Bitwise or of legal flags, for sanity checking.
+ */
+#define	OCCUPIED	01
+#define	LIVING		02
+#define	NOCLEANUP	04
+#define	NAMED		010
+#define	DEMANDREQUEST	020
+#define	TOUCHED		040
+#define	WARNED		0100
+#define	KILLED		0200
+#define	PF_MASK		0377
+
+/*
+ * Respawn limits for processes that are to be respawned:
+ *
+ *	SPAWN_INTERVAL	The number of seconds over which "init" will try to
+ *			respawn a process SPAWN_LIMIT times before it gets mad.
+ *
+ *	SPAWN_LIMIT	The number of respawns "init" will attempt in
+ *			SPAWN_INTERVAL seconds before it generates an
+ *			error message and inhibits further tries for
+ *			INHIBIT seconds.
+ *
+ *	INHIBIT		The number of seconds "init" ignores an entry it had
+ *			trouble spawning unless a "telinit Q" is received.
+ */
+
+#define	SPAWN_INTERVAL	(2*60)
+#define	SPAWN_LIMIT	10
+#define	INHIBIT		(5*60)
+
+/*
+ * The maximum number of decimal digits for an id_t.  (ceil(log10 (max_id)))
+ */
+#define	ID_MAX_STR_LEN	10
+
+#define	NULLPROC	((struct PROC_TABLE *)(0))
+#define	NO_ROOM		((struct PROC_TABLE *)(FAILURE))
+
+struct CMD_LINE {
+	char c_id[INITTAB_ENTRY_ID_SIZE];	/* Four letter unique id of */
+						/* process to be affected by */
+						/* action */
+	short c_levels;	/* Mask of legal levels for process */
+	short c_action;	/* Mask for type of action required */
+	char *c_command; /* Pointer to init command */
+};
+
+struct	pidrec {
+	int	pd_type;	/* Command type */
+	pid_t	pd_pid;		/* pid to add or remove */
+};
+
+/*
+ * pd_type's
+ */
+#define	ADDPID	1
+#define	REMPID	2
+
+static struct	pidlist {
+	pid_t	pl_pid;		/* pid to watch for */
+	int	pl_dflag;	/* Flag indicating SIGCLD from this pid */
+	short	pl_exit;	/* Exit status of proc */
+	struct	pidlist	*pl_next; /* Next in list */
+} *Plhead, *Plfree;
+
+/*
+ * The following structure contains a set of modes for /dev/syscon
+ * and should match the default contents of /etc/ioctl.syscon.  It should also
+ * be kept in-sync with base_termios in uts/common/io/ttcompat.c.
+ */
+static struct termios	dflt_termios = {
+	BRKINT|ICRNL|IXON|IMAXBEL,			/* iflag */
+	OPOST|ONLCR|TAB3,				/* oflag */
+	CS8|CREAD|B9600,				/* cflag */
+	ISIG|ICANON|ECHO|ECHOE|ECHOK|ECHOCTL|ECHOKE|IEXTEN, /* lflag */
+	CINTR, CQUIT, CERASE, CKILL, CEOF, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0
+};
+
+static struct termios	stored_syscon_termios;
+static int		write_ioctl = 0;	/* Rewrite /etc/ioctl.syscon */
+
+static union WAKEUP {
+	struct WAKEFLAGS {
+		unsigned w_usersignal : 1;	/* User sent signal to "init" */
+		unsigned w_childdeath : 1;	/* An "init" child died */
+		unsigned w_powerhit : 1;	/* OS experienced powerfail */
+	}	w_flags;
+	int w_mask;
+} wakeup;
+
+
+struct init_state {
+	int			ist_runlevel;
+	int			ist_num_proc;
+	int			ist_utmpx_ok;
+	struct PROC_TABLE	ist_proc_table[1];
+};
+
+#define	cur_state	(g_state->ist_runlevel)
+#define	num_proc	(g_state->ist_num_proc)
+#define	proc_table	(g_state->ist_proc_table)
+#define	utmpx_ok	(g_state->ist_utmpx_ok)
+
+/* Contract cookies. */
+#define	ORDINARY_COOKIE		0
+#define	STARTD_COOKIE		1
+
+
+#ifndef NDEBUG
+#define	bad_error(func, err)	{					\
+	(void) fprintf(stderr, "%s:%d: %s() failed with unexpected "	\
+	    "error %d.  Aborting.\n", __FILE__, __LINE__, (func), (err)); \
+	abort();							\
+}
+#else
+#define	bad_error(func, err)	abort()
+#endif
+
+
+/*
+ * Useful file and device names.
+ */
+static char *CONSOLE	  = "/dev/console";	/* Real system console */
+static char *INITPIPE_DIR = "/var/run";
+static char *INITPIPE	  = "/var/run/initpipe";
+
+#define	INIT_STATE_DIR "/etc/svc/volatile"
+static const char * const init_state_file = INIT_STATE_DIR "/init.state";
+static const char * const init_next_state_file =
+	INIT_STATE_DIR "/init-next.state";
+
+static const int init_num_proc = 20;	/* Initial size of process table. */
+
+static char *UTMPX	 = UTMPX_FILE;		/* Snapshot record file */
+static char *WTMPX	 = WTMPX_FILE;		/* Long term record file */
+static char *INITTAB	 = "/etc/inittab";	/* Script file for "init" */
+static char *SYSTTY	 = "/dev/systty";	/* System Console */
+static char *SYSCON	 = "/dev/syscon";	/* Virtual System console */
+static char *IOCTLSYSCON = "/etc/ioctl.syscon";	/* Last syscon modes */
+static char *ENVFILE	 = "/etc/default/init";	/* Default env. */
+static char *SU	= "/etc/sulogin";	/* Super-user program for single user */
+static char *SH	= "/sbin/sh";		/* Standard shell */
+
+/*
+ * Default Path.  /sbin is included in path only during sysinit phase
+ */
+#define	DEF_PATH	"PATH=/usr/sbin:/usr/bin"
+#define	INIT_PATH	"PATH=/sbin:/usr/sbin:/usr/bin"
+
+static int	prior_state;
+static int	prev_state;	/* State "init" was in last time it woke */
+static int	new_state;	/* State user wants "init" to go to. */
+static int	lvlq_received;	/* Explicit request to examine state */
+static int	op_modes = BOOT_MODES; /* Current state of "init" */
+static int	Gchild = 0;	/* Flag to indicate "godchild" died, set in */
+				/*   childeath() and cleared in cleanaux() */
+static int	Pfd = -1;	/* fd to receive pids thru */
+static unsigned int	spawncnt, pausecnt;
+static int	rsflag;		/* Set if a respawn has taken place */
+static volatile int time_up;	/* Flag set to TRUE by the alarm interrupt */
+				/* routine each time an alarm interrupt */
+				/* takes place. */
+static int	sflg = 0;	/* Set if we were booted -s to single user */
+static int	rflg = 0;	/* Set if booted -r, reconfigure devices */
+static int	bflg = 0;	/* Set if booted -b, don't run rc scripts */
+static pid_t	init_pid;	/* PID of "one true" init for current zone */
+
+static struct init_state *g_state = NULL;
+static size_t	g_state_sz;
+static int	booting = 1;	/* Set while we're booting. */
 
-#include "init_shared.h"
+/*
+ * Array for default global environment.
+ */
+#define	MAXENVENT	24	/* Max number of default env variables + 1 */
+				/* init can use three itself, so this leaves */
+				/* 20 for the administrator in ENVFILE. */
+static char	*glob_envp[MAXENVENT];	/* Array of environment strings */
+static int	glob_envn;		/* Number of environment strings */
+
+
+static struct pollfd	poll_fds[1];
+static int		poll_nfds = 0;	/* poll_fds is uninitialized */
+
+/*
+ * Contracts constants
+ */
+#define	SVC_INIT_PREFIX "init:/"
+#define	SVC_AUX_SIZE (INITTAB_ENTRY_ID_SIZE + 1)
+#define	SVC_FMRI_SIZE (sizeof (SVC_INIT_PREFIX) + INITTAB_ENTRY_ID_SIZE)
+
+static int	legacy_tmpl = -1;	/* fd for legacy contract template */
+static int	startd_tmpl = -1;	/* fd for svc.startd's template */
+static char	startd_svc_aux[SVC_AUX_SIZE];
+
+static char	startd_cline[256] = "";	/* svc.startd's command line */
+static int	do_restart_startd = 1;	/* Whether to restart svc.startd. */
+static char	*smf_options = NULL;	/* Options to give to startd. */
+static int	smf_debug = 0;		/* Messages for debugging smf(5) */
+static time_t	init_boot_time;		/* Substitute for kernel boot time. */
+
+#define	NSTARTD_FAILURE_TIMES	3		/* trigger after 3 failures */
+#define	STARTD_FAILURE_RATE_NS	5000000000LL	/* 1 failure/5 seconds */
+
+static hrtime_t	startd_failure_time[NSTARTD_FAILURE_TIMES];
+static uint_t	startd_failure_index;
+
+
+static char	*prog_name(char *);
+static int	state_to_mask(int);
+static int	lvlname_to_mask(char, int *);
+static void	lscf_set_runlevel(char);
+static int	state_to_flags(int);
+static char	state_to_name(int);
+static int	lvlname_to_state(char);
+static int	getcmd(struct CMD_LINE *, char *);
+static int	realcon();
+static int	spawn_processes();
+static int	get_ioctl_syscon();
+static int	account(short, struct PROC_TABLE *, char *);
+static void	alarmclk();
+static void	childeath(int);
+static void	cleanaux();
+static void	clearent(pid_t, short);
+static void	console(boolean_t, char *, ...);
+static void	init_signals(void);
+static void	setup_pipe();
+static void	killproc(pid_t);
+static void	init_env();
+static void	boot_init();
+static void	powerfail();
+static void	remv();
+static void	write_ioctl_syscon();
+static void	spawn(struct PROC_TABLE *, struct CMD_LINE *);
+static void	setimer(int);
+static void	siglvl(int, siginfo_t *, ucontext_t *);
+static void	sigpoll(int);
+static void	enter_maintenance(void);
+static void	timer(int);
+static void	userinit(int, char **);
+static void	notify_pam_dead(struct utmpx *);
+static long	waitproc(struct PROC_TABLE *);
+static struct PROC_TABLE *efork(int, struct PROC_TABLE *, int);
+static struct PROC_TABLE *findpslot(struct CMD_LINE *);
+static void	increase_proc_table_size();
+static void	st_init();
+static void	st_write();
+static void	contracts_init();
+static void	contract_event(struct pollfd *);
+static int	startd_run(const char *, int, ctid_t);
+static void	startd_record_failure();
+static int	startd_failure_rate_critical();
+static char	*audit_boot_msg();
+static int	audit_put_record(int, int, char *);
+static void	update_boot_archive(int new_state);
+
+int
+init_main(int argc, char *argv[])
+{
+	int	chg_lvl_flag = FALSE, print_banner = FALSE;
+	int	may_need_audit = 1;
+	int	c;
+	char	*msg;
+
+	/* Get a timestamp for use as boot time, if needed. */
+	(void) time(&init_boot_time);
+
+	/* Get the default umask */
+	cmask = umask(022);
+	(void) umask(cmask);
+
+	/* Parse the arguments to init. Check for single user */
+	opterr = 0;
+	while ((c = getopt(argc, argv, "brsm:")) != EOF) {
+		switch (c) {
+		case 'b':
+			rflg = 0;
+			bflg = 1;
+			if (!sflg)
+				sflg++;
+			break;
+		case 'r':
+			bflg = 0;
+			rflg++;
+			break;
+		case 's':
+			if (!bflg)
+				sflg++;
+			break;
+		case 'm':
+			smf_options = optarg;
+			smf_debug = (strstr(smf_options, "debug") != NULL);
+			break;
+		}
+	}
+
+	/*
+	 * Determine if we are the main init, or a user invoked init, whose job
+	 * it is to inform init to change levels or perform some other action.
+	 */
+	if (zone_getattr(getzoneid(), ZONE_ATTR_INITPID, &init_pid,
+	    sizeof (init_pid)) != sizeof (init_pid)) {
+		(void) fprintf(stderr, "could not get pid for init\n");
+		return (1);
+	}
+
+	/*
+	 * If this PID is not the same as the "true" init for the zone, then we
+	 * must be in 'user' mode.
+	 */
+	if (getpid() != init_pid) {
+		userinit(argc, argv);
+	}
+
+	if (getzoneid() != GLOBAL_ZONEID) {
+		print_banner = TRUE;
+	}
+
+	/*
+	 * Initialize state (and set "booting").
+	 */
+	st_init();
+
+	if (booting && print_banner) {
+		struct utsname un;
+		char buf[BUFSIZ], *isa;
+		long ret;
+		int bits = 32;
+
+		/*
+		 * We want to print the boot banner as soon as
+		 * possible.  In the global zone, the kernel does it,
+		 * but we do not have that luxury in non-global zones,
+		 * so we will print it here.
+		 */
+		(void) uname(&un);
+		ret = sysinfo(SI_ISALIST, buf, sizeof (buf));
+		if (ret != -1L && ret <= sizeof (buf)) {
+			for (isa = strtok(buf, " "); isa;
+			    isa = strtok(NULL, " ")) {
+				if (strcmp(isa, "sparcv9") == 0 ||
+				    strcmp(isa, "amd64") == 0) {
+					bits = 64;
+					break;
+				}
+			}
+		}
+
+		console(B_FALSE,
+		    "\n\n%s Release %s Version %s %d-bit\r\n",
+		    un.sysname, un.release, un.version, bits);
+		console(B_FALSE,
+		    "Copyright 1983-2009 Sun Microsystems, Inc. "
+		    " All rights reserved.\r\n");
+		console(B_FALSE,
+		    "Use is subject to license terms.\r\n");
+	}
+
+	/*
+	 * Get the ioctl settings for /dev/syscon from /etc/ioctl.syscon
+	 * so that it can be brought up in the state it was in when the
+	 * system went down; or set to defaults if ioctl.syscon isn't
+	 * valid.
+	 *
+	 * This needs to be done even if we're restarting so reset_modes()
+	 * will work in case we need to go down to single user mode.
+	 */
+	write_ioctl = get_ioctl_syscon();
+
+	/*
+	 * Set up all signals to be caught or ignored as appropriate.
+	 */
+	init_signals();
+
+	/* Load glob_envp from ENVFILE. */
+	init_env();
+
+	contracts_init();
+
+	if (!booting) {
+		/* cur_state should have been read in. */
+
+		op_modes = NORMAL_MODES;
+
+		/* Rewrite the ioctl file if it was bad. */
+		if (write_ioctl)
+			write_ioctl_syscon();
+	} else {
+		/*
+		 * It's fine to boot up with state as zero, because
+		 * startd will later tell us the real state.
+		 */
+		cur_state = 0;
+		op_modes = BOOT_MODES;
+
+		boot_init();
+	}
+
+	prev_state = prior_state = cur_state;
+
+	setup_pipe();
+
+	/*
+	 * Here is the beginning of the main process loop.
+	 */
+	for (;;) {
+		if (lvlq_received) {
+			setup_pipe();
+			lvlq_received = B_FALSE;
+		}
+
+		/*
+		 * Clean up any accounting records for dead "godchildren".
+		 */
+		if (Gchild)
+			cleanaux();
+
+		/*
+		 * If in "normal" mode, check all living processes and initiate
+		 * kill sequence on those that should not be there anymore.
+		 */
+		if (op_modes == NORMAL_MODES && cur_state != LVLa &&
+		    cur_state != LVLb && cur_state != LVLc)
+			remv();
+
+		/*
+		 * If a change in run levels is the reason we awoke, now do
+		 * the accounting to report the change in the utmp file.
+		 * Also report the change on the system console.
+		 */
+		if (chg_lvl_flag) {
+			chg_lvl_flag = FALSE;
+
+			if (state_to_flags(cur_state) & LSEL_RUNLEVEL) {
+				char rl = state_to_name(cur_state);
+
+				if (rl != -1)
+					lscf_set_runlevel(rl);
+			}
+
+			may_need_audit = 1;
+		}
+
+		/*
+		 * Scan the inittab file and spawn and respawn processes that
+		 * should be alive in the current state. If inittab does not
+		 * exist default to  single user mode.
+		 */
+		if (spawn_processes() == FAILURE) {
+			prior_state = prev_state;
+			cur_state = SINGLE_USER;
+		}
+
+		/* If any respawns occurred, take note. */
+		if (rsflag) {
+			rsflag = 0;
+			spawncnt++;
+		}
+
+		/*
+		 * If a powerfail signal was received during the last
+		 * sequence, set mode to powerfail.  When spawn_processes() is
+		 * entered the first thing it does is to check "powerhit".  If
+		 * it is in PF_MODES then it clears "powerhit" and does
+		 * a powerfail sequence.  If it is not in PF_MODES, then it
+		 * puts itself in PF_MODES and then clears "powerhit".  Should
+		 * "powerhit" get set again while spawn_processes() is working
+		 * on a powerfail sequence, the following code  will see that
+		 * spawn_processes() tries to execute the powerfail sequence
+		 * again.  This guarantees that the powerfail sequence will be
+		 * successfully completed before further processing takes
+		 * place.
+		 */
+		if (wakeup.w_flags.w_powerhit) {
+			op_modes = PF_MODES;
+			/*
+			 * Make sure that cur_state != prev_state so that
+			 * ONCE and WAIT types work.
+			 */
+			prev_state = 0;
+		} else if (op_modes != NORMAL_MODES) {
+			/*
+			 * If spawn_processes() was not just called while in
+			 * normal mode, we set the mode to normal and it will
+			 * be called again to check normal modes.  If we have
+			 * just finished a powerfail sequence with prev_state
+			 * equal to zero, we set prev_state equal to cur_state
+			 * before the next pass through.
+			 */
+			if (op_modes == PF_MODES)
+				prev_state = cur_state;
+			op_modes = NORMAL_MODES;
+		} else if (cur_state == LVLa || cur_state == LVLb ||
+		    cur_state == LVLc) {
+			/*
+			 * If it was a change of levels that awakened us and the
+			 * new level is one of the demand levels then reset
+			 * cur_state to the previous state and do another scan
+			 * to take care of the usual respawn actions.
+			 */
+			cur_state = prior_state;
+			prior_state = prev_state;
+			prev_state = cur_state;
+		} else {
+			prev_state = cur_state;
+
+			if (wakeup.w_mask == 0) {
+				int ret;
+
+				if (may_need_audit && (cur_state == LVL3)) {
+					msg = audit_boot_msg();
+
+					may_need_audit = 0;
+					(void) audit_put_record(ADT_SUCCESS,
+					    ADT_SUCCESS, msg);
+					free(msg);
+				}
+
+				/*
+				 * "init" is finished with all actions for
+				 * the current wakeup.
+				 */
+				ret = poll(poll_fds, poll_nfds,
+				    SLEEPTIME * MILLISEC);
+				pausecnt++;
+				if (ret > 0)
+					contract_event(&poll_fds[0]);
+				else if (ret < 0 && errno != EINTR)
+					console(B_TRUE, "poll() error: %s\n",
+					    strerror(errno));
+			}
+
+			if (wakeup.w_flags.w_usersignal) {
+				/*
+				 * Install the new level.  This could be a real
+				 * change in levels  or a telinit [Q|a|b|c] or
+				 * just a telinit to the same level at which
+				 * we are running.
+				 */
+				if (new_state != cur_state) {
+					if (new_state == LVLa ||
+					    new_state == LVLb ||
+					    new_state == LVLc) {
+						prev_state = prior_state;
+						prior_state = cur_state;
+						cur_state = new_state;
+					} else {
+						prev_state = cur_state;
+						if (cur_state >= 0)
+							prior_state = cur_state;
+						cur_state = new_state;
+						chg_lvl_flag = TRUE;
+					}
+				}
+
+				new_state = 0;
+			}
+
+			if (wakeup.w_flags.w_powerhit)
+				op_modes = PF_MODES;
+
+			/*
+			 * Clear all wakeup reasons.
+			 */
+			wakeup.w_mask = 0;
+		}
+	}
+
+	/*NOTREACHED*/
+}
+
+static void
+update_boot_archive(int new_state)
+{
+	if (new_state != LVL0 && new_state != LVL5 && new_state != LVL6)
+		return;
+
+	if (getzoneid() != GLOBAL_ZONEID)
+		return;
+
+	(void) system("/sbin/bootadm -ea update_all");
+}
+
+/*
+ * void enter_maintenance()
+ *   A simple invocation of sulogin(1M), with no baggage, in the case that we
+ *   are unable to activate svc.startd(1M).  We fork; the child runs sulogin;
+ *   we wait for it to exit.
+ */
+static void
+enter_maintenance()
+{
+	struct PROC_TABLE	*su_process;
+
+	console(B_FALSE, "Requesting maintenance mode\n"
+	    "(See /lib/svc/share/README for additional information.)\n");
+	(void) sigset(SIGCLD, SIG_DFL);
+	while ((su_process = efork(M_OFF, NULLPROC, NOCLEANUP)) == NO_ROOM)
+		(void) pause();
+	(void) sigset(SIGCLD, childeath);
+	if (su_process == NULLPROC) {
+		int fd;
+
+		(void) fclose(stdin);
+		(void) fclose(stdout);
+		(void) fclose(stderr);
+		closefrom(0);
+
+		fd = open(SYSCON, O_RDWR | O_NOCTTY);
+		if (fd >= 0) {
+			(void) dup2(fd, 1);
+			(void) dup2(fd, 2);
+		} else {
+			/*
+			 * Need to issue an error message somewhere.
+			 */
+			syslog(LOG_CRIT, "init[%d]: cannot open %s; %s\n",
+			    getpid(), SYSCON, strerror(errno));
+		}
+
+		/*
+		 * Execute the "su" program.
+		 */
+		(void) execle(SU, SU, "-", (char *)0, glob_envp);
+		console(B_TRUE, "execle of %s failed: %s\n", SU,
+		    strerror(errno));
+		timer(5);
+		exit(1);
+	}
+
+	/*
+	 * If we are the parent, wait around for the child to die
+	 * or for "init" to be signaled to change levels.
+	 */
+	while (waitproc(su_process) == FAILURE) {
+		/*
+		 * All other reasons for waking are ignored when in
+		 * single-user mode.  The only child we are interested
+		 * in is being waited for explicitly by waitproc().
+		 */
+		wakeup.w_mask = 0;
+	}
+}
+
+/*
+ * remv() scans through "proc_table" and performs cleanup.  If
+ * there is a process in the table, which shouldn't be here at
+ * the current run level, then remv() kills the process.
+ */
+static void
+remv()
+{
+	struct PROC_TABLE	*process;
+	struct CMD_LINE		cmd;
+	char			cmd_string[MAXCMDL];
+	int			change_level;
+
+	change_level = (cur_state != prev_state ? TRUE : FALSE);
+
+	/*
+	 * Clear the TOUCHED flag on all entries so that when we have
+	 * finished scanning inittab, we will be able to tell if we
+	 * have any processes for which there is no entry in inittab.
+	 */
+	for (process = proc_table;
+	    (process < proc_table + num_proc); process++) {
+		process->p_flags &= ~TOUCHED;
+	}
 
+	/*
+	 * Scan all inittab entries.
+	 */
+	while (getcmd(&cmd, &cmd_string[0]) == TRUE) {
+		/* Scan for process which goes with this entry in inittab. */
+		for (process = proc_table;
+		    (process < proc_table + num_proc); process++) {
+			if ((process->p_flags & OCCUPIED) == 0 ||
+			    !id_eq(process->p_id, cmd.c_id))
+				continue;
+
+			/*
+			 * This slot contains the process we are looking for.
+			 */
+
+			/*
+			 * Is the cur_state SINGLE_USER or is this process
+			 * marked as "off" or was this proc started by some
+			 * mechanism other than LVL{a|b|c} and the current level
+			 * does not support this process?
+			 */
+			if (cur_state == SINGLE_USER ||
+			    cmd.c_action == M_OFF ||
+			    ((cmd.c_levels & state_to_mask(cur_state)) == 0 &&
+			    (process->p_flags & DEMANDREQUEST) == 0)) {
+				if (process->p_flags & LIVING) {
+					/*
+					 * Touch this entry so we know we have
+					 * treated it.  Note that procs which
+					 * are already dead at this point and
+					 * should not be restarted are left
+					 * untouched.  This causes their slot to
+					 * be freed later after dead accounting
+					 * is done.
+					 */
+					process->p_flags |= TOUCHED;
+
+					if ((process->p_flags & KILLED) == 0) {
+						if (change_level) {
+							process->p_flags
+							    |= WARNED;
+							(void) kill(
+							    process->p_pid,
+							    SIGTERM);
+						} else {
+							/*
+							 * Fork a killing proc
+							 * so "init" can
+							 * continue without
+							 * having to pause for
+							 * TWARN seconds.
+							 */
+							killproc(
+							    process->p_pid);
+						}
+						process->p_flags |= KILLED;
+					}
+				}
+			} else {
+				/*
+				 * Process can exist at current level.  If it is
+				 * still alive or a DEMANDREQUEST we touch it so
+				 * it will be left alone.  Otherwise we leave it
+				 * untouched so it will be accounted for and
+				 * cleaned up later in remv().  Dead
+				 * DEMANDREQUESTs will be accounted but not
+				 * freed.
+				 */
+				if (process->p_flags &
+				    (LIVING|NOCLEANUP|DEMANDREQUEST))
+					process->p_flags |= TOUCHED;
+			}
+
+			break;
+		}
+	}
+
+	st_write();
+
+	/*
+	 * If this was a change of levels call, scan through the
+	 * process table for processes that were warned to die.  If any
+	 * are found that haven't left yet, sleep for TWARN seconds and
+	 * then send final terminations to any that haven't died yet.
+	 */
+	if (change_level) {
+
+		/*
+		 * Set the alarm for TWARN seconds on the assumption
+		 * that there will be some that need to be waited for.
+		 * This won't harm anything except we are guaranteed to
+		 * wakeup in TWARN seconds whether we need to or not.
+		 */
+		setimer(TWARN);
+
+		/*
+		 * Scan for processes which should be dying.  We hope they
+		 * will die without having to be sent a SIGKILL signal.
+		 */
+		for (process = proc_table;
+		    (process < proc_table + num_proc); process++) {
+			/*
+			 * If this process should die, hasn't yet, and the
+			 * TWARN time hasn't expired yet, wait for process
+			 * to die or for timer to expire.
+			 */
+			while (time_up == FALSE &&
+			    (process->p_flags & (WARNED|LIVING|OCCUPIED)) ==
+			    (WARNED|LIVING|OCCUPIED))
+				(void) pause();
+
+			if (time_up == TRUE)
+				break;
+		}
+
+		/*
+		 * If we reached the end of the table without the timer
+		 * expiring, then there are no procs which will have to be
+		 * sent the SIGKILL signal.  If the timer has expired, then
+		 * it is necessary to scan the table again and send signals
+		 * to all processes which aren't going away nicely.
+		 */
+		if (time_up == TRUE) {
+			for (process = proc_table;
+			    (process < proc_table + num_proc); process++) {
+				if ((process->p_flags &
+				    (WARNED|LIVING|OCCUPIED)) ==
+				    (WARNED|LIVING|OCCUPIED))
+					(void) kill(process->p_pid, SIGKILL);
+			}
+		}
+		setimer(0);
+	}
+
+	/*
+	 * Rescan the proc_table for two kinds of entry, those marked LIVING,
+	 * NAMED, which don't have an entry in inittab (haven't been TOUCHED
+	 * by the above scanning), and haven't been sent kill signals, and
+	 * those entries marked not LIVING, NAMED.  The former procs are killed.
+	 * The latter have DEAD_PROCESS accounting done and the slot cleared.
+	 */
+	for (process = proc_table;
+	    (process < proc_table + num_proc); process++) {
+		if ((process->p_flags & (LIVING|NAMED|TOUCHED|KILLED|OCCUPIED))
+		    == (LIVING|NAMED|OCCUPIED)) {
+			killproc(process->p_pid);
+			process->p_flags |= KILLED;
+		} else if ((process->p_flags & (LIVING|NAMED|OCCUPIED)) ==
+		    (NAMED|OCCUPIED)) {
+			(void) account(DEAD_PROCESS, process, NULL);
+			/*
+			 * If this named proc hasn't been TOUCHED, then free the
+			 * space. It has either died of it's own accord, but
+			 * isn't respawnable or it was killed because it
+			 * shouldn't exist at this level.
+			 */
+			if ((process->p_flags & TOUCHED) == 0)
+				process->p_flags = 0;
+		}
+	}
+
+	st_write();
+}
+
+/*
+ * Extract the svc.startd command line and whether to restart it from its
+ * inittab entry.
+ */
+/*ARGSUSED*/
+static void
+process_startd_line(struct CMD_LINE *cmd, char *cmd_string)
+{
+	size_t sz;
+
+	/* Save the command line. */
+	if (sflg || rflg) {
+		/* Also append -r or -s. */
+		(void) strlcpy(startd_cline, cmd_string, sizeof (startd_cline));
+		(void) strlcat(startd_cline, " -", sizeof (startd_cline));
+		if (sflg)
+			sz = strlcat(startd_cline, "s", sizeof (startd_cline));
+		if (rflg)
+			sz = strlcat(startd_cline, "r", sizeof (startd_cline));
+	} else {
+		sz = strlcpy(startd_cline, cmd_string, sizeof (startd_cline));
+	}
+
+	if (sz >= sizeof (startd_cline)) {
+		console(B_TRUE,
+		    "svc.startd command line too long.  Ignoring.\n");
+		startd_cline[0] = '\0';
+		return;
+	}
+}
+
+/*
+ * spawn_processes() scans inittab for entries which should be run at this
+ * mode.  Processes which should be running but are not, are started.
+ */
+static int
+spawn_processes()
+{
+	struct PROC_TABLE		*pp;
+	struct CMD_LINE			cmd;
+	char				cmd_string[MAXCMDL];
+	short				lvl_mask;
+	int				status;
+
+	/*
+	 * First check the "powerhit" flag.  If it is set, make sure the modes
+	 * are PF_MODES and clear the "powerhit" flag.  Avoid the possible race
+	 * on the "powerhit" flag by disallowing a new powerfail interrupt
+	 * between the test of the powerhit flag and the clearing of it.
+	 */
+	if (wakeup.w_flags.w_powerhit) {
+		wakeup.w_flags.w_powerhit = 0;
+		op_modes = PF_MODES;
+	}
+	lvl_mask = state_to_mask(cur_state);
+
+	/*
+	 * Scan through all the entries in inittab.
+	 */
+	while ((status = getcmd(&cmd, &cmd_string[0])) == TRUE) {
+		if (id_eq(cmd.c_id, "smf")) {
+			process_startd_line(&cmd, cmd_string);
+			continue;
+		}
+
+retry_for_proc_slot:
+
+		/*
+		 * Find out if there is a process slot for this entry already.
+		 */
+		if ((pp = findpslot(&cmd)) == NULLPROC) {
+			/*
+			 * we've run out of proc table entries
+			 * increase proc_table.
+			 */
+			increase_proc_table_size();
+
+			/*
+			 * Retry now as we have an empty proc slot.
+			 * In case increase_proc_table_size() fails,
+			 * we will keep retrying.
+			 */
+			goto retry_for_proc_slot;
+		}
+
+		/*
+		 * If there is an entry, and it is marked as DEMANDREQUEST,
+		 * one of the levels a, b, or c is in its levels mask, and
+		 * the action field is ONDEMAND and ONDEMAND is a permissable
+		 * mode, and the process is dead, then respawn it.
+		 */
+		if (((pp->p_flags & (LIVING|DEMANDREQUEST)) == DEMANDREQUEST) &&
+		    (cmd.c_levels & MASK_abc) &&
+		    (cmd.c_action & op_modes) == M_ONDEMAND) {
+			spawn(pp, &cmd);
+			continue;
+		}
+
+		/*
+		 * If the action is not an action we are interested in,
+		 * skip the entry.
+		 */
+		if ((cmd.c_action & op_modes) == 0 || pp->p_flags & LIVING ||
+		    (cmd.c_levels & lvl_mask) == 0)
+			continue;
+
+		/*
+		 * If the modes are the normal modes (ONCE, WAIT, RESPAWN, OFF,
+		 * ONDEMAND) and the action field is either OFF or the action
+		 * field is ONCE or WAIT and the current level is the same as
+		 * the last level, then skip this entry.  ONCE and WAIT only
+		 * get run when the level changes.
+		 */
+		if (op_modes == NORMAL_MODES &&
+		    (cmd.c_action == M_OFF ||
+		    (cmd.c_action & (M_ONCE|M_WAIT)) &&
+		    cur_state == prev_state))
+			continue;
+
+		/*
+		 * At this point we are interested in performing the action for
+		 * this entry.  Actions fall into two categories, spinning off
+		 * a process and not waiting, and spinning off a process and
+		 * waiting for it to die.  If the action is ONCE, RESPAWN,
+		 * ONDEMAND, POWERFAIL, or BOOT we don't wait for the process
+		 * to die, for all other actions we do wait.
+		 */
+		if (cmd.c_action & (M_ONCE | M_RESPAWN | M_PF | M_BOOT)) {
+			spawn(pp, &cmd);
+
+		} else {
+			spawn(pp, &cmd);
+			while (waitproc(pp) == FAILURE)
+				;
+			(void) account(DEAD_PROCESS, pp, NULL);
+			pp->p_flags = 0;
+		}
+	}
+	return (status);
+}
+
+/*
+ * spawn() spawns a shell, inserts the information about the process
+ * process into the proc_table, and does the startup accounting.
+ */
+static void
+spawn(struct PROC_TABLE *process, struct CMD_LINE *cmd)
+{
+	int		i;
+	int		modes, maxfiles;
+	time_t		now;
+	struct PROC_TABLE tmproc, *oprocess;
+
+	/*
+	 * The modes to be sent to efork() are 0 unless we are
+	 * spawning a LVLa, LVLb, or LVLc entry or we will be
+	 * waiting for the death of the child before continuing.
+	 */
+	modes = NAMED;
+	if (process->p_flags & DEMANDREQUEST || cur_state == LVLa ||
+	    cur_state == LVLb || cur_state == LVLc)
+		modes |= DEMANDREQUEST;
+	if ((cmd->c_action & (M_SYSINIT | M_WAIT | M_BOOTWAIT | M_PWAIT)) != 0)
+		modes |= NOCLEANUP;
+
+	/*
+	 * If this is a respawnable process, check the threshold
+	 * information to avoid excessive respawns.
+	 */
+	if (cmd->c_action & M_RESPAWN) {
+		/*
+		 * Add NOCLEANUP to all respawnable commands so that the
+		 * information about the frequency of respawns isn't lost.
+		 */
+		modes |= NOCLEANUP;
+		(void) time(&now);
+
+		/*
+		 * If no time is assigned, then this is the first time
+		 * this command is being processed in this series.  Assign
+		 * the current time.
+		 */
+		if (process->p_time == 0L)
+			process->p_time = now;
+
+		if (process->p_count++ == SPAWN_LIMIT) {
+
+			if ((now - process->p_time) < SPAWN_INTERVAL) {
+				/*
+				 * Process is respawning too rapidly.  Print
+				 * message and refuse to respawn it for now.
+				 */
+				console(B_TRUE, "Command is respawning too "
+				    "rapidly. Check for possible errors.\n"
+				    "id:%4s \"%s\"\n",
+				    &cmd->c_id[0], &cmd->c_command[EXEC]);
+				return;
+			}
+			process->p_time = now;
+			process->p_count = 0;
+
+		} else if (process->p_count > SPAWN_LIMIT) {
+			/*
+			 * If process has been respawning too rapidly and
+			 * the inhibit time limit hasn't expired yet, we
+			 * refuse to respawn.
+			 */
+			if (now - process->p_time < SPAWN_INTERVAL + INHIBIT)
+				return;
+			process->p_time = now;
+			process->p_count = 0;
+		}
+		rsflag = TRUE;
+	}
+
+	/*
+	 * Spawn a child process to execute this command.
+	 */
+	(void) sigset(SIGCLD, SIG_DFL);
+	oprocess = process;
+	while ((process = efork(cmd->c_action, oprocess, modes)) == NO_ROOM)
+		(void) pause();
+
+	if (process == NULLPROC) {
+
+		/*
+		 * We are the child.  We must make sure we get a different
+		 * file pointer for our references to utmpx.  Otherwise our
+		 * seeks and reads will compete with those of the parent.
+		 */
+		endutxent();
+
+		/*
+		 * Perform the accounting for the beginning of a process.
+		 * Note that all processes are initially "INIT_PROCESS"es.
+		 */
+		tmproc.p_id[0] = cmd->c_id[0];
+		tmproc.p_id[1] = cmd->c_id[1];
+		tmproc.p_id[2] = cmd->c_id[2];
+		tmproc.p_id[3] = cmd->c_id[3];
+		tmproc.p_pid = getpid();
+		tmproc.p_exit = 0;
+		(void) account(INIT_PROCESS, &tmproc,
+		    prog_name(&cmd->c_command[EXEC]));
+		maxfiles = ulimit(UL_GDESLIM, 0);
+		for (i = 0; i < maxfiles; i++)
+			(void) fcntl(i, F_SETFD, FD_CLOEXEC);
+
+		/*
+		 * Now exec a shell with the -c option and the command
+		 * from inittab.
+		 */
+		(void) execle(SH, "INITSH", "-c", cmd->c_command, (char *)0,
+		    glob_envp);
+		console(B_TRUE, "Command\n\"%s\"\n failed to execute.  errno "
+		    "= %d (exec of shell failed)\n", cmd->c_command, errno);
+
+		/*
+		 * Don't come back so quickly that "init" doesn't have a
+		 * chance to finish putting this child in "proc_table".
+		 */
+		timer(20);
+		exit(1);
+
+	}
+
+	/*
+	 * We are the parent.  Insert the necessary
+	 * information in the proc_table.
+	 */
+	process->p_id[0] = cmd->c_id[0];
+	process->p_id[1] = cmd->c_id[1];
+	process->p_id[2] = cmd->c_id[2];
+	process->p_id[3] = cmd->c_id[3];
+
+	st_write();
+
+	(void) sigset(SIGCLD, childeath);
+}
+
+/*
+ * findpslot() finds the old slot in the process table for the
+ * command with the same id, or it finds an empty slot.
+ */
+static struct PROC_TABLE *
+findpslot(struct CMD_LINE *cmd)
+{
+	struct PROC_TABLE	*process;
+	struct PROC_TABLE	*empty = NULLPROC;
+
+	for (process = proc_table;
+	    (process < proc_table + num_proc); process++) {
+		if (process->p_flags & OCCUPIED &&
+		    id_eq(process->p_id, cmd->c_id))
+			break;
+
+		/*
+		 * If the entry is totally empty and "empty" is still 0,
+		 * remember where this hole is and make sure the slot is
+		 * zeroed out.
+		 */
+		if (empty == NULLPROC && (process->p_flags & OCCUPIED) == 0) {
+			empty = process;
+			process->p_id[0] = '\0';
+			process->p_id[1] = '\0';
+			process->p_id[2] = '\0';
+			process->p_id[3] = '\0';
+			process->p_pid = 0;
+			process->p_time = 0L;
+			process->p_count = 0;
+			process->p_flags = 0;
+			process->p_exit = 0;
+		}
+	}
+
+	/*
+	 * If there is no entry for this slot, then there should be an
+	 * empty slot.  If there is no empty slot, then we've run out
+	 * of proc_table space.  If the latter is true, empty will be
+	 * NULL and the caller will have to complain.
+	 */
+	if (process == (proc_table + num_proc))
+		process = empty;
+
+	return (process);
+}
+
+/*
+ * getcmd() parses lines from inittab.  Each time it finds a command line
+ * it will return TRUE as well as fill the passed CMD_LINE structure and
+ * the shell command string.  When the end of inittab is reached, FALSE
+ * is returned inittab is automatically opened if it is not currently open
+ * and is closed when the end of the file is reached.
+ */
+static FILE *fp_inittab = NULL;
+
+static int
+getcmd(struct CMD_LINE *cmd, char *shcmd)
+{
+	char	*ptr;
+	int	c, lastc, state;
+	char 	*ptr1;
+	int	answer, i, proceed;
+	struct	stat	sbuf;
+	static char *actions[] = {
+		"off", "respawn", "ondemand", "once", "wait", "boot",
+		"bootwait", "powerfail", "powerwait", "initdefault",
+		"sysinit",
+	};
+	static short act_masks[] = {
+		M_OFF, M_RESPAWN, M_ONDEMAND, M_ONCE, M_WAIT, M_BOOT,
+		M_BOOTWAIT, M_PF, M_PWAIT, M_INITDEFAULT, M_SYSINIT,
+	};
+	/*
+	 * Only these actions will be allowed for entries which
+	 * are specified for single-user mode.
+	 */
+	short su_acts = M_INITDEFAULT | M_PF | M_PWAIT | M_WAIT;
+
+	if (fp_inittab == NULL) {
+		/*
+		 * Before attempting to open inittab we stat it to make
+		 * sure it currently exists and is not empty.  We try
+		 * several times because someone may have temporarily
+		 * unlinked or truncated the file.
+		 */
+		for (i = 0; i < 3; i++) {
+			if (stat(INITTAB, &sbuf) == -1) {
+				if (i == 2) {
+					console(B_TRUE,
+					    "Cannot stat %s, errno: %d\n",
+					    INITTAB, errno);
+					return (FAILURE);
+				} else {
+					timer(3);
+				}
+			} else if (sbuf.st_size < 10) {
+				if (i == 2) {
+					console(B_TRUE,
+					    "%s truncated or corrupted\n",
+					    INITTAB);
+					return (FAILURE);
+				} else {
+					timer(3);
+				}
+			} else {
+				break;
+			}
+		}
+
+		/*
+		 * If unable to open inittab, print error message and
+		 * return FAILURE to caller.
+		 */
+		if ((fp_inittab = fopen(INITTAB, "r")) == NULL) {
+			console(B_TRUE, "Cannot open %s errno: %d\n", INITTAB,
+			    errno);
+			return (FAILURE);
+		}
+	}
+
+	/*
+	 * Keep getting commands from inittab until you find a
+	 * good one or run out of file.
+	 */
+	for (answer = FALSE; answer == FALSE; ) {
+		/*
+		 * Zero out the cmd itself before trying next line.
+		 */
+		bzero(cmd, sizeof (struct CMD_LINE));
+
+		/*
+		 * Read in lines of inittab, parsing at colons, until a line is
+		 * read in which doesn't end with a backslash.  Do not start if
+		 * the first character read is an EOF.  Note that this means
+		 * that lines which don't end in a newline are still processed,
+		 * since the "for" will terminate normally once started,
+		 * regardless of whether line terminates with a newline or EOF.
+		 */
+		state = FAILURE;
+		if ((c = fgetc(fp_inittab)) == EOF) {
+			answer = FALSE;
+			(void) fclose(fp_inittab);
+			fp_inittab = NULL;
+			break;
+		}
+
+		for (proceed = TRUE, ptr = shcmd, state = ID, lastc = '\0';
+		    proceed && c != EOF;
+		    lastc = c, c = fgetc(fp_inittab)) {
+		    /* If we're not in the FAILURE state and haven't	*/
+		    /* yet reached the shell command field, process	*/
+		    /* the line, otherwise just look for a real end	*/
+		    /* of line.						*/
+		    if (state != FAILURE && state != COMMAND) {
+			/*
+			 * Squeeze out spaces and tabs.
+			 */
+			if (c == ' ' || c == '\t')
+				continue;
+
+			/*
+			 * Ignore characters in a comment, except for the \n.
+			 */
+			if (state == COMMENT) {
+				if (c == '\n') {
+					lastc = ' ';
+					break;
+				} else {
+					continue;
+				}
+			}
+
+			/*
+			 * Detect comments (lines whose first non-whitespace
+			 * character is '#') by checking that we're at the
+			 * beginning of a line, have seen a '#', and haven't
+			 * yet accumulated any characters.
+			 */
+			if (state == ID && c == '#' && ptr == shcmd) {
+				state = COMMENT;
+				continue;
+			}
+
+			/*
+			 * If the character is a ':', then check the
+			 * previous field for correctness and advance
+			 * to the next field.
+			 */
+			if (c == ':') {
+			    switch (state) {
+
+			    case ID :
+				/*
+				 * Check to see that there are only
+				 * 1 to 4 characters for the id.
+				 */
+				if ((i = ptr - shcmd) < 1 || i > 4) {
+					state = FAILURE;
+				} else {
+					bcopy(shcmd, &cmd->c_id[0], i);
+					ptr = shcmd;
+					state = LEVELS;
+				}
+				break;
+
+			    case LEVELS :
+				/*
+				 * Build a mask for all the levels for
+				 * which this command will be legal.
+				 */
+				for (cmd->c_levels = 0, ptr1 = shcmd;
+				    ptr1 < ptr; ptr1++) {
+					int mask;
+					if (lvlname_to_mask(*ptr1,
+					    &mask) == -1) {
+						state = FAILURE;
+						break;
+					}
+					cmd->c_levels |= mask;
+				}
+				if (state != FAILURE) {
+					state = ACTION;
+					ptr = shcmd;	/* Reset the buffer */
+				}
+				break;
+
+			    case ACTION :
+				/*
+				 * Null terminate the string in shcmd buffer and
+				 * then try to match against legal actions.  If
+				 * the field is of length 0, then the default of
+				 * "RESPAWN" is used if the id is numeric,
+				 * otherwise the default is "OFF".
+				 */
+				if (ptr == shcmd) {
+					if (isdigit(cmd->c_id[0]) &&
+					    (cmd->c_id[1] == '\0' ||
+						isdigit(cmd->c_id[1])) &&
+					    (cmd->c_id[2] == '\0' ||
+						isdigit(cmd->c_id[2])) &&
+					    (cmd->c_id[3] == '\0' ||
+						isdigit(cmd->c_id[3])))
+						    cmd->c_action = M_RESPAWN;
+					else
+						    cmd->c_action = M_OFF;
+				} else {
+				    for (cmd->c_action = 0, i = 0, *ptr = '\0';
+				    i < sizeof (actions)/sizeof (char *);
+				    i++) {
+					if (strcmp(shcmd, actions[i]) == 0) {
+					    if ((cmd->c_levels & MASKSU) &&
+						!(act_masks[i] & su_acts))
+						    cmd->c_action = 0;
+					    else
+						cmd->c_action = act_masks[i];
+					    break;
+					}
+				    }
+				}
+
+				/*
+				 * If the action didn't match any legal action,
+				 * set state to FAILURE.
+				 */
+				if (cmd->c_action == 0) {
+					state = FAILURE;
+				} else {
+					state = COMMAND;
+					(void) strcpy(shcmd, "exec ");
+				}
+				ptr = shcmd + EXEC;
+				break;
+			    }
+			    continue;
+			}
+		    }
+
+		    /* If the character is a '\n', then this is the end of a */
+		    /* line.  If the '\n' wasn't preceded by a backslash, */
+		    /* it is also the end of an inittab command.  If it was */
+		    /* preceded by a backslash then the next line is a */
+		    /* continuation.  Note that the continuation '\n' falls */
+		    /* through and is treated like other characters and is */
+		    /* stored in the shell command line. */
+		    if (c == '\n' && lastc != '\\') {
+				proceed = FALSE;
+				*ptr = '\0';
+				break;
+		    }
+
+		    /* For all other characters just stuff them into the */
+		    /* command as long as there aren't too many of them. */
+		    /* Make sure there is room for a terminating '\0' also. */
+		    if (ptr >= shcmd + MAXCMDL - 1)
+			state = FAILURE;
+		    else
+			*ptr++ = (char)c;
+
+		    /* If the character we just stored was a quoted	*/
+		    /* backslash, then change "c" to '\0', so that this	*/
+		    /* backslash will not cause a subsequent '\n' to appear */
+		    /* quoted.  In otherwords '\' '\' '\n' is the real end */
+		    /* of a command, while '\' '\n' is a continuation. */
+		    if (c == '\\' && lastc == '\\')
+			c = '\0';
+		}
+
+		/*
+		 * Make sure all the fields are properly specified
+		 * for a good command line.
+		 */
+		if (state == COMMAND) {
+			answer = TRUE;
+			cmd->c_command = shcmd;
+
+			/*
+			 * If no default level was supplied, insert
+			 * all numerical levels.
+			 */
+			if (cmd->c_levels == 0)
+				cmd->c_levels = MASK_NUMERIC;
+
+			/*
+			 * If no action has been supplied, declare this
+			 * entry to be OFF.
+			 */
+			if (cmd->c_action == 0)
+				cmd->c_action = M_OFF;
+
+			/*
+			 * If no shell command has been supplied, make sure
+			 * there is a null string in the command field.
+			 */
+			if (ptr == shcmd + EXEC)
+				*shcmd = '\0';
+		} else
+			answer = FALSE;
+
+		/*
+		 * If we have reached the end of inittab, then close it
+		 * and quit trying to find a good command line.
+		 */
+		if (c == EOF) {
+			(void) fclose(fp_inittab);
+			fp_inittab = NULL;
+			break;
+		}
+	}
+	return (answer);
+}
+
+/*
+ * lvlname_to_state(): convert the character name of a state to its level
+ * (its corresponding signal number).
+ */
+static int
+lvlname_to_state(char name)
+{
+	int i;
+	for (i = 0; i < LVL_NELEMS; i++) {
+		if (lvls[i].lvl_name == name)
+			return (lvls[i].lvl_state);
+	}
+	return (-1);
+}
+
+/*
+ * state_to_name(): convert the level to the character name.
+ */
+static char
+state_to_name(int state)
+{
+	int i;
+	for (i = 0; i < LVL_NELEMS; i++) {
+		if (lvls[i].lvl_state == state)
+			return (lvls[i].lvl_name);
+	}
+	return (-1);
+}
+
+/*
+ * state_to_mask(): return the mask corresponding to a signal number
+ */
+static int
+state_to_mask(int state)
+{
+	int i;
+	for (i = 0; i < LVL_NELEMS; i++) {
+		if (lvls[i].lvl_state == state)
+			return (lvls[i].lvl_mask);
+	}
+	return (0);	/* return 0, since that represents an empty mask */
+}
+
+/*
+ * lvlname_to_mask(): return the mask corresponding to a levels character name
+ */
+static int
+lvlname_to_mask(char name, int *mask)
+{
+	int i;
+	for (i = 0; i < LVL_NELEMS; i++) {
+		if (lvls[i].lvl_name == name) {
+			*mask = lvls[i].lvl_mask;
+			return (0);
+		}
+	}
+	return (-1);
+}
+
+/*
+ * state_to_flags(): return the flags corresponding to a runlevel.  These
+ * indicate properties of that runlevel.
+ */
+static int
+state_to_flags(int state)
+{
+	int i;
+	for (i = 0; i < LVL_NELEMS; i++) {
+		if (lvls[i].lvl_state == state)
+			return (lvls[i].lvl_flags);
+	}
+	return (0);
+}
+
+/*
+ * killproc() creates a child which kills the process specified by pid.
+ */
+void
+killproc(pid_t pid)
+{
+	struct PROC_TABLE	*process;
+
+	(void) sigset(SIGCLD, SIG_DFL);
+	while ((process = efork(M_OFF, NULLPROC, 0)) == NO_ROOM)
+		(void) pause();
+	(void) sigset(SIGCLD, childeath);
+
+	if (process == NULLPROC) {
+		/*
+		 * efork() sets all signal handlers to the default, so reset
+		 * the ALRM handler to make timer() work as expected.
+		 */
+		(void) sigset(SIGALRM, alarmclk);
+
+		/*
+		 * We are the child.  Try to terminate the process nicely
+		 * first using SIGTERM and if it refuses to die in TWARN
+		 * seconds kill it with SIGKILL.
+		 */
+		(void) kill(pid, SIGTERM);
+		(void) timer(TWARN);
+		(void) kill(pid, SIGKILL);
+		(void) exit(0);
+	}
+}
+
+/*
+ * Set up the default environment for all procs to be forked from init.
+ * Read the values from the /etc/default/init file, except for PATH.  If
+ * there's not enough room in the environment array, the environment
+ * lines that don't fit are silently discarded.
+ */
+void
+init_env()
+{
+	char	line[MAXCMDL];
+	FILE	*fp;
+	int	inquotes, length, wslength;
+	char	*tokp, *cp1, *cp2;
+
+	glob_envp[0] = malloc((unsigned)(strlen(DEF_PATH)+2));
+	(void) strcpy(glob_envp[0], DEF_PATH);
+	glob_envn = 1;
+
+	if (rflg) {
+		glob_envp[1] =
+		    malloc((unsigned)(strlen("_DVFS_RECONFIG=YES")+2));
+		(void) strcpy(glob_envp[1], "_DVFS_RECONFIG=YES");
+		++glob_envn;
+	} else if (bflg == 1) {
+		glob_envp[1] =
+		    malloc((unsigned)(strlen("RB_NOBOOTRC=YES")+2));
+		(void) strcpy(glob_envp[1], "RB_NOBOOTRC=YES");
+		++glob_envn;
+	}
+
+	if ((fp = fopen(ENVFILE, "r")) == NULL) {
+		console(B_TRUE,
+		    "Cannot open %s. Environment not initialized.\n",
+		    ENVFILE);
+	} else {
+		while (fgets(line, MAXCMDL - 1, fp) != NULL &&
+		    glob_envn < MAXENVENT - 2) {
+			/*
+			 * Toss newline
+			 */
+			length = strlen(line);
+			if (line[length - 1] == '\n')
+				line[length - 1] = '\0';
+
+			/*
+			 * Ignore blank or comment lines.
+			 */
+			if (line[0] == '#' || line[0] == '\0' ||
+			    (wslength = strspn(line, " \t\n")) ==
+			    strlen(line) ||
+			    strchr(line, '#') == line + wslength)
+				continue;
+
+			/*
+			 * First make a pass through the line and change
+			 * any non-quoted semi-colons to blanks so they
+			 * will be treated as token separators below.
+			 */
+			inquotes = 0;
+			for (cp1 = line; *cp1 != '\0'; cp1++) {
+				if (*cp1 == '"') {
+					if (inquotes == 0)
+						inquotes = 1;
+					else
+						inquotes = 0;
+				} else if (*cp1 == ';') {
+					if (inquotes == 0)
+						*cp1 = ' ';
+				}
+			}
+
+			/*
+			 * Tokens within the line are separated by blanks
+			 *  and tabs.  For each token in the line which
+			 * contains a '=' we strip out any quotes and then
+			 * stick the token in the environment array.
+			 */
+			if ((tokp = strtok(line, " \t")) == NULL)
+				continue;
+			do {
+				if (strchr(tokp, '=') == NULL)
+					continue;
+				length = strlen(tokp);
+				while ((cp1 = strpbrk(tokp, "\"\'")) != NULL) {
+					for (cp2 = cp1;
+					    cp2 < &tokp[length]; cp2++)
+						*cp2 = *(cp2 + 1);
+					length--;
+				}
+
+				if (strncmp(tokp, "CMASK=",
+				    sizeof ("CMASK=") - 1) == 0) {
+					long t;
+
+					/* We know there's an = */
+					t = strtol(strchr(tokp, '=') + 1, NULL,
+					    8);
+
+					/* Sanity */
+					if (t <= 077 && t >= 0)
+						cmask = (int)t;
+					(void) umask(cmask);
+					continue;
+				}
+				glob_envp[glob_envn] =
+				    malloc((unsigned)(length + 1));
+				(void) strcpy(glob_envp[glob_envn], tokp);
+				if (++glob_envn >= MAXENVENT - 1)
+					break;
+			} while ((tokp = strtok(NULL, " \t")) != NULL);
+		}
+
+		/*
+		 * Append a null pointer to the environment array
+		 * to mark its end.
+		 */
+		glob_envp[glob_envn] = NULL;
+		(void) fclose(fp);
+	}
+}
+
+/*
+ * boot_init(): Do initialization things that should be done at boot.
+ */
+void
+boot_init()
+{
+	int i;
+	struct PROC_TABLE *process, *oprocess;
+	struct CMD_LINE	cmd;
+	char	line[MAXCMDL];
+	char	svc_aux[SVC_AUX_SIZE];
+	char	init_svc_fmri[SVC_FMRI_SIZE];
+	char *old_path;
+	int maxfiles;
+
+	/* Use INIT_PATH for sysinit cmds */
+	old_path = glob_envp[0];
+	glob_envp[0] = malloc((unsigned)(strlen(INIT_PATH)+2));
+	(void) strcpy(glob_envp[0], INIT_PATH);
+
+	/*
+	 * Scan inittab(4) and process the special svc.startd entry, initdefault
+	 * and sysinit entries.
+	 */
+	while (getcmd(&cmd, &line[0]) == TRUE) {
+		if (startd_tmpl >= 0 && id_eq(cmd.c_id, "smf")) {
+			process_startd_line(&cmd, line);
+			(void) snprintf(startd_svc_aux, SVC_AUX_SIZE,
+			    INITTAB_ENTRY_ID_STR_FORMAT, cmd.c_id);
+		} else if (cmd.c_action == M_INITDEFAULT) {
+			/*
+			 * initdefault is no longer meaningful, as the SMF
+			 * milestone controls what (legacy) run level we
+			 * boot to.
+			 */
+			console(B_TRUE,
+			    "Ignoring legacy \"initdefault\" entry.\n");
+		} else if (cmd.c_action == M_SYSINIT) {
+			/*
+			 * Execute the "sysinit" entry and wait for it to
+			 * complete.  No bookkeeping is performed on these
+			 * entries because we avoid writing to the file system
+			 * until after there has been an chance to check it.
+			 */
+			if (process = findpslot(&cmd)) {
+				(void) sigset(SIGCLD, SIG_DFL);
+				(void) snprintf(svc_aux, SVC_AUX_SIZE,
+				    INITTAB_ENTRY_ID_STR_FORMAT, cmd.c_id);
+				(void) snprintf(init_svc_fmri, SVC_FMRI_SIZE,
+				    SVC_INIT_PREFIX INITTAB_ENTRY_ID_STR_FORMAT,
+				    cmd.c_id);
+				if (legacy_tmpl >= 0) {
+					(void) ct_pr_tmpl_set_svc_fmri(
+					    legacy_tmpl, init_svc_fmri);
+					(void) ct_pr_tmpl_set_svc_aux(
+					    legacy_tmpl, svc_aux);
+				}
+
+				for (oprocess = process;
+				    (process = efork(M_OFF, oprocess,
+				    (NAMED|NOCLEANUP))) == NO_ROOM;
+				    /* CSTYLED */)
+					;
+				(void) sigset(SIGCLD, childeath);
+
+				if (process == NULLPROC) {
+					maxfiles = ulimit(UL_GDESLIM, 0);
+
+					for (i = 0; i < maxfiles; i++)
+						(void) fcntl(i, F_SETFD,
+						    FD_CLOEXEC);
+					(void) execle(SH, "INITSH", "-c",
+					    cmd.c_command,
+					    (char *)0, glob_envp);
+					console(B_TRUE,
+"Command\n\"%s\"\n failed to execute.  errno = %d (exec of shell failed)\n",
+					    cmd.c_command, errno);
+					exit(1);
+				} else while (waitproc(process) == FAILURE);
+				process->p_flags = 0;
+				st_write();
+			}
+		}
+	}
+
+	/* Restore the path. */
+	free(glob_envp[0]);
+	glob_envp[0] = old_path;
+
+	/*
+	 * This will enable st_write() to complain about init_state_file.
+	 */
+	booting = 0;
+
+	/*
+	 * If the /etc/ioctl.syscon didn't exist or had invalid contents write
+	 * out a correct version.
+	 */
+	if (write_ioctl)
+		write_ioctl_syscon();
+
+	/*
+	 * Start svc.startd(1M), which does most of the work.
+	 */
+	if (startd_cline[0] != '\0' && startd_tmpl >= 0) {
+		/* Start svc.startd. */
+		if (startd_run(startd_cline, startd_tmpl, 0) == -1)
+			cur_state = SINGLE_USER;
+	} else {
+		console(B_TRUE, "Absent svc.startd entry or bad "
+		    "contract template.  Not starting svc.startd.\n");
+		enter_maintenance();
+	}
+}
+
+/*
+ * init_signals(): Initialize all signals to either be caught or ignored.
+ */
+void
+init_signals(void)
+{
+	struct sigaction act;
+	int i;
+
+	/*
+	 * Start by ignoring all signals, then selectively re-enable some.
+	 * The SIG_IGN disposition will only affect asynchronous signals:
+	 * any signal that we trigger synchronously that doesn't end up
+	 * being handled by siglvl() will be forcibly delivered by the kernel.
+	 */
+	for (i = SIGHUP; i <= SIGRTMAX; i++)
+		(void) sigset(i, SIG_IGN);
+
+	/*
+	 * Handle all level-changing signals using siglvl() and set sa_mask so
+	 * that all level-changing signals are blocked while in siglvl().
+	 */
+	act.sa_handler = siglvl;
+	act.sa_flags = SA_SIGINFO;
+	(void) sigemptyset(&act.sa_mask);
+
+	(void) sigaddset(&act.sa_mask, LVLQ);
+	(void) sigaddset(&act.sa_mask, LVL0);
+	(void) sigaddset(&act.sa_mask, LVL1);
+	(void) sigaddset(&act.sa_mask, LVL2);
+	(void) sigaddset(&act.sa_mask, LVL3);
+	(void) sigaddset(&act.sa_mask, LVL4);
+	(void) sigaddset(&act.sa_mask, LVL5);
+	(void) sigaddset(&act.sa_mask, LVL6);
+	(void) sigaddset(&act.sa_mask, SINGLE_USER);
+	(void) sigaddset(&act.sa_mask, LVLa);
+	(void) sigaddset(&act.sa_mask, LVLb);
+	(void) sigaddset(&act.sa_mask, LVLc);
+
+	(void) sigaction(LVLQ, &act, NULL);
+	(void) sigaction(LVL0, &act, NULL);
+	(void) sigaction(LVL1, &act, NULL);
+	(void) sigaction(LVL2, &act, NULL);
+	(void) sigaction(LVL3, &act, NULL);
+	(void) sigaction(LVL4, &act, NULL);
+	(void) sigaction(LVL5, &act, NULL);
+	(void) sigaction(LVL6, &act, NULL);
+	(void) sigaction(SINGLE_USER, &act, NULL);
+	(void) sigaction(LVLa, &act, NULL);
+	(void) sigaction(LVLb, &act, NULL);
+	(void) sigaction(LVLc, &act, NULL);
+
+	(void) sigset(SIGALRM, alarmclk);
+	alarmclk();
+
+	(void) sigset(SIGCLD, childeath);
+	(void) sigset(SIGPWR, powerfail);
+}
+
+/*
+ * Set up pipe for "godchildren". If the file exists and is a pipe just open
+ * it. Else, if the file system is r/w create it.  Otherwise, defer its
+ * creation and open until after /var/run has been mounted.  This function is
+ * only called on startup and when explicitly requested via LVLQ.
+ */
+void
+setup_pipe()
+{
+	struct stat stat_buf;
+	struct statvfs statvfs_buf;
+	struct sigaction act;
+
+	/*
+	 * Always close the previous pipe descriptor as the mounted filesystems
+	 * may have changed.
+	 */
+	if (Pfd >= 0)
+		(void) close(Pfd);
+
+	if ((stat(INITPIPE, &stat_buf) == 0) &&
+	    ((stat_buf.st_mode & (S_IFMT|S_IRUSR)) == (S_IFIFO|S_IRUSR)))
+		Pfd = open(INITPIPE, O_RDWR | O_NDELAY);
+	else
+		if ((statvfs(INITPIPE_DIR, &statvfs_buf) == 0) &&
+		    ((statvfs_buf.f_flag & ST_RDONLY) == 0)) {
+			(void) unlink(INITPIPE);
+			(void) mknod(INITPIPE, S_IFIFO | 0600, 0);
+			Pfd = open(INITPIPE, O_RDWR | O_NDELAY);
+		}
+
+	if (Pfd >= 0) {
+		(void) ioctl(Pfd, I_SETSIG, S_INPUT);
+		/*
+		 * Read pipe in message discard mode.
+		 */
+		(void) ioctl(Pfd, I_SRDOPT, RMSGD);
+
+		act.sa_handler = sigpoll;
+		act.sa_flags = 0;
+		(void) sigemptyset(&act.sa_mask);
+		(void) sigaddset(&act.sa_mask, SIGCLD);
+		(void) sigaction(SIGPOLL, &act, NULL);
+	}
+}
+
+/*
+ * siglvl - handle an asynchronous signal from init(1M) telling us that we
+ * should change the current run level.  We set new_state accordingly.
+ */
+void
+siglvl(int sig, siginfo_t *sip, ucontext_t *ucp)
+{
+	struct PROC_TABLE *process;
+	struct sigaction act;
+
+	/*
+	 * If the signal was from the kernel (rather than init(1M)) then init
+	 * itself tripped the signal.  That is, we might have a bug and tripped
+	 * a real SIGSEGV instead of receiving it as an alias for SIGLVLa.  In
+	 * such a case we reset the disposition to SIG_DFL, block all signals
+	 * in uc_mask but the current one, and return to the interrupted ucp
+	 * to effect an appropriate death.  The kernel will then restart us.
+	 *
+	 * The one exception to SI_FROMKERNEL() is SIGFPE (a.k.a. LVL6), which
+	 * the kernel can send us when it wants to effect an orderly reboot.
+	 * For this case we must also verify si_code is zero, rather than a
+	 * code such as FPE_INTDIV which a bug might have triggered.
+	 */
+	if (sip != NULL && SI_FROMKERNEL(sip) &&
+	    (sig != SIGFPE || sip->si_code == 0)) {
+
+		(void) sigemptyset(&act.sa_mask);
+		act.sa_handler = SIG_DFL;
+		act.sa_flags = 0;
+		(void) sigaction(sig, &act, NULL);
+
+		(void) sigfillset(&ucp->uc_sigmask);
+		(void) sigdelset(&ucp->uc_sigmask, sig);
+		ucp->uc_flags |= UC_SIGMASK;
+
+		(void) setcontext(ucp);
+	}
+
+	/*
+	 * If the signal received is a LVLQ signal, do not really
+	 * change levels, just restate the current level.  If the
+	 * signal is not a LVLQ, set the new level to the signal
+	 * received.
+	 */
+	if (sig == LVLQ) {
+		new_state = cur_state;
+		lvlq_received = B_TRUE;
+	} else {
+		new_state = sig;
+	}
+
+	/*
+	 * Clear all times and repeat counts in the process table
+	 * since either the level is changing or the user has editted
+	 * the inittab file and wants us to look at it again.
+	 * If the user has fixed a typo, we don't want residual timing
+	 * data preventing the fixed command line from executing.
+	 */
+	for (process = proc_table;
+	    (process < proc_table + num_proc); process++) {
+		process->p_time = 0L;
+		process->p_count = 0;
+	}
+
+	/*
+	 * Set the flag to indicate that a "user signal" was received.
+	 */
+	wakeup.w_flags.w_usersignal = 1;
+}
+
+
+/*
+ * alarmclk
+ */
+static void
+alarmclk()
+{
+	time_up = TRUE;
+}
+
+/*
+ * childeath_single():
+ *
+ * This used to be the SIGCLD handler and it was set with signal()
+ * (as opposed to sigset()).  When a child exited we'd come to the
+ * handler, wait for the child, and reenable the handler with
+ * signal() just before returning.  The implementation of signal()
+ * checks with waitid() for waitable children and sends a SIGCLD
+ * if there are some.  If children are exiting faster than the
+ * handler can run we keep sending signals and the handler never
+ * gets to return and eventually the stack runs out and init dies.
+ * To prevent that we set the handler with sigset() so the handler
+ * doesn't need to be reset, and in childeath() (see below) we
+ * call childeath_single() as long as there are children to be
+ * waited for.  If a child exits while init is in the handler a
+ * SIGCLD will be pending and delivered on return from the handler.
+ * If the child was already waited for the handler will have nothing
+ * to do and return, otherwise the child will be waited for.
+ */
+static void
+childeath_single()
+{
+	struct PROC_TABLE	*process;
+	struct pidlist		*pp;
+	pid_t			pid;
+	int			status;
+
+	/*
+	 * Perform wait to get the process id of the child that died and
+	 * then scan the process table to see if we are interested in
+	 * this process. NOTE: if a super-user sends the SIGCLD signal
+	 * to init, the following wait will not immediately return and
+	 * init will be inoperative until one of its child really does die.
+	 */
+	pid = wait(&status);
+
+	for (process = proc_table;
+	    (process < proc_table + num_proc); process++) {
+		if ((process->p_flags & (LIVING|OCCUPIED)) ==
+		    (LIVING|OCCUPIED) && process->p_pid == pid) {
+
+			/*
+			 * Mark this process as having died and store the exit
+			 * status.  Also set the wakeup flag for a dead child
+			 * and break out of the loop.
+			 */
+			process->p_flags &= ~LIVING;
+			process->p_exit = (short)status;
+			wakeup.w_flags.w_childdeath = 1;
+
+			return;
+		}
+	}
+
+	/*
+	 * No process was found above, look through auxiliary list.
+	 */
+	(void) sighold(SIGPOLL);
+	pp = Plhead;
+	while (pp) {
+		if (pid > pp->pl_pid) {
+			/*
+			 * Keep on looking.
+			 */
+			pp = pp->pl_next;
+			continue;
+		} else if (pid < pp->pl_pid) {
+			/*
+			 * Not in the list.
+			 */
+			break;
+		} else {
+			/*
+			 * This is a dead "godchild".
+			 */
+			pp->pl_dflag = 1;
+			pp->pl_exit = (short)status;
+			wakeup.w_flags.w_childdeath = 1;
+			Gchild = 1;	/* Notice to call cleanaux(). */
+			break;
+		}
+	}
+
+	(void) sigrelse(SIGPOLL);
+}
+
+/* ARGSUSED */
+static void
+childeath(int signo)
+{
+	siginfo_t info;
+
+	while ((waitid(P_ALL, (id_t)0, &info, WEXITED|WNOHANG|WNOWAIT) == 0) &&
+	    info.si_pid != 0)
+		childeath_single();
+}
+
+static void
+powerfail()
+{
+	(void) nice(-19);
+	wakeup.w_flags.w_powerhit = 1;
+}
+
+/*
+ * efork() forks a child and the parent inserts the process in its table
+ * of processes that are directly a result of forks that it has performed.
+ * The child just changes the "global" with the process id for this process
+ * to it's new value.
+ * If efork() is called with a pointer into the proc_table it uses that slot,
+ * otherwise it searches for a free slot.  Regardless of how it was called,
+ * it returns the pointer to the proc_table entry
+ *
+ * The SIGCLD handler is set to default (SIG_DFL) before calling efork().
+ * This relies on the somewhat obscure SVR2 SIGCLD/SIG_DFL semantic
+ * implied by the use of signal(3c).  While the meaning of SIG_DFL for
+ * SIGCLD is nominally to ignore the signal, once the signal disposition
+ * is set to childeath(), the kernel will post a SIGCLD if a child
+ * exited during the period the disposition was SIG_DFL.  It acts more
+ * like a signal block.
+ *
+ * Ideally, this should be rewritten to use modern signal semantics.
+ */
+static struct PROC_TABLE *
+efork(int action, struct PROC_TABLE *process, int modes)
+{
+	pid_t	childpid;
+	struct PROC_TABLE *proc;
+	int		i;
+	void (*oldroutine)();
+	/*
+	 * Freshen up the proc_table, removing any entries for dead processes
+	 * that don't have NOCLEANUP set.  Perform the necessary accounting.
+	 */
+	for (proc = proc_table; (proc < proc_table + num_proc); proc++) {
+		if ((proc->p_flags & (OCCUPIED|LIVING|NOCLEANUP)) ==
+		    (OCCUPIED)) {
+			/*
+			 * Is this a named process?
+			 * If so, do the necessary bookkeeping.
+			 */
+			if (proc->p_flags & NAMED)
+				(void) account(DEAD_PROCESS, proc, NULL);
+
+			/*
+			 * Free this entry for new usage.
+			 */
+			proc->p_flags = 0;
+		}
+	}
+
+	while ((childpid = fork()) == FAILURE) {
+		/*
+		 * Shorten the alarm timer in case someone else's child dies
+		 * and free up a slot in the process table.
+		 */
+		setimer(5);
+
+		/*
+		 * Wait for some children to die.  Since efork() is normally
+		 * called with SIGCLD in the default state, reset it to catch
+		 * so that child death signals can come in.
+		 */
+		oldroutine = sigset(SIGCLD, childeath);
+		(void) pause();
+		(void) sigset(SIGCLD, oldroutine);
+		setimer(0);
+	}
+
+	if (childpid != 0) {
+
+		if (process == NULLPROC) {
+			/*
+			 * No proc table pointer specified so search
+			 * for a free slot.
+			 */
+			for (process = proc_table;  process->p_flags != 0 &&
+			    (process < proc_table + num_proc); process++)
+					;
+
+			if (process == (proc_table + num_proc)) {
+				int old_proc_table_size = num_proc;
+
+				/* Increase the process table size */
+				increase_proc_table_size();
+				if (old_proc_table_size == num_proc) {
+					/* didn't grow: memory failure */
+					return (NO_ROOM);
+				} else {
+					process =
+					    proc_table + old_proc_table_size;
+				}
+			}
+
+			process->p_time = 0L;
+			process->p_count = 0;
+		}
+		process->p_id[0] = '\0';
+		process->p_id[1] = '\0';
+		process->p_id[2] = '\0';
+		process->p_id[3] = '\0';
+		process->p_pid = childpid;
+		process->p_flags = (LIVING | OCCUPIED | modes);
+		process->p_exit = 0;
+
+		st_write();
+	} else {
+		if ((action & (M_WAIT | M_BOOTWAIT)) == 0)
+			(void) setpgrp();
+
+		process = NULLPROC;
+
+		/*
+		 * Reset all signals to the system defaults.
+		 */
+		for (i = SIGHUP; i <= SIGRTMAX; i++)
+			(void) sigset(i, SIG_DFL);
+
+		/*
+		 * POSIX B.2.2.2 advises that init should set SIGTTOU,
+		 * SIGTTIN, and SIGTSTP to SIG_IGN.
+		 *
+		 * Make sure that SIGXCPU and SIGXFSZ also remain ignored,
+		 * for backward compatibility.
+		 */
+		(void) sigset(SIGTTIN, SIG_IGN);
+		(void) sigset(SIGTTOU, SIG_IGN);
+		(void) sigset(SIGTSTP, SIG_IGN);
+		(void) sigset(SIGXCPU, SIG_IGN);
+		(void) sigset(SIGXFSZ, SIG_IGN);
+	}
+	return (process);
+}
+
+
+/*
+ * waitproc() waits for a specified process to die.  For this function to
+ * work, the specified process must already in the proc_table.  waitproc()
+ * returns the exit status of the specified process when it dies.
+ */
+static long
+waitproc(struct PROC_TABLE *process)
+{
+	int		answer;
+	sigset_t	oldmask, newmask, zeromask;
+
+	(void) sigemptyset(&zeromask);
+	(void) sigemptyset(&newmask);
+
+	(void) sigaddset(&newmask, SIGCLD);
+
+	/* Block SIGCLD and save the current signal mask */
+	if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
+		perror("SIG_BLOCK error");
+
+	/*
+	 * Wait around until the process dies.
+	 */
+	if (process->p_flags & LIVING)
+		(void) sigsuspend(&zeromask);
+
+	/* Reset signal mask to unblock SIGCLD */
+	if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
+		perror("SIG_SETMASK error");
+
+	if (process->p_flags & LIVING)
+		return (FAILURE);
+
+	/*
+	 * Make sure to only return 16 bits so that answer will always
+	 * be positive whenever the process of interest really died.
+	 */
+	answer = (process->p_exit & 0xffff);
+
+	/*
+	 * Free the slot in the proc_table.
+	 */
+	process->p_flags = 0;
+	return (answer);
+}
+
+/*
+ * notify_pam_dead(): calls into the PAM framework to close the given session.
+ */
+static void
+notify_pam_dead(struct utmpx *up)
+{
+	pam_handle_t *pamh;
+	char user[sizeof (up->ut_user) + 1];
+	char ttyn[sizeof (up->ut_line) + 1];
+	char host[sizeof (up->ut_host) + 1];
+
+	/*
+	 * PAM does not take care of updating utmpx/wtmpx.
+	 */
+	(void) snprintf(user, sizeof (user), "%s", up->ut_user);
+	(void) snprintf(ttyn, sizeof (ttyn), "%s", up->ut_line);
+	(void) snprintf(host, sizeof (host), "%s", up->ut_host);
+
+	if (pam_start("init", user, NULL, &pamh) == PAM_SUCCESS)  {
+		(void) pam_set_item(pamh, PAM_TTY, ttyn);
+		(void) pam_set_item(pamh, PAM_RHOST, host);
+		(void) pam_close_session(pamh, 0);
+		(void) pam_end(pamh, PAM_SUCCESS);
+	}
+}
+
+/*
+ * Check you can access utmpx (As / may be read-only and
+ * /var may not be mounted yet).
+ */
+static int
+access_utmpx(void)
+{
+	do {
+		utmpx_ok = (access(UTMPX, R_OK|W_OK) == 0);
+	} while (!utmpx_ok && errno == EINTR);
+
+	return (utmpx_ok);
+}
+
+/*
+ * account() updates entries in utmpx and appends new entries to the end of
+ * wtmpx (assuming they exist).  The program argument indicates the name of
+ * program if INIT_PROCESS, otherwise should be NULL.
+ *
+ * account() only blocks for INIT_PROCESS requests.
+ *
+ * Returns non-zero if write failed.
+ */
+static int
+account(short state, struct PROC_TABLE *process, char *program)
+{
+	struct utmpx utmpbuf, *u, *oldu;
+	int tmplen;
+	char fail_buf[UT_LINE_SZ];
+	sigset_t block, unblock;
+
+	if (!utmpx_ok && !access_utmpx()) {
+		return (-1);
+	}
+
+	/*
+	 * Set up the prototype for the utmp structure we want to write.
+	 */
+	u = &utmpbuf;
+	(void) memset(u, 0, sizeof (struct utmpx));
+
+	/*
+	 * Fill in the various fields of the utmp structure.
+	 */
+	u->ut_id[0] = process->p_id[0];
+	u->ut_id[1] = process->p_id[1];
+	u->ut_id[2] = process->p_id[2];
+	u->ut_id[3] = process->p_id[3];
+	u->ut_pid = process->p_pid;
+
+	/*
+	 * Fill the "ut_exit" structure.
+	 */
+	u->ut_exit.e_termination = WTERMSIG(process->p_exit);
+	u->ut_exit.e_exit = WEXITSTATUS(process->p_exit);
+	u->ut_type = state;
+
+	(void) time(&u->ut_tv.tv_sec);
+
+	/*
+	 * Block signals for utmp update.
+	 */
+	(void) sigfillset(&block);
+	(void) sigprocmask(SIG_BLOCK, &block, &unblock);
+
+	/*
+	 * See if there already is such an entry in the "utmpx" file.
+	 */
+	setutxent();	/* Start at beginning of utmpx file. */
+
+	if ((oldu = getutxid(u)) != NULL) {
+		/*
+		 * Copy in the old "user", "line" and "host" fields
+		 * to our new structure.
+		 */
+		bcopy(oldu->ut_user, u->ut_user, sizeof (u->ut_user));
+		bcopy(oldu->ut_line, u->ut_line, sizeof (u->ut_line));
+		bcopy(oldu->ut_host, u->ut_host, sizeof (u->ut_host));
+		u->ut_syslen = (tmplen = strlen(u->ut_host)) ?
+		    min(tmplen + 1, sizeof (u->ut_host)) : 0;
+
+		if (oldu->ut_type == USER_PROCESS && state == DEAD_PROCESS) {
+			notify_pam_dead(oldu);
+		}
+	}
+
+	/*
+	 * Perform special accounting. Insert the special string into the
+	 * ut_line array. For INIT_PROCESSes put in the name of the
+	 * program in the "ut_user" field.
+	 */
+	switch (state) {
+	case INIT_PROCESS:
+		(void) strncpy(u->ut_user, program, sizeof (u->ut_user));
+		(void) strcpy(fail_buf, "INIT_PROCESS");
+		break;
+
+	default:
+		(void) strlcpy(fail_buf, u->ut_id, sizeof (u->ut_id) + 1);
+		break;
+	}
+
+	/*
+	 * Write out the updated entry to utmpx file.
+	 */
+	if (pututxline(u) == NULL) {
+		console(B_TRUE, "Failed write of utmpx entry: \"%s\": %s\n",
+		    fail_buf, strerror(errno));
+		endutxent();
+		(void) sigprocmask(SIG_SETMASK, &unblock, NULL);
+		return (-1);
+	}
+
+	/*
+	 * If we're able to write to utmpx, then attempt to add to the
+	 * end of the wtmpx file.
+	 */
+	updwtmpx(WTMPX, u);
+
+	endutxent();
+
+	(void) sigprocmask(SIG_SETMASK, &unblock, NULL);
+
+	return (0);
+}
+
+static void
+clearent(pid_t pid, short status)
+{
+	struct utmpx *up;
+	sigset_t block, unblock;
+
+	/*
+	 * Block signals for utmp update.
+	 */
+	(void) sigfillset(&block);
+	(void) sigprocmask(SIG_BLOCK, &block, &unblock);
+
+	/*
+	 * No error checking for now.
+	 */
+
+	setutxent();
+	while (up = getutxent()) {
+		if (up->ut_pid == pid) {
+			if (up->ut_type == DEAD_PROCESS) {
+				/*
+				 * Cleaned up elsewhere.
+				 */
+				continue;
+			}
+
+			notify_pam_dead(up);
+
+			up->ut_type = DEAD_PROCESS;
+			up->ut_exit.e_termination = WTERMSIG(status);
+			up->ut_exit.e_exit = WEXITSTATUS(status);
+			(void) time(&up->ut_tv.tv_sec);
+
+			(void) pututxline(up);
+			/*
+			 * Now attempt to add to the end of the
+			 * wtmp and wtmpx files.  Do not create
+			 * if they don't already exist.
+			 */
+			updwtmpx(WTMPX, up);
+
+			break;
+		}
+	}
+
+	endutxent();
+	(void) sigprocmask(SIG_SETMASK, &unblock, NULL);
+}
+
+/*
+ * prog_name() searches for the word or unix path name and
+ * returns a pointer to the last element of the pathname.
+ */
+static char *
+prog_name(char *string)
+{
+	char	*ptr, *ptr2;
+	/* XXX - utmp - fix name length */
+	static char word[_POSIX_LOGIN_NAME_MAX];
+
+	/*
+	 * Search for the first word skipping leading spaces and tabs.
+	 */
+	while (*string == ' ' || *string == '\t')
+		string++;
+
+	/*
+	 * If the first non-space non-tab character is not one allowed in
+	 * a word, return a pointer to a null string, otherwise parse the
+	 * pathname.
+	 */
+	if (*string != '.' && *string != '/' && *string != '_' &&
+	    (*string < 'a' || *string > 'z') &&
+	    (*string < 'A' || * string > 'Z') &&
+	    (*string < '0' || *string > '9'))
+		return ("");
+
+	/*
+	 * Parse the pathname looking forward for '/', ' ', '\t', '\n' or
+	 * '\0'.  Each time a '/' is found, move "ptr" to one past the
+	 * '/', thus when a ' ', '\t', '\n', or '\0' is found, "ptr" will
+	 * point to the last element of the pathname.
+	 */
+	for (ptr = string; *string != ' ' && *string != '\t' && 
+	    *string != '\n' && *string != '\0'; string++) {
+		if (*string == '/')
+			ptr = string+1;
+	}
+
+	/*
+	 * Copy out up to the size of the "ut_user" array into "word",
+	 * null terminate it and return a pointer to it.
+	 */
+	/* XXX - utmp - fix name length */
+	for (ptr2 = &word[0]; ptr2 < &word[_POSIX_LOGIN_NAME_MAX - 1] &&
+	    ptr < string; /* CSTYLED */)
+		*ptr2++ = *ptr++;
+
+	*ptr2 = '\0';
+	return (&word[0]);
+}
+
+
+/*
+ * realcon() returns a nonzero value if there is a character device
+ * associated with SYSCON that has the same device number as CONSOLE.
+ */
+static int
+realcon()
+{
+	struct stat sconbuf, conbuf;
+
+	if (stat(SYSCON, &sconbuf) != -1 &&
+	    stat(CONSOLE, &conbuf) != -1 &&
+	    S_ISCHR(sconbuf.st_mode) &&
+	    S_ISCHR(conbuf.st_mode) &&
+	    sconbuf.st_rdev == conbuf.st_rdev) {
+		return (1);
+	} else {
+		return (0);
+	}
+}
+
+
+/*
+ * get_ioctl_syscon() retrieves the SYSCON settings from the IOCTLSYSCON file.
+ * Returns true if the IOCTLSYSCON file needs to be written (with
+ * write_ioctl_syscon() below)
+ */
+static int
+get_ioctl_syscon()
+{
+	FILE	*fp;
+	unsigned int	iflags, oflags, cflags, lflags, ldisc, cc[18];
+	int		i, valid_format = 0;
+
+	/*
+	 * Read in the previous modes for SYSCON from IOCTLSYSCON.
+	 */
+	if ((fp = fopen(IOCTLSYSCON, "r")) == NULL) {
+		stored_syscon_termios = dflt_termios;
+		console(B_TRUE,
+		    "warning:%s does not exist, default settings assumed\n",
+		    IOCTLSYSCON);
+	} else {
+
+	    i = fscanf(fp,
+	    "%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x",
+		&iflags, &oflags, &cflags, &lflags,
+		&cc[0], &cc[1], &cc[2], &cc[3], &cc[4], &cc[5], &cc[6],
+		&cc[7], &cc[8], &cc[9], &cc[10], &cc[11], &cc[12], &cc[13],
+		&cc[14], &cc[15], &cc[16], &cc[17]);
+
+	    if (i == 22) {
+		stored_syscon_termios.c_iflag = iflags;
+		stored_syscon_termios.c_oflag = oflags;
+		stored_syscon_termios.c_cflag = cflags;
+		stored_syscon_termios.c_lflag = lflags;
+		for (i = 0; i < 18; i++)
+			stored_syscon_termios.c_cc[i] = (char)cc[i];
+		valid_format = 1;
+	    } else if (i == 13) {
+		rewind(fp);
+		i = fscanf(fp, "%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x:%x",
+		    &iflags, &oflags, &cflags, &lflags, &ldisc, &cc[0], &cc[1],
+		    &cc[2], &cc[3], &cc[4], &cc[5], &cc[6], &cc[7]);
+
+		/*
+		 * If the file is formatted properly, use the values to
+		 * initialize the console terminal condition.
+		 */
+		stored_syscon_termios.c_iflag = (ushort_t)iflags;
+		stored_syscon_termios.c_oflag = (ushort_t)oflags;
+		stored_syscon_termios.c_cflag = (ushort_t)cflags;
+		stored_syscon_termios.c_lflag = (ushort_t)lflags;
+		for (i = 0; i < 8; i++)
+			stored_syscon_termios.c_cc[i] = (char)cc[i];
+		valid_format = 1;
+	    }
+	    (void) fclose(fp);
+
+	    /* If the file is badly formatted, use the default settings. */
+	    if (!valid_format)
+		stored_syscon_termios = dflt_termios;
+	}
+
+	/* If the file had a bad format, rewrite it later. */
+	return (!valid_format);
+}
+
+
+static void
+write_ioctl_syscon()
+{
+	FILE *fp;
+	int i;
+
+	(void) unlink(SYSCON);
+	(void) link(SYSTTY, SYSCON);
+	(void) umask(022);
+	fp = fopen(IOCTLSYSCON, "w");
+
+	(void) fprintf(fp, "%x:%x:%x:%x:0", stored_syscon_termios.c_iflag,
+	    stored_syscon_termios.c_oflag, stored_syscon_termios.c_cflag,
+	    stored_syscon_termios.c_lflag);
+	for (i = 0; i < 8; ++i)
+		(void) fprintf(fp, ":%x", stored_syscon_termios.c_cc[i]);
+	(void) putc('\n', fp);
+
+	(void) fflush(fp);
+	(void) fsync(fileno(fp));
+	(void) fclose(fp);
+	(void) umask(cmask);
+}
+
+
+/*
+ * void console(boolean_t, char *, ...)
+ *   Outputs the requested message to the system console.  Note that the number
+ *   of arguments passed to console() should be determined by the print format.
+ *
+ *   The "prefix" parameter indicates whether or not "INIT: " should precede the
+ *   message.
+ *
+ *   To make sure we write to the console in a sane fashion, we use the modes
+ *   we keep in stored_syscon_termios (which we read out of /etc/ioctl.syscon).
+ *   Afterwards we restore whatever modes were already there.
+ */
+/* PRINTFLIKE2 */
+static void
+console(boolean_t prefix, char *format, ...)
+{
+	char	outbuf[BUFSIZ];
+	va_list	args;
+	int fd, getret;
+	struct termios old_syscon_termios;
+	FILE *f;
+
+	/*
+	 * We open SYSCON anew each time in case it has changed (see
+	 * userinit()).
+	 */
+	if ((fd = open(SYSCON, O_RDWR | O_NOCTTY)) < 0 ||
+	    (f = fdopen(fd, "r+")) == NULL) {
+		if (prefix)
+			syslog(LOG_WARNING, "INIT: ");
+		va_start(args, format);
+		vsyslog(LOG_WARNING, format, args);
+		va_end(args);
+		if (fd >= 0)
+			(void) close(fd);
+		return;
+	}
+	setbuf(f, &outbuf[0]);
+
+	getret = tcgetattr(fd, &old_syscon_termios);
+	old_syscon_termios.c_cflag &= ~HUPCL;
+	if (realcon())
+		/* Don't overwrite cflag of real console. */
+		stored_syscon_termios.c_cflag = old_syscon_termios.c_cflag;
+
+	stored_syscon_termios.c_cflag &= ~HUPCL;
+
+	(void) tcsetattr(fd, TCSANOW, &stored_syscon_termios);
+
+	if (prefix)
+		(void) fprintf(f, "\nINIT: ");
+	va_start(args, format);
+	(void) vfprintf(f, format, args);
+	va_end(args);
+
+	if (getret == 0)
+		(void) tcsetattr(fd, TCSADRAIN, &old_syscon_termios);
+
+	(void) fclose(f);
+}
+
+/*
+ * timer() is a substitute for sleep() which uses alarm() and pause().
+ */
+static void
+timer(int waitime)
+{
+	setimer(waitime);
+	while (time_up == FALSE)
+		(void) pause();
+}
+
+static void
+setimer(int timelimit)
+{
+	alarmclk();
+	(void) alarm(timelimit);
+	time_up = (timelimit ? FALSE : TRUE);
+}
+
+/*
+ * Fails with
+ *   ENOMEM - out of memory
+ *   ECONNABORTED - repository connection broken
+ *   EPERM - permission denied
+ *   EACCES - backend access denied
+ *   EROFS - backend readonly
+ */
+static int
+get_or_add_startd(scf_instance_t *inst)
+{
+	scf_handle_t *h;
+	scf_scope_t *scope = NULL;
+	scf_service_t *svc = NULL;
+	int ret = 0;
+
+	h = scf_instance_handle(inst);
+
+	if (scf_handle_decode_fmri(h, SCF_SERVICE_STARTD, NULL, NULL, inst,
+	    NULL, NULL, SCF_DECODE_FMRI_EXACT) == 0)
+		return (0);
+
+	switch (scf_error()) {
+	case SCF_ERROR_CONNECTION_BROKEN:
+		return (ECONNABORTED);
+
+	case SCF_ERROR_NOT_FOUND:
+		break;
+
+	case SCF_ERROR_HANDLE_MISMATCH:
+	case SCF_ERROR_INVALID_ARGUMENT:
+	case SCF_ERROR_CONSTRAINT_VIOLATED:
+	default:
+		bad_error("scf_handle_decode_fmri", scf_error());
+	}
+
+	/* Make sure we're right, since we're adding piece-by-piece. */
+	assert(strcmp(SCF_SERVICE_STARTD,
+	    "svc:/system/svc/restarter:default") == 0);
+
+	if ((scope = scf_scope_create(h)) == NULL ||
+	    (svc = scf_service_create(h)) == NULL) {
+		ret = ENOMEM;
+		goto out;
+	}
+
+get_scope:
+	if (scf_handle_get_scope(h, SCF_SCOPE_LOCAL, scope) != 0) {
+		switch (scf_error()) {
+		case SCF_ERROR_CONNECTION_BROKEN:
+			ret = ECONNABORTED;
+			goto out;
+
+		case SCF_ERROR_NOT_FOUND:
+			(void) fputs(gettext(
+			    "smf(5) repository missing local scope.\n"),
+			    stderr);
+			exit(1);
+			/* NOTREACHED */
+
+		case SCF_ERROR_HANDLE_MISMATCH:
+		case SCF_ERROR_INVALID_ARGUMENT:
+		default:
+			bad_error("scf_handle_get_scope", scf_error());
+		}
+	}
+
+get_svc:
+	if (scf_scope_get_service(scope, "system/svc/restarter", svc) != 0) {
+		switch (scf_error()) {
+		case SCF_ERROR_CONNECTION_BROKEN:
+			ret = ECONNABORTED;
+			goto out;
+
+		case SCF_ERROR_DELETED:
+			goto get_scope;
+
+		case SCF_ERROR_NOT_FOUND:
+			break;
+
+		case SCF_ERROR_HANDLE_MISMATCH:
+		case SCF_ERROR_INVALID_ARGUMENT:
+		case SCF_ERROR_NOT_SET:
+		default:
+			bad_error("scf_scope_get_service", scf_error());
+		}
+
+add_svc:
+		if (scf_scope_add_service(scope, "system/svc/restarter", svc) !=
+		    0) {
+			switch (scf_error()) {
+			case SCF_ERROR_CONNECTION_BROKEN:
+				ret = ECONNABORTED;
+				goto out;
+
+			case SCF_ERROR_EXISTS:
+				goto get_svc;
+
+			case SCF_ERROR_PERMISSION_DENIED:
+				ret = EPERM;
+				goto out;
+
+			case SCF_ERROR_BACKEND_ACCESS:
+				ret = EACCES;
+				goto out;
+
+			case SCF_ERROR_BACKEND_READONLY:
+				ret = EROFS;
+				goto out;
+
+			case SCF_ERROR_HANDLE_MISMATCH:
+			case SCF_ERROR_INVALID_ARGUMENT:
+			case SCF_ERROR_NOT_SET:
+			default:
+				bad_error("scf_scope_add_service", scf_error());
+			}
+		}
+	}
+
+get_inst:
+	if (scf_service_get_instance(svc, "default", inst) != 0) {
+		switch (scf_error()) {
+		case SCF_ERROR_CONNECTION_BROKEN:
+			ret = ECONNABORTED;
+			goto out;
+
+		case SCF_ERROR_DELETED:
+			goto add_svc;
+
+		case SCF_ERROR_NOT_FOUND:
+			break;
+
+		case SCF_ERROR_HANDLE_MISMATCH:
+		case SCF_ERROR_INVALID_ARGUMENT:
+		case SCF_ERROR_NOT_SET:
+		default:
+			bad_error("scf_service_get_instance", scf_error());
+		}
+
+		if (scf_service_add_instance(svc, "default", inst) !=
+		    0) {
+			switch (scf_error()) {
+			case SCF_ERROR_CONNECTION_BROKEN:
+				ret = ECONNABORTED;
+				goto out;
+
+			case SCF_ERROR_DELETED:
+				goto add_svc;
+
+			case SCF_ERROR_EXISTS:
+				goto get_inst;
+
+			case SCF_ERROR_PERMISSION_DENIED:
+				ret = EPERM;
+				goto out;
+
+			case SCF_ERROR_BACKEND_ACCESS:
+				ret = EACCES;
+				goto out;
+
+			case SCF_ERROR_BACKEND_READONLY:
+				ret = EROFS;
+				goto out;
+
+			case SCF_ERROR_HANDLE_MISMATCH:
+			case SCF_ERROR_INVALID_ARGUMENT:
+			case SCF_ERROR_NOT_SET:
+			default:
+				bad_error("scf_service_add_instance",
+				    scf_error());
+			}
+		}
+	}
+
+	ret = 0;
+
+out:
+	scf_service_destroy(svc);
+	scf_scope_destroy(scope);
+	return (ret);
+}
+
+/*
+ * Fails with
+ *   ECONNABORTED - repository connection broken
+ *   ECANCELED - the transaction's property group was deleted
+ */
+static int
+transaction_add_set(scf_transaction_t *tx, scf_transaction_entry_t *ent,
+    const char *pname, scf_type_t type)
+{
+change_type:
+	if (scf_transaction_property_change_type(tx, ent, pname, type) == 0)
+		return (0);
+
+	switch (scf_error()) {
+	case SCF_ERROR_CONNECTION_BROKEN:
+		return (ECONNABORTED);
+
+	case SCF_ERROR_DELETED:
+		return (ECANCELED);
+
+	case SCF_ERROR_NOT_FOUND:
+		goto new;
+
+	case SCF_ERROR_HANDLE_MISMATCH:
+	case SCF_ERROR_INVALID_ARGUMENT:
+	case SCF_ERROR_NOT_BOUND:
+	case SCF_ERROR_NOT_SET:
+	default:
+		bad_error("scf_transaction_property_change_type", scf_error());
+	}
+
+new:
+	if (scf_transaction_property_new(tx, ent, pname, type) == 0)
+		return (0);
+
+	switch (scf_error()) {
+	case SCF_ERROR_CONNECTION_BROKEN:
+		return (ECONNABORTED);
+
+	case SCF_ERROR_DELETED:
+		return (ECANCELED);
+
+	case SCF_ERROR_EXISTS:
+		goto change_type;
+
+	case SCF_ERROR_HANDLE_MISMATCH:
+	case SCF_ERROR_INVALID_ARGUMENT:
+	case SCF_ERROR_NOT_BOUND:
+	case SCF_ERROR_NOT_SET:
+	default:
+		bad_error("scf_transaction_property_new", scf_error());
+		/* NOTREACHED */
+	}
+}
+
+static void
+scferr(void)
+{
+	switch (scf_error()) {
+	case SCF_ERROR_NO_MEMORY:
+		console(B_TRUE, gettext("Out of memory.\n"));
+		break;
+
+	case SCF_ERROR_CONNECTION_BROKEN:
+		console(B_TRUE, gettext(
+		    "Connection to smf(5) repository server broken.\n"));
+		break;
+
+	case SCF_ERROR_NO_RESOURCES:
+		console(B_TRUE, gettext(
+		    "smf(5) repository server is out of memory.\n"));
+		break;
+
+	case SCF_ERROR_PERMISSION_DENIED:
+		console(B_TRUE, gettext("Insufficient privileges.\n"));
+		break;
+
+	default:
+		console(B_TRUE, gettext("libscf error: %s\n"),
+		    scf_strerror(scf_error()));
+	}
+}
+
+static void
+lscf_set_runlevel(char rl)
+{
+	scf_handle_t *h;
+	scf_instance_t *inst = NULL;
+	scf_propertygroup_t *pg = NULL;
+	scf_transaction_t *tx = NULL;
+	scf_transaction_entry_t *ent = NULL;
+	scf_value_t *val = NULL;
+	char buf[2];
+	int r;
+
+	h = scf_handle_create(SCF_VERSION);
+	if (h == NULL) {
+		scferr();
+		return;
+	}
+
+	if (scf_handle_bind(h) != 0) {
+		switch (scf_error()) {
+		case SCF_ERROR_NO_SERVER:
+			console(B_TRUE,
+			    gettext("smf(5) repository server not running.\n"));
+			goto bail;
+
+		default:
+			scferr();
+			goto bail;
+		}
+	}
+
+	if ((inst = scf_instance_create(h)) == NULL ||
+	    (pg = scf_pg_create(h)) == NULL ||
+	    (val = scf_value_create(h)) == NULL ||
+	    (tx = scf_transaction_create(h)) == NULL ||
+	    (ent = scf_entry_create(h)) == NULL) {
+		scferr();
+		goto bail;
+	}
+
+get_inst:
+	r = get_or_add_startd(inst);
+	switch (r) {
+	case 0:
+		break;
+
+	case ENOMEM:
+	case ECONNABORTED:
+	case EPERM:
+	case EACCES:
+	case EROFS:
+		scferr();
+		goto bail;
+	default:
+		bad_error("get_or_add_startd", r);
+	}
+
+get_pg:
+	if (scf_instance_get_pg(inst, SCF_PG_OPTIONS_OVR, pg) != 0) {
+		switch (scf_error()) {
+		case SCF_ERROR_CONNECTION_BROKEN:
+			scferr();
+			goto bail;
+
+		case SCF_ERROR_DELETED:
+			goto get_inst;
+
+		case SCF_ERROR_NOT_FOUND:
+			break;
+
+		case SCF_ERROR_HANDLE_MISMATCH:
+		case SCF_ERROR_INVALID_ARGUMENT:
+		case SCF_ERROR_NOT_SET:
+		default:
+			bad_error("scf_instance_get_pg", scf_error());
+		}
+
+add_pg:
+		if (scf_instance_add_pg(inst, SCF_PG_OPTIONS_OVR,
+		    SCF_PG_OPTIONS_OVR_TYPE, SCF_PG_OPTIONS_OVR_FLAGS, pg) !=
+		    0) {
+			switch (scf_error()) {
+			case SCF_ERROR_CONNECTION_BROKEN:
+			case SCF_ERROR_PERMISSION_DENIED:
+			case SCF_ERROR_BACKEND_ACCESS:
+				scferr();
+				goto bail;
+
+			case SCF_ERROR_DELETED:
+				goto get_inst;
+
+			case SCF_ERROR_EXISTS:
+				goto get_pg;
+
+			case SCF_ERROR_HANDLE_MISMATCH:
+			case SCF_ERROR_INVALID_ARGUMENT:
+			case SCF_ERROR_NOT_SET:
+			default:
+				bad_error("scf_instance_add_pg", scf_error());
+			}
+		}
+	}
+
+	buf[0] = rl;
+	buf[1] = '\0';
+	r = scf_value_set_astring(val, buf);
+	assert(r == 0);
+
+	for (;;) {
+		if (scf_transaction_start(tx, pg) != 0) {
+			switch (scf_error()) {
+			case SCF_ERROR_CONNECTION_BROKEN:
+			case SCF_ERROR_PERMISSION_DENIED:
+			case SCF_ERROR_BACKEND_ACCESS:
+				scferr();
+				goto bail;
+
+			case SCF_ERROR_DELETED:
+				goto add_pg;
+
+			case SCF_ERROR_HANDLE_MISMATCH:
+			case SCF_ERROR_NOT_BOUND:
+			case SCF_ERROR_IN_USE:
+			case SCF_ERROR_NOT_SET:
+			default:
+				bad_error("scf_transaction_start", scf_error());
+			}
+		}
+
+		r = transaction_add_set(tx, ent, "runlevel", SCF_TYPE_ASTRING);
+		switch (r) {
+		case 0:
+			break;
+
+		case ECONNABORTED:
+			scferr();
+			goto bail;
+
+		case ECANCELED:
+			scf_transaction_reset(tx);
+			goto add_pg;
+
+		default:
+			bad_error("transaction_add_set", r);
+		}
+
+		r = scf_entry_add_value(ent, val);
+		assert(r == 0);
+
+		r = scf_transaction_commit(tx);
+		if (r == 1)
+			break;
+
+		if (r != 0) {
+			switch (scf_error()) {
+			case SCF_ERROR_CONNECTION_BROKEN:
+			case SCF_ERROR_PERMISSION_DENIED:
+			case SCF_ERROR_BACKEND_ACCESS:
+			case SCF_ERROR_BACKEND_READONLY:
+				scferr();
+				goto bail;
+
+			case SCF_ERROR_DELETED:
+				scf_transaction_reset(tx);
+				goto add_pg;
+
+			case SCF_ERROR_INVALID_ARGUMENT:
+			case SCF_ERROR_NOT_BOUND:
+			case SCF_ERROR_NOT_SET:
+			default:
+				bad_error("scf_transaction_commit",
+				    scf_error());
+			}
+		}
+
+		scf_transaction_reset(tx);
+		(void) scf_pg_update(pg);
+	}
+
+bail:
+	scf_transaction_destroy(tx);
+	scf_entry_destroy(ent);
+	scf_value_destroy(val);
+	scf_pg_destroy(pg);
+	scf_instance_destroy(inst);
+
+	(void) scf_handle_unbind(h);
+	scf_handle_destroy(h);
+}
+
+/*
+ * Function to handle requests from users to main init running as process 1.
+ */
+static void
+userinit(int argc, char **argv)
+{
+	FILE	*fp;
+	char	*ln;
+	int	init_signal;
+	struct stat	sconbuf, conbuf;
+	const char *usage_msg = "Usage: init [0123456SsQqabc]\n";
+
+	/*
+	 * We are a user invoked init.  Is there an argument and is it
+	 * a single character?  If not, print usage message and quit.
+	 */
+	if (argc != 2 || argv[1][1] != '\0') {
+		(void) fprintf(stderr, usage_msg);
+		exit(0);
+	}
+
+	if ((init_signal = lvlname_to_state((char)argv[1][0])) == -1) {
+		(void) fprintf(stderr, usage_msg);
+		(void) audit_put_record(ADT_FAILURE, ADT_FAIL_VALUE_BAD_CMD,
+		    argv[1]);
+		exit(1);
+	}
+
+	if (init_signal == SINGLE_USER) {
+		/*
+		 * Make sure this process is talking to a legal tty line
+		 * and that /dev/syscon is linked to this line.
+		 */
+		ln = ttyname(0);	/* Get the name of tty */
+		if (ln == NULL) {
+			(void) fprintf(stderr,
+			    "Standard input not a tty line\n");
+			(void) audit_put_record(ADT_FAILURE,
+			    ADT_FAIL_VALUE_BAD_TTY, argv[1]);
+			exit(1);
+		}
+
+		if ((stat(ln, &sconbuf) != -1) &&
+		    (stat(SYSCON, &conbuf) == -1 ||
+		    sconbuf.st_rdev != conbuf.st_rdev)) {
+			/*
+			 * /dev/syscon needs to change.
+			 * Unlink /dev/syscon and relink it to the current line.
+			 */
+			if (lstat(SYSCON, &conbuf) != -1 &&
+			    unlink(SYSCON) == FAILURE) {
+				perror("Can't unlink /dev/syscon");
+				(void) fprintf(stderr,
+				    "Run command on the system console.\n");
+				(void) audit_put_record(ADT_FAILURE,
+				    ADT_FAIL_VALUE_PROGRAM, argv[1]);
+				exit(1);
+			}
+			if (symlink(ln, SYSCON) == FAILURE) {
+				(void) fprintf(stderr,
+				    "Can't symlink /dev/syscon to %s: %s", ln,
+				    strerror(errno));
+
+				/* Try to leave a syscon */
+				(void) link(SYSTTY, SYSCON);
+				(void) audit_put_record(ADT_FAILURE,
+				    ADT_FAIL_VALUE_PROGRAM, argv[1]);
+				exit(1);
+			}
+
+			/*
+			 * Try to leave a message on system console saying where
+			 * /dev/syscon is currently connected.
+			 */
+			if ((fp = fopen(SYSTTY, "r+")) != NULL) {
+				(void) fprintf(fp,
+				    "\n****	SYSCON CHANGED TO %s	****\n",
+				    ln);
+				(void) fclose(fp);
+			}
+		}
+	}
+
+	update_boot_archive(init_signal);
+
+	(void) audit_put_record(ADT_SUCCESS, ADT_SUCCESS, argv[1]);
+
+	/*
+	 * Signal init; init will take care of telling svc.startd.
+	 */
+	if (kill(init_pid, init_signal) == FAILURE) {
+		(void) fprintf(stderr, "Must be super-user\n");
+		(void) audit_put_record(ADT_FAILURE,
+		    ADT_FAIL_VALUE_AUTH, argv[1]);
+		exit(1);
+	}
+
+	exit(0);
+}
+
+
+#define	DELTA	25	/* Number of pidlist elements to allocate at a time */
+
+/* ARGSUSED */
+void
+sigpoll(int n)
+{
+	struct pidrec prec;
+	struct pidrec *p = &prec;
+	struct pidlist *plp;
+	struct pidlist *tp, *savetp;
+	int i;
+
+	if (Pfd < 0) {
+		return;
+	}
+
+	for (;;) {
+		/*
+		 * Important Note: Either read will really fail (in which case
+		 * return is all we can do) or will get EAGAIN (Pfd was opened
+		 * O_NDELAY), in which case we also want to return.
+		 * Always return from here!
+		 */
+		if (read(Pfd, p, sizeof (struct pidrec)) !=
+						sizeof (struct pidrec)) {
+			return;
+		}
+		switch (p->pd_type) {
+
+		case ADDPID:
+			/*
+			 * New "godchild", add to list.
+			 */
+			if (Plfree == NULL) {
+				plp = (struct pidlist *)calloc(DELTA,
+				    sizeof (struct pidlist));
+				if (plp == NULL) {
+					/* Can't save pid */
+					break;
+				}
+				/*
+				 * Point at 2nd record allocated, we'll use plp.
+				 */
+				tp = plp + 1;
+				/*
+				 * Link them into a chain.
+				 */
+				Plfree = tp;
+				for (i = 0; i < DELTA - 2; i++) {
+					tp->pl_next = tp + 1;
+					tp++;
+				}
+			} else {
+				plp = Plfree;
+				Plfree = plp->pl_next;
+			}
+			plp->pl_pid = p->pd_pid;
+			plp->pl_dflag = 0;
+			plp->pl_next = NULL;
+			/*
+			 * Note - pid list is kept in increasing order of pids.
+			 */
+			if (Plhead == NULL) {
+				Plhead = plp;
+				/* Back up to read next record */
+				break;
+			} else {
+				savetp = tp = Plhead;
+				while (tp) {
+					if (plp->pl_pid > tp->pl_pid) {
+						savetp = tp;
+						tp = tp->pl_next;
+						continue;
+					} else if (plp->pl_pid < tp->pl_pid) {
+						if (tp == Plhead) {
+							plp->pl_next = Plhead;
+							Plhead = plp;
+						} else {
+							plp->pl_next =
+							    savetp->pl_next;
+							savetp->pl_next = plp;
+						}
+						break;
+					} else {
+						/* Already in list! */
+						plp->pl_next = Plfree;
+						Plfree = plp;
+						break;
+					}
+				}
+				if (tp == NULL) {
+					/* Add to end of list */
+					savetp->pl_next = plp;
+				}
+			}
+			/* Back up to read next record. */
+			break;
+
+		case REMPID:
+			/*
+			 * This one was handled by someone else,
+			 * purge it from the list.
+			 */
+			if (Plhead == NULL) {
+				/* Back up to read next record. */
+				break;
+			}
+			savetp = tp = Plhead;
+			while (tp) {
+				if (p->pd_pid > tp->pl_pid) {
+					/* Keep on looking. */
+					savetp = tp;
+					tp = tp->pl_next;
+					continue;
+				} else if (p->pd_pid < tp->pl_pid) {
+					/* Not in list. */
+					break;
+				} else {
+					/* Found it. */
+					if (tp == Plhead)
+						Plhead = tp->pl_next;
+					else
+						savetp->pl_next = tp->pl_next;
+					tp->pl_next = Plfree;
+					Plfree = tp;
+					break;
+				}
+			}
+			/* Back up to read next record. */
+			break;
+		default:
+			console(B_TRUE, "Bad message on initpipe\n");
+			break;
+		}
+	}
+}
 
-#ifdef CONFIG_SYSLOGD
-# include <sys/syslog.h>
-#endif
 
+static void
+cleanaux()
+{
+	struct pidlist *savep, *p;
+	pid_t	pid;
+	short	status;
+
+	(void) sigset(SIGCLD, SIG_DFL);
+	Gchild = 0;	/* Note - Safe to do this here since no SIGCLDs */
+	(void) sighold(SIGPOLL);
+	savep = p = Plhead;
+	while (p) {
+		if (p->pl_dflag) {
+			/*
+			 * Found an entry to delete,
+			 * remove it from list first.
+			 */
+			pid = p->pl_pid;
+			status = p->pl_exit;
+			if (p == Plhead) {
+				Plhead = p->pl_next;
+				p->pl_next = Plfree;
+				Plfree = p;
+				savep = p = Plhead;
+			} else {
+				savep->pl_next = p->pl_next;
+				p->pl_next = Plfree;
+				Plfree = p;
+				p = savep->pl_next;
+			}
+			clearent(pid, status);
+			continue;
+		}
+		savep = p;
+		p = p->pl_next;
+	}
+	(void) sigrelse(SIGPOLL);
+	(void) sigset(SIGCLD, childeath);
+}
 
-#ifdef CONFIG_SELINUX
-# include <selinux/selinux.h>
-#endif /* CONFIG_SELINUX */
 
+/*
+ * /etc/inittab has more entries and we have run out of room in the proc_table
+ * array. Double the size of proc_table to accomodate the extra entries.
+ */
+static void
+increase_proc_table_size()
+{
+	sigset_t block, unblock;
+	void *ptr;
+	size_t delta = num_proc * sizeof (struct PROC_TABLE);
+
+
+	/*
+	 * Block signals for realloc.
+	 */
+	(void) sigfillset(&block);
+	(void) sigprocmask(SIG_BLOCK, &block, &unblock);
+
+
+	/*
+	 * On failure we just return because callers of this function check
+	 * for failure.
+	 */
+	do
+		ptr = realloc(g_state, g_state_sz + delta);
+	while (ptr == NULL && errno == EAGAIN);
+
+	if (ptr != NULL) {
+		/* ensure that the new part is initialized to zero */
+		bzero((caddr_t)ptr + g_state_sz, delta);
+
+		g_state = ptr;
+		g_state_sz += delta;
+		num_proc <<= 1;
+	}
 
-#define INIT_BUFFS_SIZE 256
-
-/* From <linux/vt.h> */
-struct vt_stat {
-	unsigned short v_active;	/* active vt */
-	unsigned short v_signal;	/* signal to send */
-	unsigned short v_state;	/* vt bitmask */
-};
-enum { VT_GETSTATE = 0x5603 };	/* get global vt state info */
 
-/* From <linux/serial.h> */
-struct serial_struct {
-	int	type;
-	int	line;
-	unsigned int	port;
-	int	irq;
-	int	flags;
-	int	xmit_fifo_size;
-	int	custom_divisor;
-	int	baud_base;
-	unsigned short	close_delay;
-	char	io_type;
-	char	reserved_char[1];
-	int	hub6;
-	unsigned short	closing_wait; /* time to wait before closing */
-	unsigned short	closing_wait2; /* no longer used... */
-	unsigned char	*iomem_base;
-	unsigned short	iomem_reg_shift;
-	unsigned int	port_high;
-	unsigned long	iomap_base;	/* cookie passed into ioremap */
-	int	reserved[1];
-};
+	/* unblock our signals before returning */
+	(void) sigprocmask(SIG_SETMASK, &unblock, NULL);
+}
 
 
-#ifndef _PATH_STDPATH
-#define _PATH_STDPATH	"/usr/bin:/bin:/usr/sbin:/sbin"
-#endif
 
-#if defined CONFIG_FEATURE_INIT_COREDUMPS
 /*
- * When a file named CORE_ENABLE_FLAG_FILE exists, setrlimit is called
- * before processes are spawned to set core file size as unlimited.
- * This is for debugging only.  Don't use this is production, unless
- * you want core dumps lying about....
+ * Sanity check g_state.
  */
-#define CORE_ENABLE_FLAG_FILE "/.init_enable_core"
-#include <sys/resource.h>
-#endif
-
-#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
-
-#define INITTAB      "/etc/inittab"	/* inittab file location */
-#ifndef INIT_SCRIPT
-#define INIT_SCRIPT  "/etc/init.d/rcS"	/* Default sysinit script. */
-#endif
+static int
+st_sane()
+{
+	int i;
+	struct PROC_TABLE *ptp;
 
-#define MAXENV	16		/* Number of env. vars */
 
-#define CONSOLE_BUFF_SIZE 32
+	/* Note: cur_state is encoded as a signal number */
+	if (cur_state < 1 || cur_state == 9 || cur_state > 13)
+		return (0);
+
+	/* Check num_proc */
+	if (g_state_sz != sizeof (struct init_state) + (num_proc - 1) *
+	    sizeof (struct PROC_TABLE))
+		return (0);
+
+	/* Check proc_table */
+	for (i = 0, ptp = proc_table; i < num_proc; ++i, ++ptp) {
+		/* skip unoccupied entries */
+		if (!(ptp->p_flags & OCCUPIED))
+			continue;
 
-/* Allowed init action types */
-#define SYSINIT     0x001
-#define RESPAWN     0x002
-#define ASKFIRST    0x004
-#define WAIT        0x008
-#define ONCE        0x010
-#define CTRLALTDEL  0x020
-#define SHUTDOWN    0x040
-#define RESTART     0x080
-
-/* A mapping between "inittab" action name strings and action type codes. */
-struct init_action_type {
-	const char *name;
-	int action;
-};
+		/* p_flags has no bits outside of PF_MASK */
+		if (ptp->p_flags & ~(PF_MASK))
+			return (0);
+
+		/* 5 <= pid <= MAXPID */
+		if (ptp->p_pid < 5 || ptp->p_pid > MAXPID)
+			return (0);
+
+		/* p_count >= 0 */
+		if (ptp->p_count < 0)
+			return (0);
+
+		/* p_time >= 0 */
+		if (ptp->p_time < 0)
+			return (0);
+	}
 
-static const struct init_action_type actions[] = {
-	{"sysinit", SYSINIT},
-	{"respawn", RESPAWN},
-	{"askfirst", ASKFIRST},
-	{"wait", WAIT},
-	{"once", ONCE},
-	{"ctrlaltdel", CTRLALTDEL},
-	{"shutdown", SHUTDOWN},
-	{"restart", RESTART},
-	{0, 0}
-};
+	return (1);
+}
 
-/* Set up a linked list of init_actions, to be read from inittab */
-struct init_action {
-	pid_t pid;
-	char command[INIT_BUFFS_SIZE];
-	char terminal[CONSOLE_BUFF_SIZE];
-	struct init_action *next;
-	int action;
-};
+/*
+ * Initialize our state.
+ *
+ * If the system just booted, then init_state_file, which is located on an
+ * everpresent tmpfs filesystem, should not exist.
+ *
+ * If we were restarted, then init_state_file should exist, in
+ * which case we'll read it in, sanity check it, and use it.
+ *
+ * Note: You can't call console() until proc_table is ready.
+ */
+void
+st_init()
+{
+	struct stat stb;
+	int ret, st_fd, insane = 0;
+	size_t to_be_read;
+	char *ptr;
 
-/* Static variables */
-static struct init_action *init_action_list = NULL;
-static char console[CONSOLE_BUFF_SIZE] = CONSOLE_DEV;
 
-#ifndef CONFIG_SYSLOGD
-static char *log_console = VC_5;
-#endif
-#if !ENABLE_DEBUG_INIT
-static sig_atomic_t got_cont = 0;
-#endif
+	booting = 1;
 
-enum {
-	LOG = 0x1,
-	CONSOLE = 0x2,
+	do {
+		/*
+		 * If we can exclusively create the file, then we're the
+		 * initial invocation of init(1M).
+		 */
+		st_fd = open(init_state_file, O_RDWR | O_CREAT | O_EXCL,
+		    S_IRUSR | S_IWUSR);
+	} while (st_fd == -1 && errno == EINTR);
+	if (st_fd != -1)
+		goto new_state;
+
+	booting = 0;
+
+	do {
+		st_fd = open(init_state_file, O_RDWR, S_IRUSR | S_IWUSR);
+	} while (st_fd == -1 && errno == EINTR);
+	if (st_fd == -1)
+		goto new_state;
+
+	/* Get the size of the file. */
+	do
+		ret = fstat(st_fd, &stb);
+	while (ret == -1 && errno == EINTR);
+	if (ret == -1)
+		goto new_state;
+
+	do
+		g_state = malloc(stb.st_size);
+	while (g_state == NULL && errno == EAGAIN);
+	if (g_state == NULL)
+		goto new_state;
+
+	to_be_read = stb.st_size;
+	ptr = (char *)g_state;
+	while (to_be_read > 0) {
+		ssize_t read_ret;
+
+		read_ret = read(st_fd, ptr, to_be_read);
+		if (read_ret < 0) {
+			if (errno == EINTR)
+				continue;
 
-#if defined CONFIG_FEATURE_EXTRA_QUIET
-	MAYBE_CONSOLE = 0x0,
-#else
-	MAYBE_CONSOLE = CONSOLE,
-#endif
+			goto new_state;
+		}
 
-#ifndef RB_HALT_SYSTEM
-	RB_HALT_SYSTEM = 0xcdef0123, /* FIXME: this overflows enum */
-	RB_ENABLE_CAD = 0x89abcdef,
-	RB_DISABLE_CAD = 0,
-	RB_POWER_OFF = 0x4321fedc,
-	RB_AUTOBOOT = 0x01234567,
-#endif
-};
+		to_be_read -= read_ret;
+		ptr += read_ret;
+	}
 
-static const char * const environment[] = {
-	"HOME=/",
-	"PATH=" _PATH_STDPATH,
-	"SHELL=/bin/sh",
-	"USER=root",
-	NULL
-};
+	(void) close(st_fd);
 
-/* Function prototypes */
-static void delete_init_action(struct init_action *a);
-static int waitfor(const struct init_action *a, pid_t pid);
-#if !ENABLE_DEBUG_INIT
-static void shutdown_signal(int sig);
-#endif
+	g_state_sz = stb.st_size;
 
-static void loop_forever(void)
-{
-	while (1)
-		sleep(1);
-}
+	if (st_sane()) {
+		console(B_TRUE, "Restarting.\n");
+		return;
+	}
 
-/* Print a message to the specified device.
- * Device may be bitwise-or'd from LOG | CONSOLE */
-#if ENABLE_DEBUG_INIT
-#define messageD message
-#else
-static inline void messageD(int ATTRIBUTE_UNUSED device,
-				const char ATTRIBUTE_UNUSED *fmt, ...)
-{
-}
-#endif
-static void message(int device, const char *fmt, ...)
-	__attribute__ ((format(printf, 2, 3)));
-static void message(int device, const char *fmt, ...)
-{
-	va_list arguments;
-	int l;
-	RESERVE_CONFIG_BUFFER(msg, 1024);
-#ifndef CONFIG_SYSLOGD
-	static int log_fd = -1;
-#endif
+	insane = 1;
 
-	msg[0] = '\r';
-		va_start(arguments, fmt);
-	l = vsnprintf(msg + 1, 1024 - 2, fmt, arguments) + 1;
-		va_end(arguments);
-
-#ifdef CONFIG_SYSLOGD
-	/* Log the message to syslogd */
-	if (device & LOG) {
-		/* don`t out "\r\n" */
-		openlog(bb_applet_name, 0, LOG_DAEMON);
-		syslog(LOG_INFO, "%s", msg + 1);
-		closelog();
+new_state:
+	if (st_fd >= 0)
+		(void) close(st_fd);
+	else
+		(void) unlink(init_state_file);
+
+	if (g_state != NULL)
+		free(g_state);
+
+	/* Something went wrong, so allocate new state. */
+	g_state_sz = sizeof (struct init_state) +
+	    ((init_num_proc - 1) * sizeof (struct PROC_TABLE));
+	do
+		g_state = calloc(1, g_state_sz);
+	while (g_state == NULL && errno == EAGAIN);
+	if (g_state == NULL) {
+		/* Fatal error! */
+		exit(errno);
 	}
 
-	msg[l++] = '\n';
-	msg[l] = 0;
-#else
+	g_state->ist_runlevel = -1;
+	num_proc = init_num_proc;
 
-	msg[l++] = '\n';
-	msg[l] = 0;
-	/* Take full control of the log tty, and never close it.
-	 * It's mine, all mine!  Muhahahaha! */
-	if (log_fd < 0) {
-		if ((log_fd = device_open(log_console, O_RDWR | O_NONBLOCK | O_NOCTTY)) < 0) {
-			log_fd = -2;
-			bb_error_msg("Bummer, can't write to log on %s!", log_console);
-			device = CONSOLE;
-		} else {
-			fcntl(log_fd, F_SETFD, FD_CLOEXEC);
-		}
-	}
-	if ((device & LOG) && (log_fd >= 0)) {
-		bb_full_write(log_fd, msg, l);
-	}
-#endif
+	if (!booting) {
+		console(B_TRUE, "Restarting.\n");
 
-	if (device & CONSOLE) {
-		int fd = device_open(CONSOLE_DEV,
-					O_WRONLY | O_NOCTTY | O_NONBLOCK);
-		/* Always send console messages to /dev/console so people will see them. */
-		if (fd >= 0) {
-			bb_full_write(fd, msg, l);
-			close(fd);
-#if ENABLE_DEBUG_INIT
-		/* all descriptors may be closed */
+		/* Overwrite the bad state file. */
+		st_write();
+
+		if (!insane) {
+			console(B_TRUE,
+			    "Error accessing persistent state file `%s'.  "
+			    "Ignored.\n", init_state_file);
 		} else {
-			bb_error_msg("Bummer, can't print: ");
-			va_start(arguments, fmt);
-			vfprintf(stderr, fmt, arguments);
-			va_end(arguments);
-#endif
+			console(B_TRUE,
+			    "Persistent state file `%s' is invalid and was "
+			    "ignored.\n", init_state_file);
 		}
 	}
-	RELEASE_CONFIG_BUFFER(msg);
 }
 
-/* Set terminal settings to reasonable defaults */
-static void set_term(void)
+/*
+ * Write g_state out to the state file.
+ */
+void
+st_write()
 {
-	struct termios tty;
+	static int complained = 0;
 
-	tcgetattr(STDIN_FILENO, &tty);
+	int st_fd;
+	char *cp;
+	size_t sz;
+	ssize_t ret;
+
+
+	do {
+		st_fd = open(init_next_state_file,
+		    O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
+	} while (st_fd < 0 && errno == EINTR);
+	if (st_fd < 0)
+		goto err;
+
+	cp = (char *)g_state;
+	sz = g_state_sz;
+	while (sz > 0) {
+		ret = write(st_fd, cp, sz);
+		if (ret < 0) {
+			if (errno == EINTR)
+				continue;
 
-	/* set control chars */
-	tty.c_cc[VINTR] = 3;	/* C-c */
-	tty.c_cc[VQUIT] = 28;	/* C-\ */
-	tty.c_cc[VERASE] = 127;	/* C-? */
-	tty.c_cc[VKILL] = 21;	/* C-u */
-	tty.c_cc[VEOF] = 4;	/* C-d */
-	tty.c_cc[VSTART] = 17;	/* C-q */
-	tty.c_cc[VSTOP] = 19;	/* C-s */
-	tty.c_cc[VSUSP] = 26;	/* C-z */
-
-	/* use line dicipline 0 */
-	tty.c_line = 0;
-
-	/* Make it be sane */
-	tty.c_cflag &= CBAUD | CBAUDEX | CSIZE | CSTOPB | PARENB | PARODD;
-	tty.c_cflag |= CREAD | HUPCL | CLOCAL;
+			goto err;
+		}
 
+		sz -= ret;
+		cp += ret;
+	}
 
-	/* input modes */
-	tty.c_iflag = ICRNL | IXON | IXOFF;
+	(void) close(st_fd);
+	st_fd = -1;
+	if (rename(init_next_state_file, init_state_file)) {
+		(void) unlink(init_next_state_file);
+		goto err;
+	}
+	complained = 0;
 
-	/* output modes */
-	tty.c_oflag = OPOST | ONLCR;
+	return;
 
-	/* local modes */
-	tty.c_lflag =
-		ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE | IEXTEN;
+err:
+	if (st_fd >= 0)
+		(void) close(st_fd);
 
-	tcsetattr(STDIN_FILENO, TCSANOW, &tty);
+	if (!booting && !complained) {
+		/*
+		 * Only complain after the filesystem should have come up.
+		 * And only do it once so we don't loop between console()
+		 * & efork().
+		 */
+		complained = 1;
+		if (st_fd)
+			console(B_TRUE, "Couldn't write persistent state "
+			    "file `%s'.\n", init_state_file);
+		else
+			console(B_TRUE, "Couldn't move persistent state "
+			    "file `%s' to `%s'.\n", init_next_state_file,
+			    init_state_file);
+	}
 }
 
-static void console_init(void)
+/*
+ * Create a contract with these parameters.
+ */
+static int
+contract_make_template(uint_t info, uint_t critical, uint_t fatal,
+    uint64_t cookie)
 {
-	int fd;
-	int tried = 0;
-	struct vt_stat vt;
-	struct serial_struct sr;
-	char *s;
-
-	if ((s = getenv("CONSOLE")) != NULL || (s = getenv("console")) != NULL) {
-		safe_strncpy(console, s, sizeof(console));
-#if 0 /* #cpu(sparc) */
-	/* sparc kernel supports console=tty[ab] parameter which is also
-	 * passed to init, so catch it here */
-		/* remap tty[ab] to /dev/ttyS[01] */
-		if (strcmp(s, "ttya") == 0)
-			safe_strncpy(console, SC_0, sizeof(console));
-		else if (strcmp(s, "ttyb") == 0)
-			safe_strncpy(console, SC_1, sizeof(console));
-#endif
-	} else {
-		/* 2.2 kernels: identify the real console backend and try to use it */
-		if (ioctl(0, TIOCGSERIAL, &sr) == 0) {
-			/* this is a serial console */
-			snprintf(console, sizeof(console) - 1, SC_FORMAT, sr.line);
-		} else if (ioctl(0, VT_GETSTATE, &vt) == 0) {
-			/* this is linux virtual tty */
-			snprintf(console, sizeof(console) - 1, VC_FORMAT, vt.v_active);
-		} else {
-			safe_strncpy(console, CONSOLE_DEV, sizeof(console));
-			tried++;
-		}
-	}
+	int fd, err;
 
-	while ((fd = open(console, O_RDONLY | O_NONBLOCK)) < 0 && tried < 2) {
-		/* Can't open selected console -- try
-			logical system console and VT_MASTER */
-		safe_strncpy(console, (tried == 0 ? CONSOLE_DEV : CURRENT_VC),
-							sizeof(console));
-		tried++;
-	}
+	char *ioctl_tset_emsg =
+	    "Couldn't set \"%s\" contract template parameter: %s.\n";
+
+	do
+		fd = open64(CTFS_ROOT "/process/template", O_RDWR);
+	while (fd < 0 && errno == EINTR);
 	if (fd < 0) {
-		/* Perhaps we should panic here? */
-#ifndef CONFIG_SYSLOGD
-		log_console =
-#endif
-		safe_strncpy(console, bb_dev_null, sizeof(console));
-	} else {
-		s = getenv("TERM");
-		/* check for serial console */
-		if (ioctl(fd, TIOCGSERIAL, &sr) == 0) {
-			/* Force the TERM setting to vt102 for serial console --
-			 * if TERM is set to linux (the default) */
-			if (s == NULL || strcmp(s, "linux") == 0)
-				putenv("TERM=vt102");
-#ifndef CONFIG_SYSLOGD
-			log_console = console;
-#endif
-		} else {
-			if (s == NULL)
-				putenv("TERM=linux");
-		}
-		close(fd);
+		console(B_TRUE, "Couldn't create process template: %s.\n",
+		    strerror(errno));
+		return (-1);
 	}
-	messageD(LOG, "console=%s", console);
-}
 
-static void fixup_argv(int argc, char **argv, char *new_argv0)
-{
-	int len;
+	if (err = ct_pr_tmpl_set_param(fd, CT_PR_INHERIT | CT_PR_REGENT))
+		console(B_TRUE, "Contract set template inherit, regent "
+		    "failed: %s.\n", strerror(err));
 
-	/* Fix up argv[0] to be certain we claim to be init */
-	len = strlen(argv[0]);
-	memset(argv[0], 0, len);
-	safe_strncpy(argv[0], new_argv0, len + 1);
+	/*
+	 * These errors result in a misconfigured template, which is better
+	 * than no template at all, so warn but don't abort.
+	 */
+	if (err = ct_tmpl_set_informative(fd, info))
+		console(B_TRUE, ioctl_tset_emsg, "informative", strerror(err));
 
-	/* Wipe argv[1]-argv[N] so they don't clutter the ps listing */
-	len = 1;
-	while (argc > len) {
-		memset(argv[len], 0, strlen(argv[len]));
-		len++;
-	}
-}
+	if (err = ct_tmpl_set_critical(fd, critical))
+		console(B_TRUE, ioctl_tset_emsg, "critical", strerror(err));
 
-/* Open the new terminal device */
-static void open_new_terminal(const char * const device, const int fail) {
-	struct stat sb;
+	if (err = ct_pr_tmpl_set_fatal(fd, fatal))
+		console(B_TRUE, ioctl_tset_emsg, "fatal", strerror(err));
 
-	if ((device_open(device, O_RDWR)) < 0) {
-		if (stat(device, &sb) != 0) {
-			message(LOG | CONSOLE, "device '%s' does not exist.", device);
-		} else {
-			message(LOG | CONSOLE, "Bummer, can't open %s", device);
-		}
-		if (fail)
-			_exit(1);
-		/* else */
-#if !ENABLE_DEBUG_INIT
-		shutdown_signal(SIGUSR1);
-#else
-		_exit(2);
-#endif
-	}
+	if (err = ct_tmpl_set_cookie(fd, cookie))
+		console(B_TRUE, ioctl_tset_emsg, "cookie", strerror(err));
+
+	(void) fcntl(fd, F_SETFD, FD_CLOEXEC);
+
+	return (fd);
 }
 
-static pid_t run(const struct init_action *a)
+/*
+ * Create the templates and open an event file descriptor.  We use dup2(2) to
+ * get these descriptors away from the stdin/stdout/stderr group.
+ */
+static void
+contracts_init()
 {
-	int i;
-	pid_t pid;
-	char *s, *tmpCmd, *cmd[INIT_BUFFS_SIZE], *cmdpath;
-	char buf[INIT_BUFFS_SIZE + 6];	/* INIT_BUFFS_SIZE+strlen("exec ")+1 */
-	sigset_t nmask, omask;
-	static const char press_enter[] =
-#ifdef CUSTOMIZED_BANNER
-#include CUSTOMIZED_BANNER
-#endif
-		"\nPlease press Enter to activate this console. ";
+	int err, fd;
 
-	/* Block sigchild while forking.  */
-	sigemptyset(&nmask);
-	sigaddset(&nmask, SIGCHLD);
-	sigprocmask(SIG_BLOCK, &nmask, &omask);
-
-	if ((pid = fork()) == 0) {
-
-		/* Clean up */
-		close(0);
-		close(1);
-		close(2);
-		sigprocmask(SIG_SETMASK, &omask, NULL);
-
-		/* Reset signal handlers that were set by the parent process */
-		signal(SIGUSR1, SIG_DFL);
-		signal(SIGUSR2, SIG_DFL);
-		signal(SIGINT, SIG_DFL);
-		signal(SIGTERM, SIG_DFL);
-		signal(SIGHUP, SIG_DFL);
-		signal(SIGQUIT, SIG_DFL);
-		signal(SIGCONT, SIG_DFL);
-		signal(SIGSTOP, SIG_DFL);
-		signal(SIGTSTP, SIG_DFL);
-
-		/* Create a new session and make ourself the process
-		 * group leader */
-		setsid();
-
-		/* Open the new terminal device */
-		open_new_terminal(a->terminal, 1);
-
-		/* Make sure the terminal will act fairly normal for us */
-		set_term();
-		/* Setup stdout, stderr for the new process so
-		 * they point to the supplied terminal */
-		dup(0);
-		dup(0);
-
-		/* If the init Action requires us to wait, then force the
-		 * supplied terminal to be the controlling tty. */
-		if (a->action & (SYSINIT | WAIT | CTRLALTDEL | SHUTDOWN | RESTART)) {
-
-			/* Now fork off another process to just hang around */
-			if ((pid = fork()) < 0) {
-				message(LOG | CONSOLE, "Can't fork!");
-				_exit(1);
-			}
-
-			if (pid > 0) {
-
-				/* We are the parent -- wait till the child is done */
-				signal(SIGINT, SIG_IGN);
-				signal(SIGTSTP, SIG_IGN);
-				signal(SIGQUIT, SIG_IGN);
-				signal(SIGCHLD, SIG_DFL);
-
-				waitfor(NULL, pid);
-				/* See if stealing the controlling tty back is necessary */
-				if (tcgetpgrp(0) != getpid())
-					_exit(0);
-
-				/* Use a temporary process to steal the controlling tty. */
-				if ((pid = fork()) < 0) {
-					message(LOG | CONSOLE, "Can't fork!");
-					_exit(1);
-				}
-				if (pid == 0) {
-					setsid();
-					ioctl(0, TIOCSCTTY, 1);
-					_exit(0);
-				}
-				waitfor(NULL, pid);
-				_exit(0);
-			}
-
-			/* Now fall though to actually execute things */
-		}
-
-		/* See if any special /bin/sh requiring characters are present */
-		if (strpbrk(a->command, "~`!$^&*()=|\\{}[];\"'<>?") != NULL) {
-			cmd[0] = (char *)DEFAULT_SHELL;
-			cmd[1] = "-c";
-			cmd[2] = strcat(strcpy(buf, "exec "), a->command);
-			cmd[3] = NULL;
-		} else {
-			/* Convert command (char*) into cmd (char**, one word per string) */
-			strcpy(buf, a->command);
-			s = buf;
-			for (tmpCmd = buf, i = 0; (tmpCmd = strsep(&s, " \t")) != NULL;) {
-				if (*tmpCmd != '\0') {
-					cmd[i] = tmpCmd;
-					i++;
-				}
-			}
-			cmd[i] = NULL;
+	/*
+	 * Create & configure a legacy template.  We only want empty events so
+	 * we know when to abandon them.
+	 */
+	legacy_tmpl = contract_make_template(0, CT_PR_EV_EMPTY, CT_PR_EV_HWERR,
+	    ORDINARY_COOKIE);
+	if (legacy_tmpl >= 0) {
+		err = ct_tmpl_activate(legacy_tmpl);
+		if (err != 0) {
+			(void) close(legacy_tmpl);
+			legacy_tmpl = -1;
+			console(B_TRUE,
+			    "Couldn't activate legacy template (%s); "
+			    "legacy services will be in init's contract.\n",
+			    strerror(err));
 		}
+	} else
+		console(B_TRUE,
+		    "Legacy services will be in init's contract.\n");
+
+	if (dup2(legacy_tmpl, 255) == -1) {
+		console(B_TRUE, "Could not duplicate legacy template: %s.\n",
+		    strerror(errno));
+	} else {
+		(void) close(legacy_tmpl);
+		legacy_tmpl = 255;
+	}
 
-		cmdpath = cmd[0];
+	(void) fcntl(legacy_tmpl, F_SETFD, FD_CLOEXEC);
 
-		/*
-		   Interactive shells want to see a dash in argv[0].  This
-		   typically is handled by login, argv will be setup this
-		   way if a dash appears at the front of the command path
-		   (like "-/bin/sh").
-		 */
+	startd_tmpl = contract_make_template(0, CT_PR_EV_EMPTY,
+	    CT_PR_EV_HWERR | CT_PR_EV_SIGNAL | CT_PR_EV_CORE, STARTD_COOKIE);
 
-		if (*cmdpath == '-') {
+	if (dup2(startd_tmpl, 254) == -1) {
+		console(B_TRUE, "Could not duplicate startd template: %s.\n",
+		    strerror(errno));
+	} else {
+		(void) close(startd_tmpl);
+		startd_tmpl = 254;
+	}
 
-			/* skip over the dash */
-			++cmdpath;
+	(void) fcntl(startd_tmpl, F_SETFD, FD_CLOEXEC);
 
-			/* find the last component in the command pathname */
-			s = bb_get_last_path_component(cmdpath);
+	if (legacy_tmpl < 0 && startd_tmpl < 0) {
+		/* The creation errors have already been reported. */
+		console(B_TRUE,
+		    "Ignoring contract events.  Core smf(5) services will not "
+		    "be restarted.\n");
+		return;
+	}
 
-			/* make a new argv[0] */
-			if ((cmd[0] = malloc(strlen(s) + 2)) == NULL) {
-				message(LOG | CONSOLE, bb_msg_memory_exhausted);
-				cmd[0] = cmdpath;
-			} else {
-				cmd[0][0] = '-';
-				strcpy(cmd[0] + 1, s);
-			}
-#ifdef CONFIG_FEATURE_INIT_SCTTY
-			/* Establish this process as session leader and
-			 * (attempt) to make the tty (if any) a controlling tty.
-			 */
-			(void) setsid();
-			(void) ioctl(0, TIOCSCTTY, 0/*don't steal it*/);
-#endif
-		}
+	/*
+	 * Open an event endpoint.
+	 */
+	do
+		fd = open64(CTFS_ROOT "/process/pbundle", O_RDONLY);
+	while (fd < 0 && errno == EINTR);
+	if (fd < 0) {
+		console(B_TRUE,
+		    "Couldn't open process pbundle: %s.  Core smf(5) services "
+		    "will not be restarted.\n", strerror(errno));
+		return;
+	}
 
-#if !defined(__UCLIBC__) || defined(__ARCH_HAS_MMU__)
-		if (a->action & ASKFIRST) {
-			char c;
-			/*
-			 * Save memory by not exec-ing anything large (like a shell)
-			 * before the user wants it. This is critical if swap is not
-			 * enabled and the system has low memory. Generally this will
-			 * be run on the second virtual console, and the first will
-			 * be allowed to start a shell or whatever an init script
-			 * specifies.
-			 */
-			messageD(LOG, "Waiting for enter to start '%s'"
-						"(pid %d, terminal %s)\n",
-					  cmdpath, getpid(), a->terminal);
-			bb_full_write(1, press_enter, sizeof(press_enter) - 1);
-			while(read(0, &c, 1) == 1 && c != '\n')
-				;
-		}
-#endif
+	if (dup2(fd, 253) == -1) {
+		console(B_TRUE, "Could not duplicate process bundle: %s.\n",
+		    strerror(errno));
+	} else {
+		(void) close(fd);
+		fd = 253;
+	}
 
-		/* Log the process name and args */
-		message(LOG, "Starting pid %d, console %s: '%s'",
-				  getpid(), a->terminal, cmdpath);
-
-#if defined CONFIG_FEATURE_INIT_COREDUMPS
-		{
-			struct stat sb;
-			if (stat(CORE_ENABLE_FLAG_FILE, &sb) == 0) {
-				struct rlimit limit;
-
-				limit.rlim_cur = RLIM_INFINITY;
-				limit.rlim_max = RLIM_INFINITY;
-				setrlimit(RLIMIT_CORE, &limit);
-			}
-		}
-#endif
+	(void) fcntl(fd, F_SETFD, FD_CLOEXEC);
 
-		/* Now run it.  The new program will take over this PID,
-		 * so nothing further in init.c should be run. */
-		execv(cmdpath, cmd);
+	/* Reset in case we've been restarted. */
+	(void) ct_event_reset(fd);
 
-		/* We're still here?  Some error happened. */
-		message(LOG | CONSOLE, "Bummer, could not run '%s': %m", cmdpath);
-		_exit(-1);
-	}
-	sigprocmask(SIG_SETMASK, &omask, NULL);
-	return pid;
+	poll_fds[0].fd = fd;
+	poll_fds[0].events = POLLIN;
+	poll_nfds = 1;
 }
 
-static int waitfor(const struct init_action *a, pid_t pid)
+static int
+contract_getfile(ctid_t id, const char *name, int oflag)
 {
-	int runpid;
-	int status, wpid;
-
-	runpid = (NULL == a)? pid : run(a);
-	while (1) {
-		wpid = waitpid(runpid,&status,0);
-		if (wpid == runpid)
-			break;
-		if (wpid == -1 && errno == ECHILD) {
-			/* we missed its termination */
-			break;
-		}
-		/* FIXME other errors should maybe trigger an error, but allow
-		 * the program to continue */
-	}
-	return wpid;
-}
+	int fd;
 
-/* Run all commands of a particular type */
-static void run_actions(int action)
-{
-	struct init_action *a, *tmp;
+	do
+		fd = contract_open(id, "process", name, oflag);
+	while (fd < 0 && errno == EINTR);
+
+	if (fd < 0)
+		console(B_TRUE, "Couldn't open %s for contract %ld: %s.\n",
+		    name, id, strerror(errno));
 
-	for (a = init_action_list; a; a = tmp) {
-		tmp = a->next;
-		if (a->action == action) {
-			if (access(a->terminal, R_OK | W_OK)) {
-				delete_init_action(a);
-			} else if (a->action & (SYSINIT | WAIT | CTRLALTDEL | SHUTDOWN | RESTART)) {
-				waitfor(a, 0);
-				delete_init_action(a);
-			} else if (a->action & ONCE) {
-				run(a);
-				delete_init_action(a);
-			} else if (a->action & (RESPAWN | ASKFIRST)) {
-				/* Only run stuff with pid==0.  If they have
-				 * a pid, that means it is still running */
-				if (a->pid == 0) {
-					a->pid = run(a);
-				}
-			}
-		}
-	}
+	return (fd);
 }
 
-#if !ENABLE_DEBUG_INIT
-static void init_reboot(unsigned long magic)
+static int
+contract_cookie(ctid_t id, uint64_t *cp)
 {
-	pid_t pid;
-	/* We have to fork here, since the kernel calls do_exit(0) in
-	 * linux/kernel/sys.c, which can cause the machine to panic when
-	 * the init process is killed.... */
-	if ((pid = fork()) == 0) {
-		reboot(magic);
-		_exit(0);
-	}
-	waitpid (pid, NULL, 0);
-}
-
-static void shutdown_system(void)
-{
-	sigset_t block_signals;
-
-	/* run everything to be run at "shutdown".  This is done _prior_
-	 * to killing everything, in case people wish to use scripts to
-	 * shut things down gracefully... */
-	run_actions(SHUTDOWN);
-
-	/* first disable all our signals */
-	sigemptyset(&block_signals);
-	sigaddset(&block_signals, SIGHUP);
-	sigaddset(&block_signals, SIGQUIT);
-	sigaddset(&block_signals, SIGCHLD);
-	sigaddset(&block_signals, SIGUSR1);
-	sigaddset(&block_signals, SIGUSR2);
-	sigaddset(&block_signals, SIGINT);
-	sigaddset(&block_signals, SIGTERM);
-	sigaddset(&block_signals, SIGCONT);
-	sigaddset(&block_signals, SIGSTOP);
-	sigaddset(&block_signals, SIGTSTP);
-	sigprocmask(SIG_BLOCK, &block_signals, NULL);
-
-	/* Allow Ctrl-Alt-Del to reboot system. */
-	init_reboot(RB_ENABLE_CAD);
-
-	message(CONSOLE | LOG, "The system is going down NOW !!");
-	sync();
-
-	/* Send signals to every process _except_ pid 1 */
-	message(CONSOLE | LOG, init_sending_format, "TERM");
-	kill(-1, SIGTERM);
-	sleep(1);
-	sync();
-
-	message(CONSOLE | LOG, init_sending_format, "KILL");
-	kill(-1, SIGKILL);
-	sleep(1);
-
-	sync();
-}
-
-static void exec_signal(int sig ATTRIBUTE_UNUSED)
-{
-	struct init_action *a, *tmp;
-	sigset_t unblock_signals;
-
-	for (a = init_action_list; a; a = tmp) {
-		tmp = a->next;
-		if (a->action & RESTART) {
-			shutdown_system();
-
-			/* unblock all signals, blocked in shutdown_system() */
-			sigemptyset(&unblock_signals);
-			sigaddset(&unblock_signals, SIGHUP);
-			sigaddset(&unblock_signals, SIGQUIT);
-			sigaddset(&unblock_signals, SIGCHLD);
-			sigaddset(&unblock_signals, SIGUSR1);
-			sigaddset(&unblock_signals, SIGUSR2);
-			sigaddset(&unblock_signals, SIGINT);
-			sigaddset(&unblock_signals, SIGTERM);
-			sigaddset(&unblock_signals, SIGCONT);
-			sigaddset(&unblock_signals, SIGSTOP);
-			sigaddset(&unblock_signals, SIGTSTP);
-			sigprocmask(SIG_UNBLOCK, &unblock_signals, NULL);
-
-			/* Close whatever files are open. */
-			close(0);
-			close(1);
-			close(2);
-
-			/* Open the new terminal device */
-			open_new_terminal(a->terminal, 0);
-
-			/* Make sure the terminal will act fairly normal for us */
-			set_term();
-			/* Setup stdout, stderr on the supplied terminal */
-			dup(0);
-			dup(0);
-
-			messageD(CONSOLE | LOG, "Trying to re-exec %s", a->command);
-			execl(a->command, a->command, NULL);
-
-			message(CONSOLE | LOG, "exec of '%s' failed: %m",
-					a->command);
-			sync();
-			sleep(2);
-			init_reboot(RB_HALT_SYSTEM);
-			loop_forever();
-		}
-	}
-}
-
-static void shutdown_signal(int sig)
-{
-	char *m;
-	int rb;
-
-	shutdown_system();
-
-	if (sig == SIGTERM) {
-		m = "reboot";
-		rb = RB_AUTOBOOT;
-	} else if (sig == SIGUSR2) {
-		m = "poweroff";
-		rb = RB_POWER_OFF;
-	} else {
-		m = "halt";
-		rb = RB_HALT_SYSTEM;
+	int fd, err;
+	ct_stathdl_t sh;
+
+	fd = contract_getfile(id, "status", O_RDONLY);
+	if (fd < 0)
+		return (-1);
+
+	err = ct_status_read(fd, CTD_COMMON, &sh);
+	if (err != 0) {
+		console(B_TRUE, "Couldn't read status of contract %ld: %s.\n",
+		    id, strerror(err));
+		(void) close(fd);
+		return (-1);
 	}
-	message(CONSOLE | LOG, "Requesting system %s.", m);
-	sync();
 
-	/* allow time for last message to reach serial console */
-	sleep(2);
+	(void) close(fd);
 
-	init_reboot(rb);
+	*cp = ct_status_get_cookie(sh);
 
-	loop_forever();
+	ct_status_free(sh);
+	return (0);
 }
 
-static void ctrlaltdel_signal(int sig ATTRIBUTE_UNUSED)
+static void
+contract_ack(ct_evthdl_t e)
 {
-	run_actions(CTRLALTDEL);
-}
+	int fd;
 
-/* The SIGSTOP & SIGTSTP handler */
-static void stop_handler(int sig ATTRIBUTE_UNUSED)
-{
-	int saved_errno = errno;
+	if (ct_event_get_flags(e) & CTE_INFO)
+		return;
 
-	got_cont = 0;
-	while (!got_cont)
-		pause();
-	got_cont = 0;
-	errno = saved_errno;
+	fd = contract_getfile(ct_event_get_ctid(e), "ctl", O_WRONLY);
+	if (fd < 0)
+		return;
+
+	(void) ct_ctl_ack(fd, ct_event_get_evid(e));
+	(void) close(fd);
 }
 
-/* The SIGCONT handler */
-static void cont_handler(int sig ATTRIBUTE_UNUSED)
+/*
+ * Process a contract event.
+ */
+static void
+contract_event(struct pollfd *poll)
 {
-	got_cont = 1;
-}
+	ct_evthdl_t e;
+	int err;
+	ctid_t ctid;
+
+	if (!(poll->revents & POLLIN)) {
+		if (poll->revents & POLLERR)
+			console(B_TRUE,
+			    "Unknown poll error on my process contract "
+			    "pbundle.\n");
+		return;
+	}
 
-#endif							/* ! ENABLE_DEBUG_INIT */
+	err = ct_event_read(poll->fd, &e);
+	if (err != 0) {
+		console(B_TRUE, "Error retrieving contract event: %s.\n",
+		    strerror(err));
+		return;
+	}
 
-static void new_init_action(int action, const char *command, const char *cons)
-{
-	struct init_action *new_action, *a, *last;
+	ctid = ct_event_get_ctid(e);
 
-	if (*cons == '\0')
-		cons = console;
+	if (ct_event_get_type(e) == CT_PR_EV_EMPTY) {
+		uint64_t cookie;
+		int ret, abandon = 1;
+
+		/* If it's svc.startd, restart it.  Else, abandon. */
+		ret = contract_cookie(ctid, &cookie);
+
+		if (ret == 0) {
+			if (cookie == STARTD_COOKIE &&
+			    do_restart_startd) {
+				if (smf_debug)
+					console(B_TRUE, "Restarting "
+					    "svc.startd.\n");
+
+				/*
+				 * Account for the failure.  If the failure rate
+				 * exceeds a threshold, then drop to maintenance
+				 * mode.
+				 */
+				startd_record_failure();
+				if (startd_failure_rate_critical())
+					enter_maintenance();
+
+				if (startd_tmpl < 0)
+					console(B_TRUE,
+					    "Restarting svc.startd in "
+					    "improper contract (bad "
+					    "template).\n");
 
-	if (strcmp(cons, bb_dev_null) == 0 && (action & ASKFIRST))
-		return;
+				(void) startd_run(startd_cline, startd_tmpl,
+				    ctid);
 
-	new_action = calloc((size_t) (1), sizeof(struct init_action));
-	if (!new_action) {
-		message(LOG | CONSOLE, "Memory allocation failure");
-		loop_forever();
-	}
+				abandon = 0;
+			}
+		}
 
-	/* Append to the end of the list */
-	for (a = last = init_action_list; a; a = a->next) {
-		/* don't enter action if it's already in the list,
-		 * but do overwrite existing actions */
-		if ((strcmp(a->command, command) == 0) &&
-		    (strcmp(a->terminal, cons) ==0)) {
-			a->action = action;
-			free(new_action);
-			return;
+		if (abandon && (err = contract_abandon_id(ctid))) {
+			console(B_TRUE, "Couldn't abandon contract %ld: %s.\n",
+			    ctid, strerror(err));
 		}
-		last = a;
-	}
-	if (last) {
-		last->next = new_action;
+
+		/*
+		 * No need to acknowledge the event since either way the
+		 * originating contract should be abandoned.
+		 */
 	} else {
-		init_action_list = new_action;
+		console(B_TRUE,
+		    "Received contract event of unexpected type %d from "
+		    "contract %ld.\n", ct_event_get_type(e), ctid);
+
+		if ((ct_event_get_flags(e) & (CTE_INFO | CTE_ACK)) == 0)
+			/* Allow unexpected critical events to be released. */
+			contract_ack(e);
 	}
-	strcpy(new_action->command, command);
-	new_action->action = action;
-	strcpy(new_action->terminal, cons);
-#if 0   /* calloc zeroed always */
-	new_action->pid = 0;
-#endif
-	messageD(LOG|CONSOLE, "command='%s' action='%d' terminal='%s'\n",
-		new_action->command, new_action->action, new_action->terminal);
+
+	ct_event_free(e);
 }
 
-static void delete_init_action(struct init_action *action)
+/*
+ * svc.startd(1M) Management
+ */
+
+/*
+ * (Re)start svc.startd(1M).  old_ctid should be the contract ID of the old
+ * contract, or 0 if we're starting it for the first time.  If wait is true
+ * we'll wait for and return the exit value of the child.
+ */
+static int
+startd_run(const char *cline, int tmpl, ctid_t old_ctid)
 {
-	struct init_action *a, *b = NULL;
+	int err, i, ret, did_activate;
+	pid_t pid;
+	struct stat sb;
 
-	for (a = init_action_list; a; b = a, a = a->next) {
-		if (a == action) {
-			if (b == NULL) {
-				init_action_list = a->next;
-			} else {
-				b->next = a->next;
-			}
-			free(a);
-			break;
-		}
+	if (cline[0] == '\0')
+		return (-1);
+
+	/*
+	 * Don't restart startd if the system is rebooting or shutting down.
+	 */
+	do {
+		ret = stat("/etc/svc/volatile/resetting", &sb);
+	} while (ret == -1 && errno == EINTR);
+
+	if (ret == 0) {
+		if (smf_debug)
+			console(B_TRUE, "Quiescing for reboot.\n");
+		(void) pause();
+		return (-1);
 	}
-}
 
-/* NOTE that if CONFIG_FEATURE_USE_INITTAB is NOT defined,
- * then parse_inittab() simply adds in some default
- * actions(i.e., runs INIT_SCRIPT and then starts a pair
- * of "askfirst" shells).  If CONFIG_FEATURE_USE_INITTAB
- * _is_ defined, but /etc/inittab is missing, this
- * results in the same set of default behaviors.
- */
-static void parse_inittab(void)
-{
-#ifdef CONFIG_FEATURE_USE_INITTAB
-	FILE *file;
-	char buf[INIT_BUFFS_SIZE], lineAsRead[INIT_BUFFS_SIZE];
-	char tmpConsole[CONSOLE_BUFF_SIZE];
-	char *id, *runlev, *action, *command, *eol;
-	const struct init_action_type *a = actions;
-
-
-	file = fopen(INITTAB, "r");
-	if (file == NULL) {
-		/* No inittab file -- set up some default behavior */
-#endif
-		/* Reboot on Ctrl-Alt-Del */
-		new_init_action(CTRLALTDEL, "/sbin/reboot", "");
-		/* Umount all filesystems on halt/reboot */
-		new_init_action(SHUTDOWN, "/bin/umount -a -r", "");
-		/* Swapoff on halt/reboot */
-		if(ENABLE_SWAPONOFF) new_init_action(SHUTDOWN, "/sbin/swapoff -a", "");
-		/* Prepare to restart init when a HUP is received */
-		new_init_action(RESTART, "/sbin/init", "");
-		/* Askfirst shell on tty1-4 */
-		new_init_action(ASKFIRST, bb_default_login_shell, "");
-		new_init_action(ASKFIRST, bb_default_login_shell, VC_2);
-		new_init_action(ASKFIRST, bb_default_login_shell, VC_3);
-		new_init_action(ASKFIRST, bb_default_login_shell, VC_4);
-		/* sysinit */
-		new_init_action(SYSINIT, INIT_SCRIPT, "");
+	err = ct_pr_tmpl_set_transfer(tmpl, old_ctid);
+	if (err == EINVAL) {
+		console(B_TRUE, "Remake startd_tmpl; reattempt transfer.\n");
+		tmpl = startd_tmpl = contract_make_template(0, CT_PR_EV_EMPTY,
+		    CT_PR_EV_HWERR, STARTD_COOKIE);
 
-		return;
-#ifdef CONFIG_FEATURE_USE_INITTAB
+		err = ct_pr_tmpl_set_transfer(tmpl, old_ctid);
+	}
+	if (err != 0) {
+		console(B_TRUE,
+		    "Couldn't set transfer parameter of contract template: "
+		    "%s.\n", strerror(err));
 	}
 
-	while (fgets(buf, INIT_BUFFS_SIZE, file) != NULL) {
-		/* Skip leading spaces */
-		for (id = buf; *id == ' ' || *id == '\t'; id++);
-
-		/* Skip the line if it's a comment */
-		if (*id == '#' || *id == '\n')
-			continue;
+	if ((err = ct_pr_tmpl_set_svc_fmri(startd_tmpl,
+	    SCF_SERVICE_STARTD)) != 0)
+		console(B_TRUE,
+		    "Can not set svc_fmri in contract template: %s\n",
+		    strerror(err));
+	if ((err = ct_pr_tmpl_set_svc_aux(startd_tmpl,
+	    startd_svc_aux)) != 0)
+		console(B_TRUE,
+		    "Can not set svc_aux in contract template: %s\n",
+		    strerror(err));
+	did_activate = !(ct_tmpl_activate(tmpl));
+	if (!did_activate)
+		console(B_TRUE,
+		    "Template activation failed; not starting \"%s\" in "
+		    "proper contract.\n", cline);
+
+	/* Hold SIGCHLD so we can wait if necessary. */
+	(void) sighold(SIGCHLD);
+
+	while ((pid = fork()) < 0) {
+		if (errno == EPERM) {
+			console(B_TRUE, "Insufficient permission to fork.\n");
 
-		/* Trim the trailing \n */
-		eol = strrchr(id, '\n');
-		if (eol != NULL)
-			*eol = '\0';
-
-		/* Keep a copy around for posterity's sake (and error msgs) */
-		strcpy(lineAsRead, buf);
-
-		/* Separate the ID field from the runlevels */
-		runlev = strchr(id, ':');
-		if (runlev == NULL || *(runlev + 1) == '\0') {
-			message(LOG | CONSOLE, "Bad inittab entry: %s", lineAsRead);
-			continue;
-		} else {
-			*runlev = '\0';
-			++runlev;
+			/* Now that's a doozy. */
+			exit(1);
 		}
 
-		/* Separate the runlevels from the action */
-		action = strchr(runlev, ':');
-		if (action == NULL || *(action + 1) == '\0') {
-			message(LOG | CONSOLE, "Bad inittab entry: %s", lineAsRead);
-			continue;
-		} else {
-			*action = '\0';
-			++action;
-		}
+		console(B_TRUE,
+		    "fork() for svc.startd failed: %s.  Will retry in 1 "
+		    "second...\n", strerror(errno));
 
-		/* Separate the action from the command */
-		command = strchr(action, ':');
-		if (command == NULL || *(command + 1) == '\0') {
-			message(LOG | CONSOLE, "Bad inittab entry: %s", lineAsRead);
-			continue;
-		} else {
-			*command = '\0';
-			++command;
+		(void) sleep(1);
+
+		/* Eventually give up? */
+	}
+
+	if (pid == 0) {
+		/* child */
+
+		/* See the comment in efork() */
+		for (i = SIGHUP; i <= SIGRTMAX; ++i) {
+			if (i == SIGTTOU || i == SIGTTIN || i == SIGTSTP)
+				(void) sigset(i, SIG_IGN);
+			else
+				(void) sigset(i, SIG_DFL);
 		}
 
-		/* Ok, now process it */
-		for (a = actions; a->name != 0; a++) {
-			if (strcmp(a->name, action) == 0) {
-				if (*id != '\0') {
-					if(strncmp(id, "/dev/", 5) == 0)
-						id += 5;
-					strcpy(tmpConsole, "/dev/");
-					safe_strncpy(tmpConsole + 5, id,
-						CONSOLE_BUFF_SIZE - 5);
-					id = tmpConsole;
-				}
-				new_init_action(a->action, command, id);
-				break;
+		if (smf_options != NULL) {
+			/* Put smf_options in the environment. */
+			glob_envp[glob_envn] =
+			    malloc(sizeof ("SMF_OPTIONS=") - 1 +
+			    strlen(smf_options) + 1);
+
+			if (glob_envp[glob_envn] != NULL) {
+				/* LINTED */
+				(void) sprintf(glob_envp[glob_envn],
+				    "SMF_OPTIONS=%s", smf_options);
+				glob_envp[glob_envn+1] = NULL;
+			} else {
+				console(B_TRUE,
+				    "Could not set SMF_OPTIONS (%s).\n",
+				    strerror(errno));
 			}
 		}
-		if (a->name == 0) {
-			/* Choke on an unknown action */
-			message(LOG | CONSOLE, "Bad inittab entry: %s", lineAsRead);
-		}
-	}
-	fclose(file);
-	return;
-#endif							/* CONFIG_FEATURE_USE_INITTAB */
-}
 
-#ifdef CONFIG_FEATURE_USE_INITTAB
-static void reload_signal(int sig ATTRIBUTE_UNUSED)
-{
-	struct init_action *a, *tmp;
+		if (smf_debug)
+			console(B_TRUE, "Executing svc.startd\n");
+
+		(void) execle(SH, "INITSH", "-c", cline, NULL, glob_envp);
 
-	message(LOG, "Reloading /etc/inittab");
+		console(B_TRUE, "Could not exec \"%s\" (%s).\n", SH,
+		    strerror(errno));
 
-	/* disable old entrys */
-	for (a = init_action_list; a; a = a->next ) {
-		a->action = ONCE;
+		exit(1);
 	}
 
-	parse_inittab();
+	/* parent */
 
-	/* remove unused entrys */
-	for (a = init_action_list; a; a = tmp) {
-		tmp = a->next;
-		if (a->action & (ONCE | SYSINIT | WAIT ) &&
-				a->pid == 0 ) {
-			delete_init_action(a);
-		}
+	if (did_activate) {
+		if (legacy_tmpl < 0 || ct_tmpl_activate(legacy_tmpl) != 0)
+			(void) ct_tmpl_clear(tmpl);
 	}
-	run_actions(RESPAWN);
-	return;
+
+	/* Clear the old_ctid reference so the kernel can reclaim it. */
+	if (old_ctid != 0)
+		(void) ct_pr_tmpl_set_transfer(tmpl, 0);
+
+	(void) sigrelse(SIGCHLD);
+
+	return (0);
 }
-#endif							/* CONFIG_FEATURE_USE_INITTAB */
 
-int init_main(int argc, char **argv)
+/*
+ * void startd_record_failure(void)
+ *   Place the current time in our circular array of svc.startd failures.
+ */
+void
+startd_record_failure()
 {
-	struct init_action *a;
-	pid_t wpid;
+	int index = startd_failure_index++ % NSTARTD_FAILURE_TIMES;
 
-	if (argc > 1 && !strcmp(argv[1], "-q")) {
-		return kill(1,SIGHUP);
-	}
-#if !ENABLE_DEBUG_INIT
-	/* Expect to be invoked as init with PID=1 or be invoked as linuxrc */
-	if (getpid() != 1 &&
-		(!ENABLE_FEATURE_INITRD || !strstr(bb_applet_name, "linuxrc")))
-	{
-		bb_show_usage();
-	}
-	/* Set up sig handlers  -- be sure to
-	 * clear all of these in run() */
-	signal(SIGHUP, exec_signal);
-	signal(SIGQUIT, exec_signal);
-	signal(SIGUSR1, shutdown_signal);
-	signal(SIGUSR2, shutdown_signal);
-	signal(SIGINT, ctrlaltdel_signal);
-	signal(SIGTERM, shutdown_signal);
-	signal(SIGCONT, cont_handler);
-	signal(SIGSTOP, stop_handler);
-	signal(SIGTSTP, stop_handler);
-
-	/* Turn off rebooting via CTL-ALT-DEL -- we get a
-	 * SIGINT on CAD so we can shut things down gracefully... */
-	init_reboot(RB_DISABLE_CAD);
-#endif
+	startd_failure_time[index] = gethrtime();
+}
 
-	/* Figure out where the default console should be */
-	console_init();
+/*
+ * int startd_failure_rate_critical(void)
+ *   Return true if the average failure interval is less than the permitted
+ *   interval.  Implicit success if insufficient measurements for an average
+ *   exist.
+ */
+int
+startd_failure_rate_critical()
+{
+	int n = startd_failure_index;
+	hrtime_t avg_ns = 0;
 
-	/* Close whatever files are open, and reset the console. */
-	close(0);
-	close(1);
-	close(2);
-
-	if (device_open(console, O_RDWR | O_NOCTTY) == 0) {
-		set_term();
-		close(0);
-	}
-
-	chdir("/");
-	setsid();
-	{
-		const char * const *e;
-		/* Make sure environs is set to something sane */
-		for(e = environment; *e; e++)
-			putenv((char *) *e);
-	}
-	/* Hello world */
-	message(MAYBE_CONSOLE | LOG, "init started:  %s", bb_msg_full_version);
-
-	/* Make sure there is enough memory to do something useful. */
-	if (ENABLE_SWAPONOFF) {
-		struct sysinfo info;
-
-		if (!sysinfo(&info) &&
-			(info.mem_unit ? : 1) * (long long)info.totalram < MEGABYTE)
-		{
-			message(CONSOLE,"Low memory: forcing swapon.");
-			/* swapon -a requires /proc typically */
-			new_init_action(SYSINIT, "/bin/mount -t proc proc /proc", "");
-			/* Try to turn on swap */
-			new_init_action(SYSINIT, "/sbin/swapon -a", "");
-			run_actions(SYSINIT);   /* wait and removing */
-		}
-	}
+	if (startd_failure_index < NSTARTD_FAILURE_TIMES)
+		return (0);
 
-	/* Check if we are supposed to be in single user mode */
-	if (argc > 1 && (!strcmp(argv[1], "single") ||
-					 !strcmp(argv[1], "-s") || !strcmp(argv[1], "1"))) {
-		/* Start a shell on console */
-		new_init_action(RESPAWN, bb_default_login_shell, "");
-	} else {
-		/* Not in single user mode -- see what inittab says */
+	avg_ns =
+	    (startd_failure_time[(n - 1) % NSTARTD_FAILURE_TIMES] -
+	    startd_failure_time[n % NSTARTD_FAILURE_TIMES]) /
+	    NSTARTD_FAILURE_TIMES;
 
-		/* NOTE that if CONFIG_FEATURE_USE_INITTAB is NOT defined,
-		 * then parse_inittab() simply adds in some default
-		 * actions(i.e., runs INIT_SCRIPT and then starts a pair
-		 * of "askfirst" shells */
-		parse_inittab();
-	}
-
-#ifdef CONFIG_SELINUX
-	if (getenv("SELINUX_INIT") == NULL) {
-		int enforce = 0;
-
-		putenv("SELINUX_INIT=YES");
-		if (selinux_init_load_policy(&enforce) == 0) {
-			execv(argv[0], argv);
-		} else if (enforce > 0) {
-			/* SELinux in enforcing mode but load_policy failed */
-			/* At this point, we probably can't open /dev/console, so log() won't work */
-			message(CONSOLE,"Unable to load SELinux Policy. Machine is in enforcing mode. Halting now.");
-			exit(1);
-		}
-	}
-#endif /* CONFIG_SELINUX */
+	return (avg_ns < STARTD_FAILURE_RATE_NS);
+}
 
-	/* Make the command line just say "init"  -- thats all, nothing else */
-	fixup_argv(argc, argv, "init");
+/*
+ * returns string that must be free'd
+ */
 
-	/* Now run everything that needs to be run */
+static char
+*audit_boot_msg()
+{
+	char		*b, *p;
+	char		desc[] = "booted";
+	zoneid_t	zid = getzoneid();
+
+	b = malloc(sizeof (desc) + MAXNAMELEN + 3);
+	if (b == NULL)
+		return (b);
+
+	p = b;
+	p += strlcpy(p, desc, sizeof (desc));
+	if (zid != GLOBAL_ZONEID) {
+		p += strlcpy(p, ": ", 3);
+		(void) getzonenamebyid(zid, p, MAXNAMELEN);
+	}
+	return (b);
+}
 
-	/* First run the sysinit command */
-	run_actions(SYSINIT);
+/*
+ * Generate AUE_init_solaris audit record.  Return 1 if
+ * auditing is enabled in case the caller cares.
+ *
+ * In the case of userint() or a local zone invocation of
+ * one_true_init, the process initially contains the audit
+ * characteristics of the process that invoked init.  The first pass
+ * through here uses those characteristics then for the case of
+ * one_true_init in a local zone, clears them so subsequent system
+ * state changes won't be attributed to the person who booted the
+ * zone.
+ */
+static int
+audit_put_record(int pass_fail, int status, char *msg)
+{
+	adt_session_data_t	*ah;
+	adt_event_data_t	*event;
 
-	/* Next run anything that wants to block */
-	run_actions(WAIT);
+	if (!adt_audit_enabled())
+		return (0);
 
-	/* Next run anything to be run only once */
-	run_actions(ONCE);
+	/*
+	 * the PROC_DATA picks up the context to tell whether this is
+	 * an attributed record (auid = -2 is unattributed)
+	 */
+	if (adt_start_session(&ah, NULL, ADT_USE_PROC_DATA)) {
+		console(B_TRUE, "audit failure:  %s\n", strerror(errno));
+		return (1);
+	}
+	event = adt_alloc_event(ah, ADT_init_solaris);
+	if (event == NULL) {
+		console(B_TRUE, "audit failure:  %s\n", strerror(errno));
+		(void) adt_end_session(ah);
+		return (1);
+	}
+	event->adt_init_solaris.info = msg;	/* NULL is ok here */
 
-#ifdef CONFIG_FEATURE_USE_INITTAB
-	/* Redefine SIGHUP to reread /etc/inittab */
-	signal(SIGHUP, reload_signal);
-#else
-	signal(SIGHUP, SIG_IGN);
-#endif /* CONFIG_FEATURE_USE_INITTAB */
+	if (adt_put_event(event, pass_fail, status)) {
+		console(B_TRUE, "audit failure:  %s\n", strerror(errno));
+		(void) adt_end_session(ah);
+		return (1);
+	}
+	adt_free_event(event);
 
+	(void) adt_end_session(ah);
 
-	/* Now run the looping stuff for the rest of forever */
-	while (1) {
-		/* run the respawn stuff */
-		run_actions(RESPAWN);
-
-		/* run the askfirst stuff */
-		run_actions(ASKFIRST);
-
-		/* Don't consume all CPU time -- sleep a bit */
-		sleep(1);
-
-		/* Wait for a child process to exit */
-		wpid = wait(NULL);
-		while (wpid > 0) {
-			/* Find out who died and clean up their corpse */
-			for (a = init_action_list; a; a = a->next) {
-				if (a->pid == wpid) {
-					/* Set the pid to 0 so that the process gets
-					 * restarted by run_actions() */
-					a->pid = 0;
-					message(LOG, "Process '%s' (pid %d) exited.  "
-							"Scheduling it for restart.",
-							a->command, wpid);
-				}
-			}
-			/* see if anyone else is waiting to be reaped */
-			wpid = waitpid (-1, NULL, WNOHANG);
-		}
-	}
+	return (1);
 }
diff -rupN busybox-1.2.0/init/init_shared.c busybox-1.2.0solaris/init/init_shared.c
--- busybox-1.2.0/init/init_shared.c	2006-07-01 02:42:12.000000000 +0400
+++ busybox-1.2.0solaris/init/init_shared.c	2009-04-18 09:49:04.881219762 +0400
@@ -34,7 +34,7 @@ int bb_shutdown_system(unsigned long mag
 #ifndef RB_ENABLE_CAD
 #define RB_ENABLE_CAD	0x89abcdef
 #endif
-	reboot(RB_ENABLE_CAD);
+	reboot(RB_ENABLE_CAD, NULL);
 
 	openlog(bb_applet_name, 0, pri);
 
@@ -62,7 +62,7 @@ int bb_shutdown_system(unsigned long mag
 
 	sync();
 
-	reboot(magic);
+	reboot(magic,NULL);
 	return 0; /* Shrug */
 }
 #endif
diff -rupN busybox-1.2.0/init/libcontract_priv.h busybox-1.2.0solaris/init/libcontract_priv.h
--- busybox-1.2.0/init/libcontract_priv.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/init/libcontract_priv.h	2009-04-01 03:48:17.000000000 +0400
@@ -0,0 +1,50 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+#ifndef	_LIBCONTRACT_PRIV_H
+#define	_LIBCONTRACT_PRIV_H
+
+#pragma ident	"%Z%%M%	%I%	%E% SMI"
+
+#include <sys/contract.h>
+#include <libcontract.h>
+#include <stdio.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+extern int contract_latest(ctid_t *);
+extern int contract_open(ctid_t, const char *, const char *, int);
+extern int contract_abandon_id(ctid_t);
+extern ctid_t getctid(void);
+extern void contract_event_dump(FILE *, ct_evthdl_t, int);
+extern void contract_negend_dump(FILE *, ct_evthdl_t);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _LIBCONTRACT_PRIV_H */
diff -rupN busybox-1.2.0/libbb/Makefile.in busybox-1.2.0solaris/libbb/Makefile.in
--- busybox-1.2.0/libbb/Makefile.in	2006-07-01 02:42:08.000000000 +0400
+++ busybox-1.2.0solaris/libbb/Makefile.in	2009-04-18 10:20:11.767053730 +0400
@@ -34,7 +34,7 @@ LIBBB-y:= \
 	get_terminal_width_height.c fclose_nonstdin.c fflush_stdout_and_exit.c \
 	getopt_ulflags.c default_error_retval.c wfopen_input.c speed_table.c \
 	perror_nomsg_and_die.c perror_nomsg.c skip_whitespace.c bb_askpass.c \
-	warn_ignoring_args.c concat_subpath_file.c vfork_daemon_rexec.c \
+	warn_ignoring_args.c concat_subpath_file.c  \
 	bb_do_delay.c
 
 # conditionally compiled objects:
@@ -48,8 +48,6 @@ LIBBB-$(CONFIG_FEATURE_HTTPD_AUTH_MD5)+=
 LIBBB-$(CONFIG_VLOCK)+= correct_password.c
 LIBBB-$(CONFIG_SU)+= correct_password.c
 LIBBB-$(CONFIG_LOGIN)+= correct_password.c
-LIBBB-$(CONFIG_DF)+= find_mount_point.c
-LIBBB-$(CONFIG_EJECT)+= find_mount_point.c
 
 LIBBB-y:=$(patsubst %,$(srcdir)/%,$(LIBBB-y))
 
diff -rupN busybox-1.2.0/libbb/find_mount_point.c busybox-1.2.0solaris/libbb/find_mount_point.c
--- busybox-1.2.0/libbb/find_mount_point.c	2006-07-01 02:42:08.000000000 +0400
+++ busybox-1.2.0solaris/libbb/find_mount_point.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,54 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * Utility routines.
- *
- * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
- */
-
-#include <stdio.h>
-#include <string.h>
-#include "libbb.h"
-
-
-#include <mntent.h>
-/*
- * Given a block device, find the mount table entry if that block device
- * is mounted.
- *
- * Given any other file (or directory), find the mount table entry for its
- * filesystem.
- */
-struct mntent *find_mount_point(const char *name, const char *table)
-{
-	struct stat s;
-	dev_t mountDevice;
-	FILE *mountTable;
-	struct mntent *mountEntry;
-
-	if (stat(name, &s) != 0)
-		return 0;
-
-	if ((s.st_mode & S_IFMT) == S_IFBLK)
-		mountDevice = s.st_rdev;
-	else
-		mountDevice = s.st_dev;
-
-
-	if ((mountTable = setmntent(table ? table : bb_path_mtab_file, "r")) == 0)
-		return 0;
-
-	while ((mountEntry = getmntent(mountTable)) != 0) {
-
-			if(strcmp(name, mountEntry->mnt_dir) == 0
-			|| strcmp(name, mountEntry->mnt_fsname) == 0)	/* String match. */
-			break;
-		if (stat(mountEntry->mnt_fsname, &s) == 0 && s.st_rdev == mountDevice)	/* Match the device. */
-			break;
-		if (stat(mountEntry->mnt_dir, &s) == 0 && s.st_dev == mountDevice)	/* Match the directory's mount point. */
-			break;
-	}
-	endmntent(mountTable);
-	return mountEntry;
-}
diff -rupN busybox-1.2.0/libbb/md5.c busybox-1.2.0solaris/libbb/md5.c
--- busybox-1.2.0/libbb/md5.c	2006-07-01 02:42:08.000000000 +0400
+++ busybox-1.2.0solaris/libbb/md5.c	2009-04-17 16:55:49.632065462 +0400
@@ -18,6 +18,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/byteorder.h>
+#define bswap_32	BSWAP_32
 
 #include "libbb.h"
 
diff -rupN busybox-1.2.0/libbb/verror_msg.c busybox-1.2.0solaris/libbb/verror_msg.c
--- busybox-1.2.0/libbb/verror_msg.c	2006-07-01 02:42:08.000000000 +0400
+++ busybox-1.2.0solaris/libbb/verror_msg.c	2009-04-18 10:11:15.249256074 +0400
@@ -17,5 +17,5 @@ void bb_verror_msg(const char *s, va_lis
 {
 	fflush(stdout);
 	fprintf(stderr, "%s: ", bb_applet_name);
-	vfprintf(stderr, s, p);
+	fprintf(stderr, s, p);
 }
diff -rupN busybox-1.2.0/libbb/vfork_daemon_rexec.c busybox-1.2.0solaris/libbb/vfork_daemon_rexec.c
--- busybox-1.2.0/libbb/vfork_daemon_rexec.c	2006-07-01 02:42:08.000000000 +0400
+++ busybox-1.2.0solaris/libbb/vfork_daemon_rexec.c	1970-01-01 03:00:00.000000000 +0300
@@ -1,67 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * Rexec program for system have fork() as vfork() with foreground option
- *
- * Copyright (C) Vladimir N. Oleynik <dzo@simtreas.ru>
- * Copyright (C) 2003 Russ Dill <Russ.Dill@asu.edu>
- *
- * daemon() portion taken from uClibc:
- *
- * Copyright (c) 1991, 1993
- *      The Regents of the University of California.  All rights reserved.
- *
- * Modified for uClibc by Erik Andersen <andersee@debian.org>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this tarball for details.
- */
-
-#include <unistd.h>
-#include <stdio.h>
-#include <fcntl.h>
-#include <paths.h>
-#include "libbb.h"
-
-
-#ifdef BB_NOMMU
-void vfork_daemon_rexec(int nochdir, int noclose,
-		int argc, char **argv, char *foreground_opt)
-{
-	int fd;
-	char **vfork_args;
-	int a = 0;
-
-	setsid();
-
-	if (!nochdir)
-		chdir("/");
-
-	if (!noclose && (fd = open(bb_dev_null, O_RDWR, 0)) != -1) {
-		dup2(fd, STDIN_FILENO);
-		dup2(fd, STDOUT_FILENO);
-		dup2(fd, STDERR_FILENO);
-		if (fd > 2)
-			close(fd);
-	}
-
-	vfork_args = xcalloc(sizeof(char *), argc + 3);
-	vfork_args[a++] = "/bin/busybox";
-	while(*argv) {
-	    vfork_args[a++] = *argv;
-	    argv++;
-	}
-	vfork_args[a] = foreground_opt;
-	switch (vfork()) {
-	case 0: /* child */
-		/* Make certain we are not a session leader, or else we
-		 * might reacquire a controlling terminal */
-		if (vfork())
-			_exit(0);
-		execv(vfork_args[0], vfork_args);
-		bb_perror_msg_and_die("execv %s", vfork_args[0]);
-	case -1: /* error */
-		bb_perror_msg_and_die("vfork");
-	default: /* parent */
-		exit(0);
-	}
-}
-#endif /* BB_NOMMU */
diff -rupN busybox-1.2.0/libbb/vherror_msg.c busybox-1.2.0solaris/libbb/vherror_msg.c
--- busybox-1.2.0/libbb/vherror_msg.c	2006-07-01 02:42:08.000000000 +0400
+++ busybox-1.2.0solaris/libbb/vherror_msg.c	2009-04-18 10:14:03.959445642 +0400
@@ -33,5 +33,5 @@ void bb_vherror_msg(const char *s, va_li
 	bb_verror_msg(s, p);
 	if (*s)
 		fputs(": ", stderr);
-	herror("");
+	printf("");
 }
diff -rupN busybox-1.2.0/libbb/xconnect.c busybox-1.2.0solaris/libbb/xconnect.c
--- busybox-1.2.0/libbb/xconnect.c	2006-07-01 02:42:08.000000000 +0400
+++ busybox-1.2.0solaris/libbb/xconnect.c	2009-04-18 17:08:27.644564574 +0400
@@ -49,24 +49,44 @@ unsigned short bb_lookup_port(const char
 	return port_nr;
 }
 
-void bb_lookup_host(struct sockaddr_in *s_in, const char *host)
+void bb_lookup_host(struct sockaddr_in s_in, const char *host)
 {
 	struct hostent *he;
-
-	memset(s_in, 0, sizeof(struct sockaddr_in));
-	s_in->sin_family = AF_INET;
+	memset(&s_in, 0, sizeof(struct sockaddr_in));
+	s_in.sin_family = AF_INET;
 	he = xgethostbyname(host);
-	memcpy(&(s_in->sin_addr), he->h_addr_list[0], he->h_length);
+	memcpy(&(s_in.sin_addr), he->h_addr_list[0], he->h_length);
+	
+}
+
+int xconnect(struct sockaddr_in servaddr, const char *host, const char *port)
+{
+
+	bzero(&servaddr,sizeof(servaddr));
+        servaddr.sin_family = AF_INET;
+	servaddr.sin_port = htons(atoi(port));
+	inet_aton(host, &servaddr.sin_addr);
+		     
+	int s = bb_xsocket(AF_INET, SOCK_STREAM, 0);
+	if (connect(s, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
+	{
+		if (ENABLE_FEATURE_CLEAN_UP) close(s);
+		bb_perror_msg_and_die("Unable to connect to remote host (%s)",
+				inet_ntoa(servaddr.sin_addr));
+	}
+	return s;
 }
 
-int xconnect(struct sockaddr_in *s_addr)
+/*
+int xconnect(struct sockaddr_in s_in)
 {
 	int s = bb_xsocket(AF_INET, SOCK_STREAM, 0);
-	if (connect(s, (struct sockaddr *)s_addr, sizeof(struct sockaddr_in)) < 0)
+	if (connect(s, (struct sockaddr *)&s_in, sizeof(s_in)) < 0)
 	{
 		if (ENABLE_FEATURE_CLEAN_UP) close(s);
 		bb_perror_msg_and_die("Unable to connect to remote host (%s)",
-				inet_ntoa(s_addr->sin_addr));
+				inet_ntoa(s_in.sin_addr));
 	}
 	return s;
 }
+*/
diff -rupN busybox-1.2.0/networking/Makefile busybox-1.2.0solaris/networking/Makefile
--- busybox-1.2.0/networking/Makefile	2006-07-01 02:42:02.000000000 +0400
+++ busybox-1.2.0solaris/networking/Makefile	2009-04-18 09:59:21.798812447 +0400
@@ -15,7 +15,7 @@ NETWORKING_DIR:=./
 include $(top_srcdir)/Rules.mak
 include $(top_builddir)/.config
 include Makefile.in
-all: $(libraries-y)
+all: $(libraries-y) 
 -include $(top_builddir)/.depend
 
 clean:
diff -rupN busybox-1.2.0/networking/telnet.c busybox-1.2.0solaris/networking/telnet.c
--- busybox-1.2.0/networking/telnet.c	2006-07-01 02:42:02.000000000 +0400
+++ busybox-1.2.0solaris/networking/telnet.c	2009-04-18 15:54:50.688474048 +0400
@@ -605,6 +605,24 @@ static void cookmode(void)
 {
 	if (G.do_termios) tcsetattr(0, TCSADRAIN, &G.termios_def);
 }
+void
+cfmakeraw(t)
+    struct termios *t;
+    {
+    
+//	_DIAGASSERT(t != NULL);
+	
+	    t->c_iflag &= ~(IMAXBEL|IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);
+		t->c_oflag &= ~OPOST;
+		    t->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
+			t->c_cflag &= ~(CSIZE|PARENB);
+			    t->c_cflag |= CS8;
+				/* XXX set MIN/TIME */
+				}
+				
+
+
+
 
 int telnet_main(int argc, char** argv)
 {
@@ -650,11 +668,10 @@ int telnet_main(int argc, char** argv)
 	} else
 		bb_show_usage();
 #else
-	bb_lookup_host(&s_in, argv[1]);
+	bb_lookup_host(s_in, argv[1]);
 	s_in.sin_port = bb_lookup_port((argc == 3) ? argv[2] : "telnet", "tcp", 23);
 #endif
-
-	G.netfd = xconnect(&s_in);
+	G.netfd = xconnect(s_in, argv[1], (argc == 3) ? argv[2] : 23);
 
 	setsockopt(G.netfd, SOL_SOCKET, SO_KEEPALIVE, &one, sizeof one);
 
diff -rupN busybox-1.2.0/networking/wget.c busybox-1.2.0solaris/networking/wget.c
--- busybox-1.2.0/networking/wget.c	2006-07-01 02:42:02.000000000 +0400
+++ busybox-1.2.0solaris/networking/wget.c	2009-04-18 16:30:12.137888508 +0400
@@ -22,7 +22,7 @@ struct host_info {
 };
 
 static void parse_url(char *url, struct host_info *h);
-static FILE *open_socket(struct sockaddr_in *s_in);
+static FILE *open_socket(struct sockaddr_in s_in, char *host, char *port);
 static char *gethdr(char *buf, size_t bufsiz, FILE *fp, int *istrunc);
 static int ftpcmd(char *s1, char *s2, FILE *fp, char *buf);
 
@@ -281,7 +281,7 @@ int wget_main(int argc, char **argv)
 	/* We want to do exactly _one_ DNS lookup, since some
 	 * sites (i.e. ftp.us.debian.org) use round-robin DNS
 	 * and we want to connect to only one IP... */
-	bb_lookup_host(&s_in, server.host);
+	bb_lookup_host(s_in, server.host);
 	s_in.sin_port = server.port;
 	if (quiet_flag==FALSE) {
 		fprintf(stdout, "Connecting to %s[%s]:%d\n",
@@ -302,7 +302,7 @@ int wget_main(int argc, char **argv)
 			 * Open socket to http server
 			 */
 			if (sfp) fclose(sfp);
-			sfp = open_socket(&s_in);
+			sfp = open_socket(s_in, server.host, server.port);
 
 			/*
 			 * Send HTTP request.
@@ -403,7 +403,7 @@ read_response:
 							server.host = target.host;
 							server.port = target.port;
 						}
-						bb_lookup_host(&s_in, server.host);
+						bb_lookup_host(s_in, server.host);
 						s_in.sin_port = server.port;
 						break;
 					}
@@ -421,7 +421,7 @@ read_response:
 		if (! target.user)
 			target.user = bb_xstrdup("anonymous:busybox@");
 
-		sfp = open_socket(&s_in);
+		sfp = open_socket(s_in, server.host, server.port);
 		if (ftpcmd(NULL, NULL, sfp, buf) != 220)
 			close_delete_and_die("%s", buf+4);
 
@@ -468,7 +468,7 @@ read_response:
 		s = strrchr(buf, ',');
 		port += atoi(s+1) * 256;
 		s_in.sin_port = htons(port);
-		dfp = open_socket(&s_in);
+		dfp = open_socket(s_in, server.host, server.port);
 
 		if (do_continue) {
 			sprintf(buf, "REST %ld", beg_range);
@@ -591,11 +591,11 @@ void parse_url(char *url, struct host_in
 }
 
 
-FILE *open_socket(struct sockaddr_in *s_in)
+FILE *open_socket(struct sockaddr_in s_in, char *host, char *port)
 {
 	FILE *fp;
-
-	fp = fdopen(xconnect(s_in), "r+");
+	printf("FDhost: %s port: %s\n",host,port);
+	fp = fdopen(xconnect(s_in, host, port), "r+");
 	if (fp == NULL)
 		bb_perror_msg_and_die("fdopen()");
 
diff -rupN busybox-1.2.0/procps/priv_utils.h busybox-1.2.0solaris/procps/priv_utils.h
--- busybox-1.2.0/procps/priv_utils.h	1970-01-01 03:00:00.000000000 +0300
+++ busybox-1.2.0solaris/procps/priv_utils.h	2009-04-01 03:48:10.000000000 +0400
@@ -0,0 +1,96 @@
+/*
+ * CDDL HEADER START
+ *
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License, Version 1.0 only
+ * (the "License").  You may not use this file except in compliance
+ * with the License.
+ *
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
+ */
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * This is a private header file.  The interfaces in this header are
+ * subject to change or removal without notice.
+ * The Sun classification is "Project Private".
+ */
+
+#ifndef	_PRIV_UTILS_H
+#define	_PRIV_UTILS_H
+
+#pragma ident	"%Z%%M%	%I%	%E% SMI"
+
+#include <priv.h>
+
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#define	PU_RESETGROUPS		0x0001	/* Remove supplemental groups */
+#define	PU_LIMITPRIVS		0x0002	/* L=P */
+#define	PU_INHERITPRIVS		0x0004	/* I=P */
+#define	PU_CLEARLIMITSET	0x0008	/* L=0 */
+
+/*
+ * Should be run at the start of a set-uid root program;
+ * if the effective uid == 0 and the real uid != 0,
+ * the specified privileges X are assigned as follows:
+ *
+ * P = I + X + B (B added insofar allowable from L)
+ * E = I
+ * (i.e., the requested privileges are dormant, not active)
+ * Then resets all uids to the invoking uid; no-op if euid == uid == 0.
+ *
+ * flags: PU_LIMITPRIVS, PU_CLEARLIMITSET, PU_CLEARINHERITABLE
+ *
+ * Caches the required privileges for use by __priv_bracket().
+ *
+ */
+extern int __init_suid_priv(int, ...);
+
+/*
+ * After calling __init_suid_priv we can __priv_bracket(PRIV_ON) and
+ * __priv_bracket(PRIV_OFF) and __priv_relinquish to get rid of the
+ * privileges forever.
+ */
+extern int __priv_bracket(priv_op_t);
+extern void __priv_relinquish(void);
+
+/*
+ * Runs at the start of a daemon, assuming euid=uid=0.
+ *
+ * P = E = B + X
+ *
+ * Then resets uids.
+ *
+ * Flags: all
+ *
+ */
+extern int __init_daemon_priv(int, uid_t, gid_t, ...);
+
+/*
+ * Runs after the daemon is initialized, and gives up the privileges
+ * passed in as argument because they are no longer needed.
+ * Reenables core dumps.
+ */
+extern void __fini_daemon_priv(const char *, ...);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _PRIV_UTILS_H */
diff -rupN busybox-1.2.0/procps/ps.c busybox-1.2.0solaris/procps/ps.c
--- busybox-1.2.0/procps/ps.c	2006-07-01 02:42:12.000000000 +0400
+++ busybox-1.2.0solaris/procps/ps.c	2009-04-21 09:12:31.059944626 +0400
@@ -1,130 +1,1980 @@
-/* vi: set sw=4 ts=4: */
 /*
- * Mini ps implementation(s) for busybox
+ * CDDL HEADER START
  *
- * Copyright (C) 1999-2004 by Erik Andersen <andersen@codepoet.org>
+ * The contents of this file are subject to the terms of the
+ * Common Development and Distribution License (the "License").
+ * You may not use this file except in compliance with the License.
  *
- * Licensed under the GPL v2, see the file LICENSE in this tarball.
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
+ * or http://www.opensolaris.org/os/licensing.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ *
+ * When distributing Covered Code, include this CDDL HEADER in each
+ * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
+ * If applicable, add the following below this CDDL HEADER, with the
+ * fields enclosed by brackets "[]" replaced with your own identifying
+ * information: Portions Copyright [yyyy] [name of copyright owner]
+ *
+ * CDDL HEADER END
  */
 
-#include "busybox.h"
+/*
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ */
+
+/*	Copyright (c) 1984, 1986, 1987, 1988, 1989 AT&T	*/
+/*	  All Rights Reserved  	*/
+
+/*
+ * ps -- print things about processes.
+ */
 #include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <errno.h>
-#include <fcntl.h>
 #include <ctype.h>
 #include <string.h>
-#include <termios.h>
-#include <sys/ioctl.h>
-#if ENABLE_SELINUX
-#include <selinux/selinux.h>  /* for is_selinux_enabled()  */
-#endif
+#include <errno.h>
+#include <fcntl.h>
+#include <pwd.h>
+#include <grp.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mkdev.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <dirent.h>
+#include <sys/signal.h>
+#include <sys/fault.h>
+#include <sys/syscall.h>
+#include <sys/time.h>
+#include <procfs.h>
+#include <locale.h>
+#include <wctype.h>
+#include <wchar.h>
+#include <libw.h>
+#include <stdarg.h>
+#include <sys/proc.h>
+#include <sys/pset.h>
+#include <project.h>
+#include <zone.h>
 
-int ps_main(int argc, char **argv)
-{
-	procps_status_t * p;
-	int i, len;
+#include "busybox.h"
 
-#if ENABLE_SELINUX
-	int use_selinux = 0;
-	security_context_t sid=NULL;
-#endif
+#define	min(a, b)	((a) > (b) ? (b) : (a))
+#define	max(a, b)	((a) < (b) ? (b) : (a))
 
-#if ENABLE_FEATURE_PS_WIDE
-	int terminal_width;
-	int w_count = 0;
+#define	NTTYS	20	/* initial size of table for -t option  */
+#define	SIZ	30	/* initial size of tables for -p, -s and -z */
 
-	bb_opt_complementally="-:ww";
+/*
+ * Size of buffer holding args for t, p, z options.
+ * Set to ZONENAME_MAX, the minimum value needed to allow any
+ * zone to be specified.
+ */
+#define	ARGSIZ ZONENAME_MAX
+
+#define	MAXUGNAME 10	/* max chars in a user/group name or printed u/g id */
+
+/* Structure for storing user or group info */
+struct ugdata {
+	id_t	id;			/* numeric user-id or group-id */
+	char	name[MAXUGNAME+1];	/* user/group name, null terminated */
+};
+
+struct ughead {
+	size_t	size;		/* number of ugdata structs allocated */
+	size_t	nent;		/* number of active entries */
+	struct ugdata *ent;	/* pointer to array of actual entries */
+};
+
+enum fname {	/* enumeration of field names */
+	F_USER,		/* effective user of the process */
+	F_RUSER,	/* real user of the process */
+	F_GROUP,	/* effective group of the process */
+	F_RGROUP,	/* real group of the process */
+	F_UID,		/* numeric effective uid of the process */
+	F_RUID,		/* numeric real uid of the process */
+	F_GID,		/* numeric effective gid of the process */
+	F_RGID,		/* numeric real gid of the process */
+	F_PID,		/* process id */
+	F_PPID,		/* parent process id */
+	F_PGID,		/* process group id */
+	F_SID,		/* session id */
+	F_PSR,		/* bound processor */
+	F_LWP,		/* lwp-id */
+	F_NLWP,		/* number of lwps */
+	F_OPRI,		/* old priority (obsolete) */
+	F_PRI,		/* new priority */
+	F_F,		/* process flags */
+	F_S,		/* letter indicating the state */
+	F_C,		/* processor utilization (obsolete) */
+	F_PCPU,		/* percent of recently used cpu time */
+	F_PMEM,		/* percent of physical memory used (rss) */
+	F_OSZ,		/* virtual size of the process in pages */
+	F_VSZ,		/* virtual size of the process in kilobytes */
+	F_RSS,		/* resident set size of the process in kilobytes */
+	F_NICE,		/* "nice" value of the process */
+	F_CLASS,	/* scheduler class */
+	F_STIME,	/* start time of the process, hh:mm:ss or Month Day */
+	F_ETIME,	/* elapsed time of the process, [[dd-]hh:]mm:ss */
+	F_TIME,		/* cpu time of the process, [[dd-]hh:]mm:ss */
+	F_TTY,		/* name of the controlling terminal */
+	F_ADDR,		/* address of the process (obsolete) */
+	F_WCHAN,	/* wait channel (sleep condition variable) */
+	F_FNAME,	/* file name of command */
+	F_COMM,		/* name of command (argv[0] value) */
+	F_ARGS,		/* name of command plus all its arguments */
+	F_TASKID,	/* task id */
+	F_PROJID,	/* project id */
+	F_PROJECT,	/* project name of the process */
+	F_PSET,		/* bound processor set */
+	F_ZONE,		/* zone name */
+	F_ZONEID,	/* zone id */
+	F_CTID,		/* process contract id */
+	F_LGRP		/* process home lgroup */
+};
+
+struct field {
+	struct field	*next;		/* linked list */
+	int		fname;		/* field index */
+	const char	*header;	/* header to use */
+	int		width;		/* width of field */
+};
+
+static	struct field *fields = NULL;	/* fields selected via -o */
+static	int do_header = 0;
+static	struct timeval now;
+
+/* array of defined fields, in fname order */
+struct def_field {
+	const char *fname;
+	const char *header;
+	int width;
+	int minwidth;
+};
+
+static struct def_field fname[] = {
+	/* fname	header		width	minwidth */
+	{ "user",	"USER",		8,	8	},
+	{ "ruser",	"RUSER",	8,	8	},
+	{ "group",	"GROUP",	8,	8	},
+	{ "rgroup",	"RGROUP",	8,	8	},
+	{ "uid",	"UID",		5,	5	},
+	{ "ruid",	"RUID",		5,	5	},
+	{ "gid",	"GID",		5,	5	},
+	{ "rgid",	"RGID",		5,	5	},
+	{ "pid",	"PID",		5,	5	},
+	{ "ppid",	"PPID",		5,	5	},
+	{ "pgid",	"PGID",		5,	5	},
+	{ "sid",	"SID",		5,	5	},
+	{ "psr",	"PSR",		3,	2	},
+	{ "lwp",	"LWP",		6,	2	},
+	{ "nlwp",	"NLWP",		4,	2	},
+	{ "opri",	"PRI",		3,	2	},
+	{ "pri",	"PRI",		3,	2	},
+	{ "f",		"F",		2,	2	},
+	{ "s",		"S",		1,	1	},
+	{ "c",		"C",		2,	2	},
+	{ "pcpu",	"%CPU",		4,	4	},
+	{ "pmem",	"%MEM",		4,	4	},
+	{ "osz",	"SZ",		4,	4	},
+	{ "vsz",	"VSZ",		4,	4	},
+	{ "rss",	"RSS",		4,	4	},
+	{ "nice",	"NI",		2,	2	},
+	{ "class",	"CLS",		4,	2	},
+	{ "stime",	"STIME",	8,	8	},
+	{ "etime",	"ELAPSED",	11,	7	},
+	{ "time",	"TIME",		11,	5	},
+	{ "tty",	"TT",		7,	7	},
+#ifdef _LP64
+	{ "addr",	"ADDR",		16,	8	},
+	{ "wchan",	"WCHAN",	16,	8	},
 #else
-# define terminal_width 79
+	{ "addr",	"ADDR",		8,	8	},
+	{ "wchan",	"WCHAN",	8,	8	},
 #endif
+	{ "fname",	"COMMAND",	8,	8	},
+	{ "comm",	"COMMAND",	80,	8	},
+	{ "args",	"COMMAND",	80,	80	},
+	{ "taskid",	"TASKID",	5,	5	},
+	{ "projid",	"PROJID",	5,	5	},
+	{ "project",	"PROJECT",	8,	8	},
+	{ "pset",	"PSET",		3,	3	},
+	{ "zone",	"ZONE",		8,	8	},
+	{ "zoneid",	"ZONEID",	5,	5	},
+	{ "ctid",	"CTID",		5,	5	},
+	{ "lgrp",	"LGRP",		4,	2 	},
+};
+
+#define	NFIELDS	(sizeof (fname) / sizeof (fname[0]))
+
+static	int	retcode = 1;
+static	int	lflg;
+static	int	Aflg;
+static	int	aflg;
+static	int	dflg;
+static	int	Lflg;
+static	int	Pflg;
+static	int	yflg;
+static	int	pflg;
+static	int	fflg;
+static	int	cflg;
+static	int	jflg;
+static	int	tflg;
+static	int	zflg;
+static	int	Zflg;
+static	int	Hflg;
+static	uid_t	tuid = (uid_t)-1;
+static	int	errflg;
+
+static	int	ndev;		/* number of devices */
+static	int	maxdev;		/* number of devl structures allocated */
+
+#define	DNINCR	100
+#define	DNSIZE	14
+static struct devl {		/* device list   */
+	char	dname[DNSIZE];	/* device name   */
+	dev_t	ddev;		/* device number */
+} *devl;
+
+static	struct tty {
+	char *tname;
+	dev_t tdev;
+} *tty = NULL;			/* for t option */
+static	size_t	ttysz = 0;
+static	int	ntty = 0;
+
+static	pid_t	*pid = NULL;	/* for p option */
+static	size_t	pidsz = 0;
+static	size_t	npid = 0;
+
+static	zoneid_t *zoneid = NULL; /* for z option */
+static	size_t	zoneidsz = 0;
+static	int	nzoneid = 0;
+
+static	int	kbytes_per_page;
+static	int	pidwidth;
+
+static	char	*procdir = "/proc";	/* standard /proc directory */
+
+static struct ughead	euid_tbl;	/* table to store selected euid's */
+static struct ughead	ruid_tbl;	/* table to store selected real uid's */
+static struct ughead	egid_tbl;	/* table to store selected egid's */
+static struct ughead	rgid_tbl;	/* table to store selected real gid's */
+static prheader_t *lpsinfobuf;		/* buffer to contain lpsinfo */
+static size_t	lpbufsize;
+
+/*
+ * This constant defines the sentinal number of process IDs below which we
+ * only examine individual entries in /proc rather than scanning through
+ * /proc. This optimization is a huge win in the common case.
+ */
+#define	PTHRESHOLD	40
+
+static	char	*getarg(char **);
+static	char	*gettty(psinfo_t *);
+static	int	prfind(int, psinfo_t *, char **);
+static	void	prcom(psinfo_t *, char *);
+static	void	prtpct(ushort_t, int);
+static	void	print_time(time_t, int);
+static	void	print_field(psinfo_t *, struct field *, const char *);
+static	void	print_zombie_field(psinfo_t *, struct field *, const char *);
+static	void	pr_fields(psinfo_t *, const char *,
+		void (*print_fld)(psinfo_t *, struct field *, const char *));
+static	int	search(pid_t *, int, pid_t);
+static	int	uconv(struct ughead *);
+static	int	gconv(struct ughead *);
+static	void	prtime(timestruc_t, int, int);
+static	void	przom(psinfo_t *);
+static	int	namencnt(char *, int, int);
+static	char	*err_string(int);
+static	int	print_proc(char *pname);
+static	time_t	delta_secs(const timestruc_t *);
+static	int	str2id(const char *, pid_t *, long, long);
+static	int	str2uid(const char *,  uid_t *, unsigned long, unsigned long);
+static	void	*Realloc(void *, size_t);
+static	int	pidcmp(const void *p1, const void *p2);
+
+static	int	stdmain(int, char **);
+
+int
+ps_main(int argc, char **argv)
+{
+
+	if (argv[1] != NULL) {
+		return (stdmain(argc, argv));
+	}
+	return (stdmain(argc, argv));
+}
 
-#if ENABLE_FEATURE_PS_WIDE || ENABLE_SELINUX
-	/* handle arguments */
-#if ENABLE_FEATURE_PS_WIDE && ENABLE_SELINUX
-	i = bb_getopt_ulflags(argc, argv, "wc", &w_count);
-#elif ENABLE_FEATURE_PS_WIDE && !ENABLE_SELINUX
-	bb_getopt_ulflags(argc, argv, "w", &w_count);
-#else /* !ENABLE_FEATURE_PS_WIDE && ENABLE_SELINUX */
-	i = bb_getopt_ulflags(argc, argv, "c");
+static int
+stdmain(int argc, char **argv)
+{
+	char	*p;
+	char	*p1;
+	char	*parg;
+	int	c;
+	int	i;
+	int	pgerrflg = 0;	/* err flg: non-numeric arg w/p & g options */
+	size_t	size, len;
+	DIR	*dirp;
+	struct dirent *dentp;
+	pid_t	maxpid;
+	pid_t	id;
+	int	ret;
+	char	loc_stime_str[32];
+
+	(void) setlocale(LC_ALL, "");
+#if !defined(TEXT_DOMAIN)	/* Should be defined by cc -D */
+#define	TEXT_DOMAIN	"SYS_TEST"	/* Use this only if it weren't */
 #endif
-#if ENABLE_FEATURE_PS_WIDE
-	/* if w is given once, GNU ps sets the width to 132,
-	 * if w is given more than once, it is "unlimited"
-	 */
-	if(w_count) {
-		terminal_width = (w_count==1) ? 132 : INT_MAX;
-	} else {
-		get_terminal_width_height(1, &terminal_width, NULL);
-		/* Go one less... */
-		terminal_width--;
+	(void) textdomain(TEXT_DOMAIN);
+
+	(void) memset(&euid_tbl, 0, sizeof (euid_tbl));
+	(void) memset(&ruid_tbl, 0, sizeof (ruid_tbl));
+	(void) memset(&egid_tbl, 0, sizeof (egid_tbl));
+	(void) memset(&rgid_tbl, 0, sizeof (rgid_tbl));
+
+	kbytes_per_page = sysconf(_SC_PAGESIZE) / 1024;
+
+	(void) gettimeofday(&now, NULL);
+
+	/*
+	 * calculate width of pid fields based on configured MAXPID
+	 * (must be at least 5 to retain output format compatibility)
+	 */
+	id = maxpid = (pid_t)sysconf(_SC_MAXPID);
+	pidwidth = 1;
+	while ((id /= 10) > 0)
+		++pidwidth;
+	pidwidth = pidwidth < 5 ? 5 : pidwidth;
+
+	fname[F_PID].width = fname[F_PPID].width = pidwidth;
+	fname[F_PGID].width = fname[F_SID].width = pidwidth;
+
+	/*
+	 * TRANSLATION_NOTE
+	 * Specify the printf format with width and precision for
+	 * the STIME field.
+	 */
+	len = snprintf(loc_stime_str, sizeof (loc_stime_str),
+	    dcgettext(NULL, "%8.8s", LC_TIME), "STIME");
+	if (len >= sizeof (loc_stime_str))
+		len = sizeof (loc_stime_str) - 1;
+
+	fname[F_STIME].width = fname[F_STIME].minwidth = len;
+
+	while ((c = getopt(argc, argv, "jlfceAadLPyZH:t:p:n:o:z:"))
+	    != EOF)
+		switch (c) {
+		case 'H':		/* Show home lgroups */
+			Hflg++;
+			break;
+		case 'l':		/* long listing */
+			lflg++;
+			break;
+		case 'f':		/* full listing */
+			fflg++;
+			break;
+		case 'j':
+			jflg++;
+			break;
+		case 'c':
+			/*
+			 * Format output to reflect scheduler changes:
+			 * high numbers for high priorities and don't
+			 * print nice or p_cpu values.  'c' option only
+			 * effective when used with 'l' or 'f' options.
+			 */
+			cflg++;
+			break;
+		case 'A':		/* list every process */
+		case 'e':		/* (obsolete) list every process */
+			Aflg++;
+			tflg = pflg = 0;
+			zflg =  0;
+			break;
+		case 'a':
+			/*
+			 * Same as 'e' except no session group leaders
+			 * and no non-terminal processes.
+			 */
+			aflg++;
+			break;
+		case 'd':	/* same as e except no session leaders */
+			dflg++;
+			break;
+		case 'L':	/* show lwps */
+			Lflg++;
+			break;
+		case 'P':	/* show bound processor */
+			Pflg++;
+			break;
+		case 'y':	/* omit F & ADDR, report RSS & SZ in Kby */
+			yflg++;
+			break;
+		case 'n':	/* no longer needed; retain as no-op */
+			(void) fprintf(stderr,
+			    gettext("ps: warning: -n option ignored\n"));
+			break;
+		case 't':		/* terminals */
+#define	TSZ	30
+			tflg++;
+			p1 = optarg;
+			do {
+				char nambuf[TSZ+6];	/* for "/dev/" + '\0' */
+				struct stat64 s;
+				parg = getarg(&p1);
+				p = Realloc(NULL, TSZ+1);	/* for '\0' */
+				/* zero the buffer before using it */
+				p[0] = '\0';
+				size = TSZ;
+				if (isdigit(*parg)) {
+					(void) strcpy(p, "tty");
+					size -= 3;
+				}
+				(void) strncat(p, parg, size);
+				if (ntty == ttysz) {
+					if ((ttysz *= 2) == 0)
+						ttysz = NTTYS;
+					tty = Realloc(tty,
+					    (ttysz + 1) * sizeof (struct tty));
+				}
+				tty[ntty].tdev = PRNODEV;
+				(void) strcpy(nambuf, "/dev/");
+				(void) strcat(nambuf, p);
+				if (stat64(nambuf, &s) == 0)
+					tty[ntty].tdev = s.st_rdev;
+				tty[ntty++].tname = p;
+			} while (*p1);
+			break;
+		case 'p':		/* proc ids */
+			pflg++;
+			p1 = optarg;
+			do {
+				pid_t id;
+
+				parg = getarg(&p1);
+				if ((ret = str2id(parg, &id, 0, maxpid)) != 0) {
+					pgerrflg++;
+					(void) fprintf(stderr,
+					    gettext("ps: %s "), parg);
+					if (ret == EINVAL)
+						(void) fprintf(stderr,
+						    gettext("is an invalid "
+						    "non-numeric argument"));
+					else
+						(void) fprintf(stderr,
+						    gettext("exceeds valid "
+						    "range"));
+					(void) fprintf(stderr,
+					    gettext(" for -p option\n"));
+					continue;
+				}
+
+				if (npid == pidsz) {
+					if ((pidsz *= 2) == 0)
+						pidsz = SIZ;
+					pid = Realloc(pid,
+					    pidsz * sizeof (pid_t));
+				}
+				pid[npid++] = id;
+			} while (*p1);
+			break;
+		case 'z':		/* zone name or number */
+			zflg++;
+			p1 = optarg;
+			do {
+				zoneid_t id;
+
+				parg = getarg(&p1);
+				if (zone_get_id(parg, &id) != 0) {
+					pgerrflg++;
+					(void) fprintf(stderr,
+					    gettext("ps: unknown zone %s\n"),
+					    parg);
+					continue;
+				}
+
+				if (nzoneid == zoneidsz) {
+					if ((zoneidsz *= 2) == 0)
+						zoneidsz = SIZ;
+					zoneid = Realloc(zoneid,
+					    zoneidsz * sizeof (zoneid_t));
+				}
+				zoneid[nzoneid++] = id;
+			} while (*p1);
+			break;
+		case 'Z':		/* show zone name */
+			Zflg++;
+			break;
+		default:			/* error on ? */
+			errflg++;
+			break;
+		}
+
+	if (errflg || optind < argc || pgerrflg)
+		bb_show_usage();
+
+	if (tflg)
+		tty[ntty].tname = NULL;
+	/*
+	 * If an appropriate option has not been specified, use the
+	 * current terminal and effective uid as the default.
+	 */
+	if (!(aflg|Aflg|dflg|tflg|pflg|zflg)) {
+		psinfo_t info;
+		int procfd;
+		char *name;
+		char pname[100];
+
+		/* get our own controlling tty name using /proc */
+		(void) snprintf(pname, sizeof (pname),
+		    "%s/self/psinfo", procdir);
+		if ((procfd = open(pname, O_RDONLY)) < 0 ||
+		    read(procfd, (char *)&info, sizeof (info)) < 0 ||
+		    info.pr_ttydev == PRNODEV) {
+			(void) fprintf(stderr,
+			    gettext("ps: no controlling terminal\n"));
+			exit(1);
+		}
+		(void) close(procfd);
+
+		i = 0;
+		name = gettty(&info);
+		if (*name == '?') {
+			(void) fprintf(stderr,
+			    gettext("ps: can't find controlling terminal\n"));
+			exit(1);
+		}
+		if (ntty == ttysz) {
+			if ((ttysz *= 2) == 0)
+				ttysz = NTTYS;
+			tty = Realloc(tty, (ttysz + 1) * sizeof (struct tty));
+		}
+		tty[ntty].tdev = info.pr_ttydev;
+		tty[ntty++].tname = name;
+		tty[ntty].tname = NULL;
+		tflg++;
+		tuid = getuid();
+	}
+	if (Aflg) {
+		pflg = aflg = dflg = 0;
+		zflg =  0;
+	}
+	if (Aflg | aflg | dflg)
+		tflg = 0;
+
+	i = 0;		/* prepare to exit on name lookup errors */
+	i += uconv(&euid_tbl);
+	i += uconv(&ruid_tbl);
+	i += gconv(&egid_tbl);
+	i += gconv(&rgid_tbl);
+	if (i)
+		exit(1);
+
+	/* allocate a buffer for lwpsinfo structures */
+	lpbufsize = 4096;
+	if (Lflg && (lpsinfobuf = malloc(lpbufsize)) == NULL) {
+		(void) fprintf(stderr,
+		    gettext("ps: no memory\n"));
+		exit(1);
+	}
+
+	if (fields) {	/* print user-specified header */
+		if (do_header) {
+			struct field *f;
+
+			for (f = fields; f != NULL; f = f->next) {
+				if (f != fields)
+					(void) printf(" ");
+				switch (f->fname) {
+				case F_TTY:
+					(void) printf("%-*s",
+					    f->width, f->header);
+					break;
+				case F_FNAME:
+				case F_COMM:
+				case F_ARGS:
+					/*
+					 * Print these headers full width
+					 * unless they appear at the end.
+					 */
+					if (f->next != NULL) {
+						(void) printf("%-*s",
+						    f->width, f->header);
+					} else {
+						(void) printf("%s",
+						    f->header);
+					}
+					break;
+				default:
+					(void) printf("%*s",
+					    f->width, f->header);
+					break;
+				}
+			}
+			(void) printf("\n");
+		}
+	} else {	/* print standard header */
+		/*
+		 * All fields before 'PID' are printed with a trailing space
+		 * as a separator and that is how we print the headers too.
+		 */
+		if (lflg) {
+			if (yflg)
+				(void) printf("S ");
+			else
+				(void) printf(" F S ");
+		}
+		if (Zflg)
+			(void) printf("    ZONE ");
+		if (fflg) {
+			(void) printf("     UID ");
+		} else if (lflg)
+			(void) printf("   UID ");
+
+		(void) printf("%*s", pidwidth,  "PID");
+		if (lflg || fflg)
+			(void) printf(" %*s", pidwidth, "PPID");
+		if (jflg)
+			(void) printf(" %*s %*s", pidwidth, "PGID",
+			    pidwidth, "SID");
+		if (Lflg)
+			(void) printf("   LWP");
+		if (Pflg)
+			(void) printf(" PSR");
+		if (Lflg && fflg)
+			(void) printf("  NLWP");
+		if (cflg)
+			(void) printf("  CLS PRI");
+		else if (lflg || fflg) {
+			(void) printf("   C");
+			if (lflg)
+				(void) printf(" PRI NI");
+		}
+		if (lflg) {
+			if (yflg)
+				(void) printf("   RSS     SZ    WCHAN");
+			else
+				(void) printf("     ADDR     SZ    WCHAN");
+		}
+		if (fflg)
+			(void) printf(" %s", loc_stime_str);
+		if (Hflg)
+			(void) printf(" LGRP");
+		if (Lflg)
+			(void) printf(" TTY        LTIME CMD\n");
+		else
+			(void) printf(" TTY         TIME CMD\n");
+	}
+
+
+	if (pflg && !(aflg|Aflg|dflg|tflg|zflg) &&
+	    npid <= PTHRESHOLD) {
+		/*
+		 * If we are looking at specific processes go straight
+		 * to their /proc entries and don't scan /proc.
+		 */
+		int i;
+
+		(void) qsort(pid, npid, sizeof (pid_t), pidcmp);
+		for (i = 0; i < npid; i++) {
+			char pname[12];
+
+			if (i >= 1 && pid[i] == pid[i - 1])
+				continue;
+			(void) sprintf(pname, "%d", (int)pid[i]);
+			if (print_proc(pname) == 0)
+				retcode = 0;
+		}
+	} else {
+		/*
+		 * Determine which processes to print info about by searching
+		 * the /proc directory and looking at each process.
+		 */
+		if ((dirp = opendir(procdir)) == NULL) {
+			(void) fprintf(stderr,
+			    gettext("ps: cannot open PROC directory %s\n"),
+			    procdir);
+			exit(1);
+		}
+
+		/* for each active process --- */
+		while (dentp = readdir(dirp)) {
+			if (dentp->d_name[0] == '.')    /* skip . and .. */
+				continue;
+			if (print_proc(dentp->d_name) == 0)
+				retcode = 0;
+		}
+
+		(void) closedir(dirp);
+	}
+	return (retcode);
+}
+
+
+int
+print_proc(char *pid_name)
+{
+	char	pname[PATH_MAX];
+	int	pdlen;
+	int	found;
+	int	procfd; /* filedescriptor for /proc/nnnnn/psinfo */
+	char	*tp;    /* ptr to ttyname,  if any */
+	psinfo_t info;  /* process information from /proc */
+	lwpsinfo_t *lwpsinfo;   /* array of lwpsinfo structs */
+
+	pdlen = snprintf(pname, sizeof (pname), "%s/%s/", procdir, pid_name);
+	if (pdlen >= sizeof (pname) - 10)
+		return (1);
+retry:
+	(void) strcpy(&pname[pdlen], "psinfo");
+	if ((procfd = open(pname, O_RDONLY)) == -1) {
+		/* Process may have exited meanwhile. */
+		return (1);
+	}
+	/*
+	 * Get the info structure for the process and close quickly.
+	 */
+	if (read(procfd, (char *)&info, sizeof (info)) < 0) {
+		int	saverr = errno;
+
+		(void) close(procfd);
+		if (saverr == EAGAIN)
+			goto retry;
+		if (saverr != ENOENT)
+			(void) fprintf(stderr,
+			    gettext("ps: read() on %s: %s\n"),
+			    pname, err_string(saverr));
+		return (1);
+	}
+	(void) close(procfd);
+
+	found = 0;
+	if (info.pr_lwp.pr_state == 0)	/* can't happen? */
+		return (1);
+
+	/*
+	 * Omit session group leaders for 'a' and 'd' options.
+	 */
+	if ((info.pr_pid == info.pr_sid) && (dflg || aflg))
+		return (1);
+	if (Aflg || dflg)
+		found++;
+	else if (pflg && search(pid, npid, info.pr_pid))
+		found++;	/* ppid in p option arg list */
+	else if (zflg && search(zoneid, nzoneid, info.pr_zoneid))
+		found++;	/* zoneid in z option arg list */
+	if (!found && !tflg && !aflg)
+		return (1);
+	if (!prfind(found, &info, &tp))
+		return (1);
+	if (Lflg && (info.pr_nlwp + info.pr_nzomb) > 1) {
+		ssize_t prsz;
+
+		(void) strcpy(&pname[pdlen], "lpsinfo");
+		if ((procfd = open(pname, O_RDONLY)) == -1)
+			return (1);
+		/*
+		 * Get the info structures for the lwps.
+		 */
+		prsz = read(procfd, lpsinfobuf, lpbufsize);
+		if (prsz == -1) {
+			int	saverr = errno;
+
+			(void) close(procfd);
+			if (saverr == EAGAIN)
+				goto retry;
+			if (saverr != ENOENT)
+				(void) fprintf(stderr,
+				    gettext("ps: read() on %s: %s\n"),
+				    pname, err_string(saverr));
+			return (1);
+		}
+		(void) close(procfd);
+		if (prsz == lpbufsize) {
+			/*
+			 * buffer overflow. Realloc new buffer.
+			 * Error handling is done in Realloc().
+			 */
+			lpbufsize *= 2;
+			lpsinfobuf = Realloc(lpsinfobuf, lpbufsize);
+			goto retry;
+		}
+		if (lpsinfobuf->pr_nent != (info.pr_nlwp + info.pr_nzomb))
+			goto retry;
+		lwpsinfo = (lwpsinfo_t *)(lpsinfobuf + 1);
+	}
+	if (!Lflg || (info.pr_nlwp + info.pr_nzomb) <= 1) {
+		prcom(&info, tp);
+	} else {
+		int nlwp = 0;
+
+		do {
+			info.pr_lwp = *lwpsinfo;
+			prcom(&info, tp);
+			/* LINTED improper alignment */
+			lwpsinfo = (lwpsinfo_t *)((char *)lwpsinfo +
+			    lpsinfobuf->pr_entsize);
+		} while (++nlwp < lpsinfobuf->pr_nent);
+	}
+	return (0);
+}
+
+/*
+ * getarg() finds the next argument in list and copies arg into argbuf.
+ * p1 first pts to arg passed back from getopt routine.  p1 is then
+ * bumped to next character that is not a comma or blank -- p1 NULL
+ * indicates end of list.
+ */
+static char *
+getarg(char **pp1)
+{
+	static char argbuf[ARGSIZ];
+	char *p1 = *pp1;
+	char *parga = argbuf;
+	int c;
+
+	while ((c = *p1) != '\0' && (c == ',' || isspace(c)))
+		p1++;
+
+	while ((c = *p1) != '\0' && c != ',' && !isspace(c)) {
+		if (parga < argbuf + ARGSIZ - 1)
+			*parga++ = c;
+		p1++;
+	}
+	*parga = '\0';
+
+	while ((c = *p1) != '\0' && (c == ',' || isspace(c)))
+		p1++;
+
+	*pp1 = p1;
+
+	return (argbuf);
+}
+
+static char *
+devlookup(dev_t ddev)
+{
+	struct devl *dp;
+	int i;
+
+	for (dp = devl, i = 0; i < ndev; dp++, i++) {
+		if (dp->ddev == ddev)
+			return (dp->dname);
+	}
+	return (NULL);
+}
+
+static char *
+devadd(char *name, dev_t ddev)
+{
+	struct devl *dp;
+	int leng, start, i;
+
+	if (ndev == maxdev) {
+		maxdev += DNINCR;
+		devl = Realloc(devl, maxdev * sizeof (struct devl));
+	}
+	dp = &devl[ndev++];
+
+	dp->ddev = ddev;
+	if (name == NULL) {
+		(void) strcpy(dp->dname, "??");
+		return (dp->dname);
+	}
+
+	leng = strlen(name);
+	/* Strip off /dev/ */
+	if (leng < DNSIZE + 4)
+		(void) strcpy(dp->dname, &name[5]);
+	else {
+		start = leng - DNSIZE - 1;
+
+		for (i = start; i < leng && name[i] != '/'; i++)
+				;
+		if (i == leng)
+			(void) strncpy(dp->dname, &name[start], DNSIZE);
+		else
+			(void) strncpy(dp->dname, &name[i+1], DNSIZE);
 	}
+	return (dp->dname);
+}
+
+/*
+ * gettty returns the user's tty number or ? if none.
+ */
+static char *
+gettty(psinfo_t *psinfo)
+{
+	extern char *_ttyname_dev(dev_t, char *, size_t);
+	char devname[TTYNAME_MAX];
+	char *retval;
+
+	if (psinfo->pr_ttydev == PRNODEV)
+		return ("?");
+
+	if ((retval = devlookup(psinfo->pr_ttydev)) != NULL)
+		return (retval);
+
+	retval = _ttyname_dev(psinfo->pr_ttydev, devname, sizeof (devname));
+
+	return (devadd(retval, psinfo->pr_ttydev));
+}
+
+/*
+ * Find the process's tty and return 1 if process is to be printed.
+ */
+static int
+prfind(int found, psinfo_t *psinfo, char **tpp)
+{
+	char	*tp;
+	struct tty *ttyp;
+
+	if (psinfo->pr_nlwp == 0) {
+		/* process is a zombie */
+		*tpp = "?";
+		if (tflg && !found)
+			return (0);
+		return (1);
+	}
+
+	/*
+	 * Get current terminal.  If none ("?") and 'a' is set, don't print
+	 * info.  If 't' is set, check if term is in list of desired terminals
+	 * and print it if it is.
+	 */
+	tp = gettty(psinfo);
+	if (aflg && *tp == '?') {
+		*tpp = tp;
+		return (0);
+	}
+	if (tflg && !found) {
+		int match = 0;
+		char *other = NULL;
+		for (ttyp = tty; ttyp->tname != NULL; ttyp++) {
+			/*
+			 * Look for a name match
+			 */
+			if (strcmp(tp, ttyp->tname) == 0) {
+				match = 1;
+				break;
+			}
+			/*
+			 * Look for same device under different names.
+			 */
+			if ((other == NULL) &&
+			    (ttyp->tdev != PRNODEV) &&
+			    (psinfo->pr_ttydev == ttyp->tdev))
+				other = ttyp->tname;
+		}
+		if (!match && (other != NULL)) {
+			/*
+			 * found under a different name
+			 */
+			match = 1;
+			tp = other;
+		}
+		if (!match || (tuid != (uid_t)-1 && tuid != psinfo->pr_euid)) {
+			/*
+			 * not found OR not matching euid
+			 */
+			*tpp = tp;
+			return (0);
+		}
+	}
+	*tpp = tp;
+	return (1);
+}
+
+/*
+ * Print info about the process.
+ */
+static void
+prcom(psinfo_t *psinfo, char *ttyp)
+{
+	char	*cp;
+	long	tm;
+	int	bytesleft;
+	int	wcnt, length;
+	wchar_t	wchar;
+	struct passwd *pwd;
+	int	zombie_lwp;
+	char	zonename[ZONENAME_MAX];
+
+	/*
+	 * If process is zombie, call zombie print routine and return.
+	 */
+	if (psinfo->pr_nlwp == 0) {
+		if (fields != NULL)
+			pr_fields(psinfo, ttyp, print_zombie_field);
+		else
+			przom(psinfo);
+		return;
+	}
+
+	zombie_lwp = (Lflg && psinfo->pr_lwp.pr_sname == 'Z');
+
+	/*
+	 * If user specified '-o format', print requested fields and return.
+	 */
+	if (fields != NULL) {
+		pr_fields(psinfo, ttyp, print_field);
+		return;
+	}
+
+	/*
+	 * All fields before 'PID' are printed with a trailing space as a
+	 * separator, rather than keeping track of which column is first.  All
+	 * other fields are printed with a leading space.
+	 */
+	if (lflg) {
+		if (!yflg)
+			(void) printf("%2x ", psinfo->pr_flag & 0377); /* F */
+		(void) printf("%c ", psinfo->pr_lwp.pr_sname);	/* S */
+	}
+
+	if (Zflg) {						/* ZONE */
+		if (getzonenamebyid(psinfo->pr_zoneid, zonename,
+		    sizeof (zonename)) < 0) {
+			(void) printf(" %7.7d ", ((int)psinfo->pr_zoneid));
+		} else {
+			(void) printf("%8.8s ", zonename);
+		}
+	}
+
+	if (fflg) {						/* UID */
+		if ((pwd = getpwuid(psinfo->pr_euid)) != NULL)
+			(void) printf("%8.8s ", pwd->pw_name);
+		else
+			(void) printf(" %7.7u ", psinfo->pr_euid);
+	} else if (lflg) {
+		(void) printf("%6u ", psinfo->pr_euid);
+	}
+	(void) printf("%*d", pidwidth, (int)psinfo->pr_pid); /* PID */
+	if (lflg || fflg)
+		(void) printf(" %*d", pidwidth,
+		    (int)psinfo->pr_ppid); /* PPID */
+	if (jflg) {
+		(void) printf(" %*d", pidwidth,
+		    (int)psinfo->pr_pgid);	/* PGID */
+		(void) printf(" %*d", pidwidth,
+		    (int)psinfo->pr_sid);	/* SID  */
+	}
+	if (Lflg)
+		(void) printf(" %5d", (int)psinfo->pr_lwp.pr_lwpid); /* LWP */
+	if (Pflg) {
+		if (psinfo->pr_lwp.pr_bindpro == PBIND_NONE)	/* PSR */
+			(void) printf("   -");
+		else
+			(void) printf(" %3d", psinfo->pr_lwp.pr_bindpro);
+	}
+	if (Lflg && fflg)					/* NLWP */
+		(void) printf(" %5d", psinfo->pr_nlwp + psinfo->pr_nzomb);
+	if (cflg) {
+		if (zombie_lwp)					/* CLS */
+			(void) printf("     ");
+		else
+			(void) printf(" %4s", psinfo->pr_lwp.pr_clname);
+		(void) printf(" %3d", psinfo->pr_lwp.pr_pri);	/* PRI */
+	} else if (lflg || fflg) {
+		(void) printf(" %3d", psinfo->pr_lwp.pr_cpu & 0377); /* C   */
+		if (lflg) {					    /* PRI NI */
+			/*
+			 * Print priorities the old way (lower numbers
+			 * mean higher priority) and print nice value
+			 * for time sharing procs.
+			 */
+			(void) printf(" %3d", psinfo->pr_lwp.pr_oldpri);
+			if (psinfo->pr_lwp.pr_oldpri != 0)
+				(void) printf(" %2d", psinfo->pr_lwp.pr_nice);
+			else
+				(void) printf(" %2.2s",
+				    psinfo->pr_lwp.pr_clname);
+		}
+	}
+	if (lflg) {
+		if (yflg) {
+			if (psinfo->pr_flag & SSYS)		/* RSS */
+				(void) printf("     0");
+			else if (psinfo->pr_rssize)
+				(void) printf(" %5lu",
+				    (ulong_t)psinfo->pr_rssize);
+			else
+				(void) printf("     ?");
+			if (psinfo->pr_flag & SSYS)		/* SZ */
+				(void) printf("      0");
+			else if (psinfo->pr_size)
+				(void) printf(" %6lu",
+				    (ulong_t)psinfo->pr_size);
+			else
+				(void) printf("      ?");
+		} else {
+#ifndef _LP64
+			if (psinfo->pr_addr)			/* ADDR */
+				(void) printf(" %8lx",
+				    (ulong_t)psinfo->pr_addr);
+			else
 #endif
-#if ENABLE_SELINUX
-	if ((i & (1+ENABLE_FEATURE_PS_WIDE)) && is_selinux_enabled())
-		use_selinux = 1;
+				(void) printf("        ?");
+			if (psinfo->pr_flag & SSYS)		/* SZ */
+				(void) printf("      0");
+			else if (psinfo->pr_size)
+				(void) printf(" %6lu",
+				    (ulong_t)psinfo->pr_size / kbytes_per_page);
+			else
+				(void) printf("      ?");
+		}
+		if (psinfo->pr_lwp.pr_sname != 'S')		/* WCHAN */
+			(void) printf("         ");
+#ifndef _LP64
+		else if (psinfo->pr_lwp.pr_wchan)
+			(void) printf(" %8lx",
+			    (ulong_t)psinfo->pr_lwp.pr_wchan);
 #endif
-#endif  /* ENABLE_FEATURE_PS_WIDE || ENABLE_SELINUX */
+		else
+			(void) printf("        ?");
+	}
+	if (fflg) {						/* STIME */
+		int width = fname[F_STIME].width;
+		if (Lflg)
+			prtime(psinfo->pr_lwp.pr_start, width + 1, 1);
+		else
+			prtime(psinfo->pr_start, width + 1, 1);
+	}
 
-#if ENABLE_SELINUX
-	if (use_selinux)
-	  printf("  PID Context                          Stat Command\n");
-	else
-#endif
-	  printf("  PID  Uid     VmSize Stat Command\n");
+	if (Hflg) {
+		/* Display home lgroup */
+		(void) printf(" %4d", (int)psinfo->pr_lwp.pr_lgrp);
+	}
+
+	(void) printf(" %-8.14s", ttyp);			/* TTY */
+	if (Lflg) {
+		tm = psinfo->pr_lwp.pr_time.tv_sec;
+		if (psinfo->pr_lwp.pr_time.tv_nsec > 500000000)
+			tm++;
+	} else {
+		tm = psinfo->pr_time.tv_sec;
+		if (psinfo->pr_time.tv_nsec > 500000000)
+			tm++;
+	}
+	(void) printf(" %4ld:%.2ld", tm / 60, tm % 60);		/* [L]TIME */
+
+	if (zombie_lwp) {
+		(void) printf(" <defunct>\n");
+		return;
+	}
+
+	if (!fflg) {						/* CMD */
+		wcnt = namencnt(psinfo->pr_fname, 16, 8);
+		(void) printf(" %.*s\n", wcnt, psinfo->pr_fname);
+		return;
+	}
 
-	while ((p = procps_scan(1)) != 0)  {
-		char *namecmd = p->cmd;
-#if ENABLE_SELINUX
-		if (use_selinux)
-		  {
-			char sbuf[128];
-			len = sizeof(sbuf);
-
-			if (is_selinux_enabled()) {
-			  if (getpidcon(p->pid,&sid)<0)
-			    sid=NULL;
+
+	/*
+	 * PRARGSZ == length of cmd arg string.
+	 */
+	psinfo->pr_psargs[PRARGSZ-1] = '\0';
+	bytesleft = PRARGSZ;
+	for (cp = psinfo->pr_psargs; *cp != '\0'; cp += length) {
+		length = mbtowc(&wchar, cp, MB_LEN_MAX);
+		if (length == 0)
+			break;
+		if (length < 0 || !iswprint(wchar)) {
+			if (length < 0)
+				length = 1;
+			if (bytesleft <= length) {
+				*cp = '\0';
+				break;
+			}
+			/* omit the unprintable character */
+			(void) memmove(cp, cp+length, bytesleft-length);
+			length = 0;
+		}
+		bytesleft -= length;
+	}
+	wcnt = namencnt(psinfo->pr_psargs, PRARGSZ, lflg ? 35 : PRARGSZ);
+	(void) printf(" %.*s\n", wcnt, psinfo->pr_psargs);
+}
+
+/*
+ * Print percent from 16-bit binary fraction [0 .. 1]
+ * Round up .01 to .1 to indicate some small percentage (the 0x7000 below).
+ */
+static void
+prtpct(ushort_t pct, int width)
+{
+	uint_t value = pct;	/* need 32 bits to compute with */
+
+	value = ((value * 1000) + 0x7000) >> 15;	/* [0 .. 1000] */
+	if (value >= 1000)
+		value = 999;
+	if ((width -= 2) < 2)
+		width = 2;
+	(void) printf("%*u.%u", width, value / 10, value % 10);
+}
+
+static void
+print_time(time_t tim, int width)
+{
+	char buf[30];
+	time_t seconds;
+	time_t minutes;
+	time_t hours;
+	time_t days;
+
+	if (tim < 0) {
+		(void) printf("%*s", width, "-");
+		return;
+	}
+
+	seconds = tim % 60;
+	tim /= 60;
+	minutes = tim % 60;
+	tim /= 60;
+	hours = tim % 24;
+	days = tim / 24;
+
+	if (days > 0) {
+		(void) snprintf(buf, sizeof (buf), "%ld-%2.2ld:%2.2ld:%2.2ld",
+		    days, hours, minutes, seconds);
+	} else if (hours > 0) {
+		(void) snprintf(buf, sizeof (buf), "%2.2ld:%2.2ld:%2.2ld",
+		    hours, minutes, seconds);
+	} else {
+		(void) snprintf(buf, sizeof (buf), "%2.2ld:%2.2ld",
+		    minutes, seconds);
+	}
+
+	(void) printf("%*s", width, buf);
+}
+
+static void
+print_field(psinfo_t *psinfo, struct field *f, const char *ttyp)
+{
+	int width = f->width;
+	struct passwd *pwd;
+	struct group *grp;
+	time_t cputime;
+	int bytesleft;
+	int wcnt;
+	wchar_t	wchar;
+	char *cp;
+	int length;
+	ulong_t mask;
+	char c, *csave;
+	int zombie_lwp;
+
+	zombie_lwp = (Lflg && psinfo->pr_lwp.pr_sname == 'Z');
+
+	switch (f->fname) {
+	case F_RUSER:
+		if ((pwd = getpwuid(psinfo->pr_uid)) != NULL)
+			(void) printf("%*s", width, pwd->pw_name);
+		else
+			(void) printf("%*u", width, psinfo->pr_uid);
+		break;
+	case F_USER:
+		if ((pwd = getpwuid(psinfo->pr_euid)) != NULL)
+			(void) printf("%*s", width, pwd->pw_name);
+		else
+			(void) printf("%*u", width, psinfo->pr_euid);
+		break;
+	case F_RGROUP:
+		if ((grp = getgrgid(psinfo->pr_gid)) != NULL)
+			(void) printf("%*s", width, grp->gr_name);
+		else
+			(void) printf("%*u", width, psinfo->pr_gid);
+		break;
+	case F_GROUP:
+		if ((grp = getgrgid(psinfo->pr_egid)) != NULL)
+			(void) printf("%*s", width, grp->gr_name);
+		else
+			(void) printf("%*u", width, psinfo->pr_egid);
+		break;
+	case F_RUID:
+		(void) printf("%*u", width, psinfo->pr_uid);
+		break;
+	case F_UID:
+		(void) printf("%*u", width, psinfo->pr_euid);
+		break;
+	case F_RGID:
+		(void) printf("%*u", width, psinfo->pr_gid);
+		break;
+	case F_GID:
+		(void) printf("%*u", width, psinfo->pr_egid);
+		break;
+	case F_PID:
+		(void) printf("%*d", width, (int)psinfo->pr_pid);
+		break;
+	case F_PPID:
+		(void) printf("%*d", width, (int)psinfo->pr_ppid);
+		break;
+	case F_PGID:
+		(void) printf("%*d", width, (int)psinfo->pr_pgid);
+		break;
+	case F_SID:
+		(void) printf("%*d", width, (int)psinfo->pr_sid);
+		break;
+	case F_PSR:
+		if (zombie_lwp || psinfo->pr_lwp.pr_bindpro == PBIND_NONE)
+			(void) printf("%*s", width, "-");
+		else
+			(void) printf("%*d", width, psinfo->pr_lwp.pr_bindpro);
+		break;
+	case F_LWP:
+		(void) printf("%*d", width, (int)psinfo->pr_lwp.pr_lwpid);
+		break;
+	case F_NLWP:
+		(void) printf("%*d", width, psinfo->pr_nlwp + psinfo->pr_nzomb);
+		break;
+	case F_OPRI:
+		if (zombie_lwp)
+			(void) printf("%*s", width, "-");
+		else
+			(void) printf("%*d", width, psinfo->pr_lwp.pr_oldpri);
+		break;
+	case F_PRI:
+		if (zombie_lwp)
+			(void) printf("%*s", width, "-");
+		else
+			(void) printf("%*d", width, psinfo->pr_lwp.pr_pri);
+		break;
+	case F_F:
+		mask = 0xffffffffUL;
+		if (width < 8)
+			mask >>= (8 - width) * 4;
+		(void) printf("%*lx", width, psinfo->pr_flag & mask);
+		break;
+	case F_S:
+		(void) printf("%*c", width, psinfo->pr_lwp.pr_sname);
+		break;
+	case F_C:
+		if (zombie_lwp)
+			(void) printf("%*s", width, "-");
+		else
+			(void) printf("%*d", width, psinfo->pr_lwp.pr_cpu);
+		break;
+	case F_PCPU:
+		if (zombie_lwp)
+			(void) printf("%*s", width, "-");
+		else if (Lflg)
+			prtpct(psinfo->pr_lwp.pr_pctcpu, width);
+		else
+			prtpct(psinfo->pr_pctcpu, width);
+		break;
+	case F_PMEM:
+		prtpct(psinfo->pr_pctmem, width);
+		break;
+	case F_OSZ:
+		(void) printf("%*lu", width,
+		    (ulong_t)psinfo->pr_size / kbytes_per_page);
+		break;
+	case F_VSZ:
+		(void) printf("%*lu", width, (ulong_t)psinfo->pr_size);
+		break;
+	case F_RSS:
+		(void) printf("%*lu", width, (ulong_t)psinfo->pr_rssize);
+		break;
+	case F_NICE:
+		/* if pr_oldpri is zero, then this class has no nice */
+		if (zombie_lwp)
+			(void) printf("%*s", width, "-");
+		else if (psinfo->pr_lwp.pr_oldpri != 0)
+			(void) printf("%*d", width, psinfo->pr_lwp.pr_nice);
+		else
+			(void) printf("%*.*s", width, width,
+			    psinfo->pr_lwp.pr_clname);
+		break;
+	case F_CLASS:
+		if (zombie_lwp)
+			(void) printf("%*s", width, "-");
+		else
+			(void) printf("%*.*s", width, width,
+			    psinfo->pr_lwp.pr_clname);
+		break;
+	case F_STIME:
+		if (Lflg)
+			prtime(psinfo->pr_lwp.pr_start, width, 0);
+		else
+			prtime(psinfo->pr_start, width, 0);
+		break;
+	case F_ETIME:
+		if (Lflg)
+			print_time(delta_secs(&psinfo->pr_lwp.pr_start),
+			    width);
+		else
+			print_time(delta_secs(&psinfo->pr_start), width);
+		break;
+	case F_TIME:
+		if (Lflg) {
+			cputime = psinfo->pr_lwp.pr_time.tv_sec;
+			if (psinfo->pr_lwp.pr_time.tv_nsec > 500000000)
+				cputime++;
+		} else {
+			cputime = psinfo->pr_time.tv_sec;
+			if (psinfo->pr_time.tv_nsec > 500000000)
+				cputime++;
+		}
+		print_time(cputime, width);
+		break;
+	case F_TTY:
+		(void) printf("%-*s", width, ttyp);
+		break;
+	case F_ADDR:
+		if (zombie_lwp)
+			(void) printf("%*s", width, "-");
+		else if (Lflg)
+			(void) printf("%*lx", width,
+			    (long)psinfo->pr_lwp.pr_addr);
+		else
+			(void) printf("%*lx", width, (long)psinfo->pr_addr);
+		break;
+	case F_WCHAN:
+		if (!zombie_lwp && psinfo->pr_lwp.pr_wchan)
+			(void) printf("%*lx", width,
+			    (long)psinfo->pr_lwp.pr_wchan);
+		else
+			(void) printf("%*.*s", width, width, "-");
+		break;
+	case F_FNAME:
+		/*
+		 * Print full width unless this is the last output format.
+		 */
+		if (zombie_lwp) {
+			if (f->next != NULL)
+				(void) printf("%-*s", width, "<defunct>");
+			else
+				(void) printf("%s", "<defunct>");
+			break;
+		}
+		wcnt = namencnt(psinfo->pr_fname, 16, width);
+		if (f->next != NULL)
+			(void) printf("%-*.*s", width, wcnt, psinfo->pr_fname);
+		else
+			(void) printf("%-.*s", wcnt, psinfo->pr_fname);
+		break;
+	case F_COMM:
+		if (zombie_lwp) {
+			if (f->next != NULL)
+				(void) printf("%-*s", width, "<defunct>");
+			else
+				(void) printf("%s", "<defunct>");
+			break;
+		}
+		csave = strpbrk(psinfo->pr_psargs, " \t\r\v\f\n");
+		if (csave) {
+			c = *csave;
+			*csave = '\0';
+		}
+		/* FALLTHROUGH */
+	case F_ARGS:
+		/*
+		 * PRARGSZ == length of cmd arg string.
+		 */
+		if (zombie_lwp) {
+			(void) printf("%-*s", width, "<defunct>");
+			break;
+		}
+		psinfo->pr_psargs[PRARGSZ-1] = '\0';
+		bytesleft = PRARGSZ;
+		for (cp = psinfo->pr_psargs; *cp != '\0'; cp += length) {
+			length = mbtowc(&wchar, cp, MB_LEN_MAX);
+			if (length == 0)
+				break;
+			if (length < 0 || !iswprint(wchar)) {
+				if (length < 0)
+					length = 1;
+				if (bytesleft <= length) {
+					*cp = '\0';
+					break;
+				}
+				/* omit the unprintable character */
+				(void) memmove(cp, cp+length, bytesleft-length);
+				length = 0;
 			}
+			bytesleft -= length;
+		}
+		wcnt = namencnt(psinfo->pr_psargs, PRARGSZ, width);
+		/*
+		 * Print full width unless this is the last format.
+		 */
+		if (f->next != NULL)
+			(void) printf("%-*.*s", width, wcnt,
+			    psinfo->pr_psargs);
+		else
+			(void) printf("%-.*s", wcnt,
+			    psinfo->pr_psargs);
+		if (f->fname == F_COMM && csave)
+			*csave = c;
+		break;
+	case F_TASKID:
+		(void) printf("%*d", width, (int)psinfo->pr_taskid);
+		break;
+	case F_PROJID:
+		(void) printf("%*d", width, (int)psinfo->pr_projid);
+		break;
+	case F_PROJECT:
+		{
+			struct project cproj;
+			char proj_buf[PROJECT_BUFSZ];
 
-			if (sid) {
-			  /*  I assume sid initilized with NULL  */
-			  len = strlen(sid)+1;
-			  safe_strncpy(sbuf, sid, len);
-			  freecon(sid);
-			  sid=NULL;
-			}else {
-			  safe_strncpy(sbuf, "unknown",7);
+			if ((getprojbyid(psinfo->pr_projid, &cproj,
+			    (void *)&proj_buf, PROJECT_BUFSZ)) == NULL)
+				(void) printf("%*d", width,
+				    (int)psinfo->pr_projid);
+			else
+				(void) printf("%*s", width,
+				    (cproj.pj_name != NULL) ?
+				    cproj.pj_name : "---");
+		}
+		break;
+	case F_PSET:
+		if (zombie_lwp || psinfo->pr_lwp.pr_bindpset == PS_NONE)
+			(void) printf("%*s", width, "-");
+		else
+			(void) printf("%*d", width, psinfo->pr_lwp.pr_bindpset);
+		break;
+	case F_ZONEID:
+		(void) printf("%*d", width, (int)psinfo->pr_zoneid);
+		break;
+	case F_ZONE:
+		{
+			char zonename[ZONENAME_MAX];
+
+			if (getzonenamebyid(psinfo->pr_zoneid, zonename,
+			    sizeof (zonename)) < 0) {
+				(void) printf("%*d", width,
+				    ((int)psinfo->pr_zoneid));
+			} else {
+				(void) printf("%*s", width, zonename);
 			}
-			len = printf("%5d %-32s %s ", p->pid, sbuf, p->state);
 		}
+		break;
+	case F_CTID:
+		if (psinfo->pr_contract == -1)
+			(void) printf("%*s", width, "-");
 		else
-#endif
-		  if(p->rss == 0)
-		    len = printf("%5d %-8s        %s ", p->pid, p->user, p->state);
-		  else
-		    len = printf("%5d %-8s %6ld %s ", p->pid, p->user, p->rss, p->state);
-
-		i = terminal_width-len;
-
-		if(namecmd && namecmd[0]) {
-			if(i < 0)
-				i = 0;
-			if(strlen(namecmd) > (size_t)i)
-				namecmd[i] = 0;
-			printf("%s\n", namecmd);
+			(void) printf("%*ld", width, (long)psinfo->pr_contract);
+		break;
+	case F_LGRP:
+		/* Display home lgroup */
+		(void) printf("%*d", width, (int)psinfo->pr_lwp.pr_lgrp);
+		break;
+	}
+}
+
+static void
+print_zombie_field(psinfo_t *psinfo, struct field *f, const char *ttyp)
+{
+	int wcnt;
+	int width = f->width;
+
+	switch (f->fname) {
+	case F_FNAME:
+	case F_COMM:
+	case F_ARGS:
+		/*
+		 * Print full width unless this is the last output format.
+		 */
+		wcnt = min(width, sizeof ("<defunct>"));
+		if (f->next != NULL)
+			(void) printf("%-*.*s", width, wcnt, "<defunct>");
+		else
+			(void) printf("%-.*s", wcnt, "<defunct>");
+		break;
+
+	case F_PSR:
+	case F_PCPU:
+	case F_PMEM:
+	case F_NICE:
+	case F_CLASS:
+	case F_STIME:
+	case F_ETIME:
+	case F_WCHAN:
+	case F_PSET:
+		(void) printf("%*s", width, "-");
+		break;
+
+	case F_OPRI:
+	case F_PRI:
+	case F_OSZ:
+	case F_VSZ:
+	case F_RSS:
+		(void) printf("%*d", width, 0);
+		break;
+
+	default:
+		print_field(psinfo, f, ttyp);
+		break;
+	}
+}
+
+static void
+pr_fields(psinfo_t *psinfo, const char *ttyp,
+	void (*print_fld)(psinfo_t *, struct field *, const char *))
+{
+	struct field *f;
+
+	for (f = fields; f != NULL; f = f->next) {
+		print_fld(psinfo, f, ttyp);
+		if (f->next != NULL)
+			(void) printf(" ");
+	}
+	(void) printf("\n");
+}
+
+/*
+ * Returns 1 if arg is found in array arr, of length num; 0 otherwise.
+ */
+static int
+search(pid_t *arr, int number, pid_t arg)
+{
+	int i;
+
+	for (i = 0; i < number; i++)
+		if (arg == arr[i])
+			return (1);
+	return (0);
+}
+
+static int
+uconv(struct ughead *uhead)
+{
+	struct ugdata *utbl = uhead->ent;
+	int n = uhead->nent;
+	struct passwd *pwd;
+	int i;
+	int fnd = 0;
+	uid_t uid;
+
+	/*
+	 * Ask the name service for names.
+	 */
+	for (i = 0; i < n; i++) {
+		/*
+		 * If name is numeric, ask for numeric id
+		 */
+		if (str2uid(utbl[i].name, &uid, 0, MAXEPHUID) == 0)
+			pwd = getpwuid(uid);
+		else
+			pwd = getpwnam(utbl[i].name);
+
+		/*
+		 * If found, enter found index into tbl array.
+		 */
+		if (pwd == NULL) {
+			(void) fprintf(stderr,
+			    gettext("ps: unknown user %s\n"), utbl[i].name);
+			continue;
+		}
+
+		utbl[fnd].id = pwd->pw_uid;
+		(void) strncpy(utbl[fnd].name, pwd->pw_name, MAXUGNAME);
+		fnd++;
+	}
+
+	uhead->nent = fnd;	/* in case it changed */
+	return (n - fnd);
+}
+
+static int
+gconv(struct ughead *ghead)
+{
+	struct ugdata *gtbl = ghead->ent;
+	int n = ghead->nent;
+	struct group *grp;
+	gid_t gid;
+	int i;
+	int fnd = 0;
+
+	/*
+	 * Ask the name service for names.
+	 */
+	for (i = 0; i < n; i++) {
+		/*
+		 * If name is numeric, ask for numeric id
+		 */
+		if (str2uid(gtbl[i].name, (uid_t *)&gid, 0, MAXEPHUID) == 0)
+			grp = getgrgid(gid);
+		else
+			grp = getgrnam(gtbl[i].name);
+		/*
+		 * If found, enter found index into tbl array.
+		 */
+		if (grp == NULL) {
+			(void) fprintf(stderr,
+			    gettext("ps: unknown group %s\n"), gtbl[i].name);
+			continue;
+		}
+
+		gtbl[fnd].id = grp->gr_gid;
+		(void) strncpy(gtbl[fnd].name, grp->gr_name, MAXUGNAME);
+		fnd++;
+	}
+
+	ghead->nent = fnd;	/* in case it changed */
+	return (n - fnd);
+}
+
+/*
+ * Print starting time of process unless process started more than 24 hours
+ * ago, in which case the date is printed.  The date is printed in the form
+ * "MMM dd" if old format, else the blank is replaced with an '_' so
+ * it appears as a single word (for parseability).
+ */
+static void
+prtime(timestruc_t st, int width, int old)
+{
+	char sttim[26];
+	time_t starttime;
+
+	starttime = st.tv_sec;
+	if (st.tv_nsec > 500000000)
+		starttime++;
+	if ((now.tv_sec - starttime) >= 24*60*60) {
+		(void) strftime(sttim, sizeof (sttim), 
+		old? "%b %d" : "%b_%d", localtime(&starttime));
+	} else {
+		(void) strftime(sttim, sizeof (sttim),
+		    "%H:%M:%S",
+		    localtime(&starttime));
+	}
+	(void) printf("%*.*s", width, width, sttim);
+}
+
+static void
+przom(psinfo_t *psinfo)
+{
+	long	tm;
+	struct passwd *pwd;
+	char zonename[ZONENAME_MAX];
+
+	/*
+	 * All fields before 'PID' are printed with a trailing space as a
+	 * spearator, rather than keeping track of which column is first.  All
+	 * other fields are printed with a leading space.
+	 */
+	if (lflg) {	/* F S */
+		if (!yflg)
+			(void) printf("%2x ", psinfo->pr_flag & 0377); /* F */
+		(void) printf("%c ", psinfo->pr_lwp.pr_sname);	/* S */
+	}
+	if (Zflg) {
+		if (getzonenamebyid(psinfo->pr_zoneid, zonename,
+		    sizeof (zonename)) < 0) {
+			(void) printf(" %7.7d ", ((int)psinfo->pr_zoneid));
 		} else {
-			namecmd = p->short_cmd;
-			if(i < 2)
-				i = 2;
-			if(strlen(namecmd) > ((size_t)i-2))
-				namecmd[i-2] = 0;
-			printf("[%s]\n", namecmd);
-		}
-		/* no check needed, but to make valgrind happy..  */
-		if (ENABLE_FEATURE_CLEAN_UP && p->cmd)
-			free(p->cmd);
+			(void) printf("%8.8s ", zonename);
+		}
+	}
+	if (Hflg) {
+		/* Display home lgroup */
+		(void) printf(" %6d", (int)psinfo->pr_lwp.pr_lgrp); /* LGRP */
+	}
+	if (fflg) {
+		if ((pwd = getpwuid(psinfo->pr_euid)) != NULL)
+			(void) printf("%8.8s ", pwd->pw_name);
+		else
+			(void) printf(" %7.7u ", psinfo->pr_euid);
+	} else if (lflg)
+		(void) printf("%6u ", psinfo->pr_euid);
+
+	(void) printf("%*d", pidwidth, (int)psinfo->pr_pid);	/* PID */
+	if (lflg || fflg)
+		(void) printf(" %*d", pidwidth,
+		    (int)psinfo->pr_ppid);			/* PPID */
+
+	if (jflg) {
+		(void) printf(" %*d", pidwidth,
+		    (int)psinfo->pr_pgid);			/* PGID */
+		(void) printf(" %*d", pidwidth,
+		    (int)psinfo->pr_sid);			/* SID  */
+	}
+
+	if (Lflg)
+		(void) printf(" %5d", 0);			/* LWP */
+	if (Pflg)
+		(void) printf("   -");				/* PSR */
+	if (Lflg && fflg)
+		(void) printf(" %5d", 0);			/* NLWP */
+
+	if (cflg) {
+		(void) printf(" %4s", "-");	/* zombies have no class */
+		(void) printf(" %3d", psinfo->pr_lwp.pr_pri);	/* PRI	*/
+	} else if (lflg || fflg) {
+		(void) printf(" %3d", psinfo->pr_lwp.pr_cpu & 0377); /* C   */
+		if (lflg)
+			(void) printf(" %3d %2s",
+			    psinfo->pr_lwp.pr_oldpri, "-");	/* PRI NI */
 	}
-	return EXIT_SUCCESS;
+	if (lflg) {
+		if (yflg)				/* RSS SZ WCHAN */
+			(void) printf(" %5d %6d %8s", 0, 0, "-");
+		else					/* ADDR SZ WCHAN */
+			(void) printf(" %8s %6d %8s", "-", 0, "-");
+	}
+	if (fflg) {
+		int width = fname[F_STIME].width;
+		(void) printf(" %*.*s", width, width, "-"); 	/* STIME */
+	}
+	(void) printf(" %-8.14s", "?");				/* TTY */
+
+	tm = psinfo->pr_time.tv_sec;
+	if (psinfo->pr_time.tv_nsec > 500000000)
+		tm++;
+	(void) printf(" %4ld:%.2ld", tm / 60, tm % 60);	/* TIME */
+	(void) printf(" <defunct>\n");
+}
+
+/*
+ * Function to compute the number of printable bytes in a multibyte
+ * command string ("internationalization").
+ */
+static int
+namencnt(char *cmd, int csisize, int scrsize)
+{
+	int csiwcnt = 0, scrwcnt = 0;
+	int ncsisz, nscrsz;
+	wchar_t  wchar;
+	int	 len;
+
+	while (*cmd != '\0') {
+		if ((len = csisize - csiwcnt) > (int)MB_CUR_MAX)
+			len = MB_CUR_MAX;
+		if ((ncsisz = mbtowc(&wchar, cmd, len)) < 0)
+			return (8); /* default to use for illegal chars */
+		if ((nscrsz = wcwidth(wchar)) <= 0)
+			return (8);
+		if (csiwcnt + ncsisz > csisize || scrwcnt + nscrsz > scrsize)
+			break;
+		csiwcnt += ncsisz;
+		scrwcnt += nscrsz;
+		cmd += ncsisz;
+	}
+	return (csiwcnt);
+}
+
+static char *
+err_string(int err)
+{
+	static char buf[32];
+	char *str = strerror(err);
+
+	if (str == NULL)
+		(void) snprintf(str = buf, sizeof (buf), "Errno #%d", err);
+
+	return (str);
+}
+
+/* If allocation fails, die */
+static void *
+Realloc(void *ptr, size_t size)
+{
+	ptr = realloc(ptr, size);
+	if (ptr == NULL) {
+		(void) fprintf(stderr, "ps: no memory\n");
+		exit(1);
+	}
+	return (ptr);
+}
+
+static time_t
+delta_secs(const timestruc_t *start)
+{
+	time_t seconds = now.tv_sec - start->tv_sec;
+	long nanosecs = now.tv_usec * 1000 - start->tv_nsec;
+
+	if (nanosecs >= (NANOSEC / 2))
+		seconds++;
+	else if (nanosecs < -(NANOSEC / 2))
+		seconds--;
+
+	return (seconds);
+}
+
+/*
+ * Returns the following:
+ *
+ * 	0	No error
+ * 	EINVAL	Invalid number
+ * 	ERANGE	Value exceeds (min, max) range
+ */
+static int
+str2id(const char *p, pid_t *val, long min, long max)
+{
+	char *q;
+	long number;
+	int error;
+
+	errno = 0;
+	number = strtol(p, &q, 10);
+
+	if (errno != 0 || q == p || *q != '\0') {
+		if ((error = errno) == 0) {
+			/*
+			 * strtol() can fail without setting errno, or it can
+			 * set it to EINVAL or ERANGE.  In the case errno is
+			 * still zero, return EINVAL.
+			 */
+			error = EINVAL;
+		}
+	} else if (number < min || number > max) {
+		error = ERANGE;
+	} else {
+		error = 0;
+	}
+
+	*val = number;
+
+	return (error);
+}
+
+/*
+ * Returns the following:
+ *
+ * 	0	No error
+ * 	EINVAL	Invalid number
+ * 	ERANGE	Value exceeds (min, max) range
+ */
+static int
+str2uid(const char *p, uid_t *val, unsigned long min, unsigned long max)
+{
+	char *q;
+	unsigned long number;
+	int error;
+
+	errno = 0;
+	number = strtoul(p, &q, 10);
+
+	if (errno != 0 || q == p || *q != '\0') {
+		if ((error = errno) == 0) {
+			/*
+			 * strtoul() can fail without setting errno, or it can
+			 * set it to EINVAL or ERANGE.  In the case errno is
+			 * still zero, return EINVAL.
+			 */
+			error = EINVAL;
+		}
+	} else if (number < min || number > max) {
+		error = ERANGE;
+	} else {
+		error = 0;
+	}
+
+	*val = number;
+
+	return (error);
+}
+
+static int
+pidcmp(const void *p1, const void *p2)
+{
+	pid_t i = *((pid_t *)p1);
+	pid_t j = *((pid_t *)p2);
+
+	return (i - j);
 }
Binary files busybox-1.2.0/scripts/bb_mkdep and busybox-1.2.0solaris/scripts/bb_mkdep differ
diff -rupN busybox-1.2.0/shell/ash.c busybox-1.2.0solaris/shell/ash.c
--- busybox-1.2.0/shell/ash.c	2006-07-01 02:42:05.000000000 +0400
+++ busybox-1.2.0solaris/shell/ash.c	2009-04-18 09:24:35.208393482 +0400
@@ -47,7 +47,7 @@
 #define IFS_BROKEN
 
 #define PROFILE 0
-
+#define _PATH_TTY "/dev/tty"
 #include "busybox.h"
 
 #ifdef DEBUG
diff -rupN busybox-1.2.0/util-linux/Config.in busybox-1.2.0solaris/util-linux/Config.in
--- busybox-1.2.0/util-linux/Config.in	2006-07-01 02:42:13.000000000 +0400
+++ busybox-1.2.0solaris/util-linux/Config.in	2009-04-20 11:27:03.786695930 +0400
@@ -334,7 +334,7 @@ config CONFIG_FEATURE_USE_TERMIOS
 	  will be unable to determine the current screen size, and will be
 	  unable to move the cursor.
 
-config CONFIG_MOUNT
+config CONFIG_LINUX_MOUNT
 	bool "mount"
 	default n
 	help
@@ -418,7 +418,7 @@ config CONFIG_SWITCH_ROOT
 	  and ending point for searching through the kernel's doubly linked
 	  list of active mount points.  That's why.
 
-config CONFIG_UMOUNT
+config CONFIG_LINUX_UMOUNT
 	bool "umount"
 	default n
 	help
diff -rupN busybox-1.2.0/util-linux/Makefile.in busybox-1.2.0solaris/util-linux/Makefile.in
--- busybox-1.2.0/util-linux/Makefile.in	2006-07-01 02:42:13.000000000 +0400
+++ busybox-1.2.0solaris/util-linux/Makefile.in	2009-04-20 11:27:16.438048566 +0400
@@ -28,7 +28,7 @@ UTILLINUX-$(CONFIG_MDEV)          +=mdev
 UTILLINUX-$(CONFIG_MKFS_MINIX)    +=mkfs_minix.o
 UTILLINUX-$(CONFIG_MKSWAP)        +=mkswap.o
 UTILLINUX-$(CONFIG_MORE)          +=more.o
-UTILLINUX-$(CONFIG_MOUNT)         +=mount.o
+UTILLINUX-$(CONFIG_LINUX_MOUNT)         +=mount.o
 UTILLINUX-$(CONFIG_FEATURE_MOUNT_NFS)	+=nfsmount.o
 UTILLINUX-$(CONFIG_PIVOT_ROOT)    +=pivot_root.o
 UTILLINUX-$(CONFIG_RDATE)         +=rdate.o
@@ -36,7 +36,7 @@ UTILLINUX-$(CONFIG_READPROFILE)   +=read
 UTILLINUX-$(CONFIG_SETARCH)       +=setarch.o
 UTILLINUX-$(CONFIG_SWAPONOFF)     +=swaponoff.o
 UTILLINUX-$(CONFIG_SWITCH_ROOT)   +=switch_root.o
-UTILLINUX-$(CONFIG_UMOUNT)        +=umount.o
+UTILLINUX-$(CONFIG_LINUX_UMOUNT)        +=umount.o
 
 UTILLINUX-y:=$(sort $(UTILLINUX-y))
 
