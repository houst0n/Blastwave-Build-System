diff -rupN conky-1.5.1/configure conky-1.5.1.new/configure
--- conky-1.5.1/configure	2008-04-01 04:13:26.000000000 +0000
+++ conky-1.5.1.new/configure	2009-08-05 13:44:25.021936000 +0000
@@ -20234,9 +20234,9 @@ case $uname in
     ;;
 
 # Solaris doesn't work at all right now
-#  SunOS*)
-#    WANT_KSTAT=yes
-#    ;;
+  SunOS*)
+    WANT_KSTAT=yes
+    ;;
 
   *)
     echo "Your operating system $uname isn't supported"
@@ -21043,7 +21043,7 @@ fi
 if test "${enable_mpd+set}" = set; then
   enableval=$enable_mpd; want_mpd="$enableval"
 else
-  want_mpd=yes
+  want_mpd=no
 fi
 
 
diff -rupN conky-1.5.1/data/conky.conf conky-1.5.1.new/data/conky.conf
--- conky-1.5.1/data/conky.conf	2008-01-06 01:13:47.000000000 +0000
+++ conky-1.5.1.new/data/conky.conf	2009-08-05 13:44:25.024445000 +0000
@@ -1,74 +1,110 @@
-# Conky, a system monitor, based on torsmo
-#
-# Any original torsmo code is licensed under the BSD license
-#
-# All code written since the fork of torsmo is licensed under the GPL
-#
-# Please see COPYING for details
-#
-# Copyright (c) 2004, Hannu Saransaari and Lauri Hakkarainen
-# Copyright (c) 2005-2007 Brenden Matthews, Philip Kovacs, et. al. (see AUTHORS)
-# All rights reserved.
-#
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <http://www.gnu.org/licenses/>.
-#
-# $Id: conky.conf 990 2007-11-22 19:38:17Z pkovacs $
-
-alignment bottom_left
+# set to yes if you want Conky to be forked in the background
 background no
-border_width 1
+
 cpu_avg_samples 2
-default_color white
-default_outline_color white
-default_shade_color white
-draw_borders no
-draw_graph_borders yes
-draw_outline no
-draw_shades no
-font 6x10
-gap_x 5
-gap_y 60
-minimum_size 5 5
 net_avg_samples 2
-no_buffers yes
+
 out_to_console no
+
+# Use Xft?
+use_xft yes
+
+# Xft font when Xft is enabled
+xftfont  Monospace:size=9
+
+# Create own window instead of drawing to desktop.
 own_window yes
-own_window_class Conky
+own_window_transparent yes
+own_window_colour navyblue
+own_window_hints undecorated,below,sticky,skip_taskbar,skip_pager
 own_window_type normal
-stippled_borders 0
-update_interval 3.0
+
+# Text alpha when using Xft
+xftalpha 0.8
+
+# mail spool
+#mail_spool $MAIL
+
+# Update interval in seconds
+update_interval 1
+
+# Use double buffering (reduces flicker, may not work for everyone)
+double_buffer yes
+
+# Minimum size of text area
+minimum_size 330 10
+maximum_width 330
+
+# Draw shades?
+draw_shades yes
+
+# Draw outlines?
+draw_outline no
+
+# Draw borders around text
+draw_borders no
+
+# Stippled borders?
+stippled_borders 2
+
+# border margins
+#border_margin 4
+
+# border width
+border_width 1
+
+# Default colors and also border colors
+default_color green
+default_shade_color black
+default_outline_color white
+
+# Text alignment, other possible values are commented
+#minimum_size 10 10
+gap_x 25
+gap_y 15
+#alignment top_left
+alignment top_right
+#alignment bottom_left
+#alignment bottom_right
+
+# Gap between borders of screen and text
+
+# Add spaces to keep things from moving about?  This only affects certain objects.
+use_spacer none
+
+# Subtract file system buffers from used memory?
+no_buffers yes
+
+# set to yes if you want all text to be in uppercase
 uppercase no
-use_spacer no
 
-TEXT
-$nodename - $sysname $kernel on $machine
-$hr
-${color grey}Uptime:$color $uptime
-${color grey}Frequency (in MHz):$color $freq
-${color grey}Frequency (in GHz):$color $freq_g
-${color grey}RAM Usage:$color $mem/$memmax - $memperc% ${membar 4}
-${color grey}Swap Usage:$color $swap/$swapmax - $swapperc% ${swapbar 4}
-${color grey}CPU Usage:$color $cpu% ${cpubar 4}
-${color grey}Processes:$color $processes  ${color grey}Running:$color $running_processes
-$hr
-${color grey}File systems:
- / $color${fs_free /}/${fs_size /} ${fs_bar 6 /}
-${color grey}Networking:
-Up:$color ${upspeed eth0} k/s${color grey} - Down:$color ${downspeed eth0} k/s
-$hr
-${color grey}Name                  PID   CPU%   MEM%
-${color lightgrey} ${top name 1} ${top pid 1} ${top cpu 1} ${top mem 1}
-${color lightgrey} ${top name 2} ${top pid 2} ${top cpu 2} ${top mem 2}
-${color lightgrey} ${top name 3} ${top pid 3} ${top cpu 3} ${top mem 3}
-${color lightgrey} ${top name 4} ${top pid 4} ${top cpu 4} ${top mem 4}
+# drawn 1 pixel border around graphs or not
+draw_graph_borders no
 
+# Allow for the creation of at least this number of port monitors (if 0 or not set, default is 16) 
+#min_port_monitors 8
+
+# Allow each port monitor to track at least this many connections (if 0 or not set, default is 256)
+#min_port_monitor_connections 64
+
+# none, xmms, bmp, audacious, infopipe (default is none)
+#xmms_player none
+
+TEXT
+$color $alignc$sysname $kernel on $machine
+$color $alignc${exec whoami} @ $nodename
+${color #0077ff}$stippled_hr
+${color #0077ff}Date: $color ${time %A,  %d,  %B}
+${color #0077ff}Time: $color ${time %k:%M:%S}${alignr}${color #0077ff}Uptime: $color $uptime
+${color lightgrey}$stippled_hr
+${color #0077ff}CPU Usage:$color ${cpu}% ${alignr}${color #0077ff}Procs:$color $processes ${color #0077ff}Running:$color $running_processes ${color #0077ff}
+${color #0077ff}${cpubar}
+${color black}${cpugraph 0 32, 350 104E8B 4daaf8}
+${color #0077ff}RAM Usage: $color $mem/$memmax - $memperc% ${color #0077ff}$membar
+${color #0077ff}Swap Usage:$color $swap/$swapmax - $swapperc% ${color #0077ff}${swapbar}
+${color lightgrey}Networking:                                                                                           
+ Down:${color #8844ee} ${downspeed bge0} k/s${color lightgrey} ${offset 80}Up:${color #22ccff} ${upspeed bge} k/s      
+ ${color #0000ff}${downspeedgraph bge0 32,150 ff0000 0000ff} ${color #22ccff}${upspeedgraph bge0 32,150 0000ff ff0000}   
+${color #0077ff}File systems:
+ ${color #0077ff}/         $color${fs_used /}/${fs_size /}${alignr}${color #0077ff}${fs_bar 5,120 /}
+  
diff -rupN conky-1.5.1/src/Makefile.am conky-1.5.1.new/src/Makefile.am
--- conky-1.5.1/src/Makefile.am	2008-03-20 02:00:13.000000000 +0000
+++ conky-1.5.1.new/src/Makefile.am	2009-08-05 13:44:25.059804000 +0000
@@ -89,54 +89,23 @@ smapi = smapi.c smapi.h
 endif
 
 conky_SOURCES = 		\
-	$(audacious)            \
-	$(bmpx)                 \
 	common.c 		\
 	conky.c                 \
 	conky.h                 \
-	$(freebsd)              \
 	fs.c 			\
-	$(hddtemp)		\
-	$(linux) 		\
 	mail.c 			\
-	mixer.c 		\
-	$(mpd)                  \
-	$(netbsd)               \
-	$(openbsd)              \
-	$(port_monitors)        \
-	$(rss)			\
-	$(solaris) 		\
+	solaris.c 		\
 	timed_thread.c		\
 	timed_thread.h		\
 	mboxscan.c		\
 	mboxscan.h		\
 	$(x11)                  \
-	$(xmms2)		\
-	$(smapi)		\
 	users.c
 
 AM_LDFLAGS = $(PTHREAD_LIBS) -lm
 
 EXTRA_DIST = 			\
-	audacious.c		\
-	audacious.h		\
-	bmpx.c			\
-	freebsd.c		\
-	hddtemp.c		\
-	linux.c			\
-	libmpdclient.c          \
-	libmpdclient.h          \
-	libtcp-portmon.c	\
-	libtcp-portmon.h	\
-	mpd.c			\
-	netbsd.c		\
-	openbsd.c		\
-	solaris.c 		\
-	top.h                   \
-	diskio.h                \
 	x11.c                   \
-	xmms2.c                 \
-	smapi.c			\
 	users.c
 
 # vi:set ts=8 sw=8 noet ai nocindent syntax=automake:
diff -rupN conky-1.5.1/src/Makefile.in conky-1.5.1.new/src/Makefile.in
--- conky-1.5.1/src/Makefile.in	2008-04-01 04:13:24.000000000 +0000
+++ conky-1.5.1.new/src/Makefile.in	2009-08-05 13:44:25.062601000 +0000
@@ -73,32 +73,13 @@ CONFIG_CLEAN_FILES = build.h
 am__installdirs = "$(DESTDIR)$(bindir)"
 binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
 PROGRAMS = $(bin_PROGRAMS)
-am__conky_SOURCES_DIST = audacious.c audacious.h bmpx.c common.c \
-	conky.c conky.h freebsd.c diskio.c fs.c hddtemp.c linux.c \
-	top.c mail.c mixer.c mpd.c libmpdclient.c openbsd.c \
-	libtcp-portmon.h libtcp-portmon.c rss.c prss.c prss.h \
-	timed_thread.c timed_thread.h mboxscan.c mboxscan.h x11.c \
-	xmms2.c smapi.c smapi.h users.c
-@BUILD_AUDACIOUS_TRUE@am__objects_1 = audacious.$(OBJEXT)
-@BUILD_BMPX_TRUE@am__objects_2 = bmpx.$(OBJEXT)
-@BUILD_FREEBSD_TRUE@am__objects_3 = freebsd.$(OBJEXT) diskio.$(OBJEXT)
-@BUILD_HDDTEMP_TRUE@am__objects_4 = hddtemp.$(OBJEXT)
-@BUILD_LINUX_TRUE@am__objects_5 = linux.$(OBJEXT) top.$(OBJEXT) \
-@BUILD_LINUX_TRUE@	diskio.$(OBJEXT)
-@BUILD_MPD_TRUE@am__objects_6 = mpd.$(OBJEXT) libmpdclient.$(OBJEXT)
-@BUILD_OPENBSD_TRUE@am__objects_7 = openbsd.$(OBJEXT)
-@BUILD_PORT_MONITORS_TRUE@am__objects_8 = libtcp-portmon.$(OBJEXT)
-@BUILD_RSS_TRUE@am__objects_9 = rss.$(OBJEXT) prss.$(OBJEXT)
-@BUILD_X11_TRUE@am__objects_10 = x11.$(OBJEXT)
-@BUILD_XMMS2_TRUE@am__objects_11 = xmms2.$(OBJEXT)
-@BUILD_SMAPI_TRUE@am__objects_12 = smapi.$(OBJEXT)
-am_conky_OBJECTS = $(am__objects_1) $(am__objects_2) common.$(OBJEXT) \
-	conky.$(OBJEXT) $(am__objects_3) fs.$(OBJEXT) $(am__objects_4) \
-	$(am__objects_5) mail.$(OBJEXT) mixer.$(OBJEXT) \
-	$(am__objects_6) $(am__objects_7) $(am__objects_8) \
-	$(am__objects_9) timed_thread.$(OBJEXT) mboxscan.$(OBJEXT) \
-	$(am__objects_10) $(am__objects_11) $(am__objects_12) \
-	users.$(OBJEXT)
+am__conky_SOURCES_DIST = common.c conky.c conky.h fs.c mail.c \
+	solaris.c timed_thread.c timed_thread.h mboxscan.c mboxscan.h \
+	x11.c users.c
+@BUILD_X11_TRUE@am__objects_1 = x11.$(OBJEXT)
+am_conky_OBJECTS = common.$(OBJEXT) conky.$(OBJEXT) fs.$(OBJEXT) \
+	mail.$(OBJEXT) solaris.$(OBJEXT) timed_thread.$(OBJEXT) \
+	mboxscan.$(OBJEXT) $(am__objects_1) users.$(OBJEXT)
 conky_OBJECTS = $(am_conky_OBJECTS)
 conky_LDADD = $(LDADD)
 DEFAULT_INCLUDES = -I.@am__isrc@
@@ -287,53 +268,22 @@ INCLUDES = \
 @BUILD_RSS_TRUE@rss = rss.c prss.c prss.h
 @BUILD_SMAPI_TRUE@smapi = smapi.c smapi.h
 conky_SOURCES = \
-	$(audacious)            \
-	$(bmpx)                 \
 	common.c 		\
 	conky.c                 \
 	conky.h                 \
-	$(freebsd)              \
 	fs.c 			\
-	$(hddtemp)		\
-	$(linux) 		\
 	mail.c 			\
-	mixer.c 		\
-	$(mpd)                  \
-	$(netbsd)               \
-	$(openbsd)              \
-	$(port_monitors)        \
-	$(rss)			\
-	$(solaris) 		\
+	solaris.c 		\
 	timed_thread.c		\
 	timed_thread.h		\
 	mboxscan.c		\
 	mboxscan.h		\
 	$(x11)                  \
-	$(xmms2)		\
-	$(smapi)		\
 	users.c
 
 AM_LDFLAGS = $(PTHREAD_LIBS) -lm
 EXTRA_DIST = \
-	audacious.c		\
-	audacious.h		\
-	bmpx.c			\
-	freebsd.c		\
-	hddtemp.c		\
-	linux.c			\
-	libmpdclient.c          \
-	libmpdclient.h          \
-	libtcp-portmon.c	\
-	libtcp-portmon.h	\
-	mpd.c			\
-	netbsd.c		\
-	openbsd.c		\
-	solaris.c 		\
-	top.h                   \
-	diskio.h                \
 	x11.c                   \
-	xmms2.c                 \
-	smapi.c			\
 	users.c
 
 all: config.h
@@ -419,7 +369,7 @@ clean-binPROGRAMS:
 	done
 conky$(EXEEXT): $(conky_OBJECTS) $(conky_DEPENDENCIES) 
 	@rm -f conky$(EXEEXT)
-	$(LINK) $(conky_OBJECTS) $(conky_LDADD) $(LIBS)
+	$(LINK) $(conky_OBJECTS) $(conky_LDADD) $(LIBS) -lsocket -lnsl
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -427,30 +377,15 @@ mostlyclean-compile:
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/audacious.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bmpx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/common.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/conky.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/diskio.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/freebsd.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fs.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hddtemp.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmpdclient.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libtcp-portmon.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/linux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mail.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mboxscan.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mixer.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mpd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openbsd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/prss.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rss.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/smapi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/solaris.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/timed_thread.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/top.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/users.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/x11.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xmms2.Po@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
diff -rupN conky-1.5.1/src/common.c conky-1.5.1.new/src/common.c
--- conky-1.5.1/src/common.c	2008-03-31 04:56:41.000000000 +0000
+++ conky-1.5.1.new/src/common.c	2009-08-05 13:44:25.064435000 +0000
@@ -256,15 +256,15 @@ void update_stuff(void)
 	prepare_update();
 
 	if (NEED(INFO_UPTIME)) {
-		update_uptime();
+		get_uptime();
 	}
 
 	if (NEED(INFO_PROCS)) {
-		update_total_processes();
+		get_total_processes();
 	}
 
 	if (NEED(INFO_RUN_PROCS)) {
-		update_running_processes();
+		get_running_processes();
 	}
 
 	if (NEED(INFO_CPU)) {
@@ -275,9 +275,9 @@ void update_stuff(void)
 		update_net_stats();
 	}
 
-	if (NEED(INFO_DISKIO)) {
-		update_diskio();
-	}
+//	if (NEED(INFO_DISKIO)) {
+//		update_diskio();
+//	}
 
 #if defined(__linux__)
 	if (NEED(INFO_I8K)) {
@@ -321,7 +321,9 @@ void update_stuff(void)
 #endif
 
 	if (NEED(INFO_LOADAVG)) {
-		update_load_average();
+		get_load_average1();
+		get_load_average5();
+		get_load_average15();
 	}
 
 	if ((NEED(INFO_MEM) || NEED(INFO_BUFFERS) || NEED(INFO_TOP))
@@ -333,9 +335,9 @@ void update_stuff(void)
 		last_meminfo_update = current_update_time;
 	}
 
-	if (NEED(INFO_TOP)) {
-		update_top();
-	}
+//	if (NEED(INFO_TOP)) {
+//		update_top();
+//	}
 
 	/* update_fs_stat() won't do anything if there aren't fs -things */
 	if (NEED(INFO_FS) && current_update_time - last_fs_update > 12.9) {
@@ -347,15 +349,15 @@ void update_stuff(void)
 		update_tcp_port_monitor_collection(info.p_tcp_port_monitor_collection);
 	}
 #endif
-	if (NEED(INFO_ENTROPY)) {
-		update_entropy();
-	}
+//	if (NEED(INFO_ENTROPY)) {
+//		update_entropy();
+//	}
 	if (NEED(INFO_USERS)) {
 		update_users();
 	}
-	if (NEED(INFO_GW)) {
-		update_gateway_info();
-	}
+//	if (NEED(INFO_GW)) {
+//		update_gateway_info();
+//	}
 	if (NEED(INFO_DNS)) {
 		update_dns_data();
 	}
diff -rupN conky-1.5.1/src/conky.c conky-1.5.1.new/src/conky.c
--- conky-1.5.1/src/conky.c	2008-04-01 03:52:20.000000000 +0000
+++ conky-1.5.1.new/src/conky.c	2009-08-05 13:54:20.979451000 +0000
@@ -25,6 +25,9 @@
  *
  * $Id: conky.c 1091 2008-03-31 15:33:54Z n0-1 $ */
 
+/* Commented non-solaris stuff and added working functions
+ * Copyright (c) 2008 Alexander R. Eremin */
+
 #include "conky.h"
 #include <stdio.h>
 #include <stdlib.h>
@@ -1151,9 +1154,9 @@ enum text_object_type {
 	OBJ_ibm_brightness,
 	OBJ_if_up,
 	OBJ_if_gw,
-	OBJ_ioscheduler,
-	OBJ_gw_iface,
-	OBJ_gw_ip,
+//	OBJ_ioscheduler,
+//	OBJ_gw_iface,
+//	OBJ_gw_ip,
 	OBJ_laptop_mode,
 	OBJ_pb_battery,
 	OBJ_voltage_mv,
@@ -1560,7 +1563,7 @@ void *imap_thread(void *arg)
 	struct mail_s *mail = (struct mail_s *)arg;
 
 	if ((he = gethostbyname(mail->host)) == NULL) {	// get the host info
-		herror("gethostbyname");
+		printf("gethostbyname");
 		exit(1);
 	}
 	while (fail < 5) {
@@ -1746,7 +1749,7 @@ void *pop3_thread(void *arg)
 	struct mail_s *mail = (struct mail_s *)arg;
 
 	if ((he = gethostbyname(mail->host)) == NULL) {	// get the host info
-		herror("gethostbyname");
+		printf("gethostbyname");
 		exit(1);
 	}
 	while (fail < 5) {
@@ -2070,7 +2073,7 @@ static void free_text_objects(unsigned i
 			case OBJ_if_gw:
 				free(objs[i].data.ifblock.s);
 				free(objs[i].data.ifblock.str);
-			case OBJ_gw_iface:
+	/*		case OBJ_gw_iface:
 			case OBJ_gw_ip:
 				if (info.gw_info.iface) {
 					free(info.gw_info.iface);
@@ -2085,6 +2088,7 @@ static void free_text_objects(unsigned i
 				if(objs[i].data.s)
 					free(objs[i].data.s);
 				break;
+*/
 #endif
 #ifdef XMMS2
 			case OBJ_xmms2_artist:
@@ -2165,6 +2169,7 @@ static void free_text_objects(unsigned i
 			case OBJ_bmpx_bitrate:
 				break;
 #endif
+
 #ifdef RSS
 			case OBJ_rss:
 				free(objs[i].data.rss.uri);
@@ -2195,13 +2200,14 @@ static void free_text_objects(unsigned i
 			case OBJ_nameserver:
 				free_dns_data();
 				break;
-			case OBJ_top:
+/*			case OBJ_top:
 			case OBJ_top_mem:
 				if (info.first_process) {
 					free_all_processes();
 					info.first_process = NULL;
 				}
 				break;
+*/
 #ifdef HDDTEMP
 			case OBJ_hddtemp:
 				free(objs[i].data.hddtemp.dev);
@@ -2270,7 +2276,7 @@ static void free_text_objects(unsigned i
 	   text_object_count = 0; */
 }
 
-void scan_mixer_bar(const char *arg, int *a, int *w, int *h)
+/*void scan_mixer_bar(const char *arg, int *a, int *w, int *h)
 {
 	char buf1[64];
 	int n;
@@ -2283,7 +2289,7 @@ void scan_mixer_bar(const char *arg, int
 		scan_bar(arg, w, h);
 	}
 }
-
+*/
 /* strip a leading /dev/ if any */
 #define DEV_NAME(x)	strncmp(x, "/dev/", 5) ? x : x + 5
 
@@ -2311,41 +2317,45 @@ static struct text_object *construct_tex
 	OBJ(freq, INFO_FREQ)
 #else
 	OBJ(acpitemp, 0)
-		obj->data.i = open_acpi_temperature(arg);
+//		obj->data.i = open_acpi_temperature(arg);
 	END OBJ(acpitempf, 0)
-		obj->data.i = open_acpi_temperature(arg);
+//		obj->data.i = open_acpi_temperature(arg);
 	END OBJ(acpiacadapter, 0)
+
 	END OBJ(freq, INFO_FREQ)
-#endif /* !__OpenBSD__ */
-		get_cpu_count();
+
+#endif // !__OpenBSD__ 
+
+//		get_cpu_count();
 		if (!arg || !isdigit(arg[0]) || strlen(arg) >= 2 || atoi(&arg[0]) == 0
 				|| (unsigned int) atoi(&arg[0]) > info.cpu_count) {
 			obj->data.cpu_index = 1;
-			/* ERR("freq: Invalid CPU number or you don't have that many CPUs! "
-				"Displaying the clock for CPU 1."); */
+			// ERR("freq: Invalid CPU number or you don't have that many CPUs! "
+			//	"Displaying the clock for CPU 1."); 
 		} else {
 			obj->data.cpu_index = atoi(&arg[0]);
 		}
 		obj->a = 1;
 	END OBJ(freq_g, INFO_FREQ)
-		get_cpu_count();
+//		get_cpu_count();
 		if (!arg || !isdigit(arg[0]) || strlen(arg) >= 2 || atoi(&arg[0]) == 0
 				|| (unsigned int) atoi(&arg[0]) > info.cpu_count) {
 			obj->data.cpu_index = 1;
-			/* ERR("freq_g: Invalid CPU number or you don't have that many "
-				"CPUs! Displaying the clock for CPU 1."); */
+			// ERR("freq_g: Invalid CPU number or you don't have that many "
+			//	"CPUs! Displaying the clock for CPU 1."); 
 		} else {
 			obj->data.cpu_index = atoi(&arg[0]);
 		}
 		obj->a = 1;
+
 #if defined(__linux__)
 	END OBJ(voltage_mv, 0)
 		get_cpu_count();
 		if (!arg || !isdigit(arg[0]) || strlen(arg) >= 2 || atoi(&arg[0]) == 0
 				|| (unsigned int) atoi(&arg[0]) > info.cpu_count) {
 			obj->data.cpu_index = 1;
-			/* ERR("voltage_mv: Invalid CPU number or you don't have that many "
-				"CPUs! Displaying voltage for CPU 1."); */
+			// ERR("voltage_mv: Invalid CPU number or you don't have that many "
+			//	"CPUs! Displaying voltage for CPU 1."); 
 		} else {
 			obj->data.cpu_index = atoi(&arg[0]);
 		}
@@ -2355,13 +2365,13 @@ static struct text_object *construct_tex
 		if (!arg || !isdigit(arg[0]) || strlen(arg) >= 2 || atoi(&arg[0]) == 0
 				|| (unsigned int) atoi(&arg[0]) > info.cpu_count) {
 			obj->data.cpu_index = 1;
-			/* ERR("voltage_v: Invalid CPU number or you don't have that many "
-				"CPUs! Displaying voltage for CPU 1."); */
+			// ERR("voltage_v: Invalid CPU number or you don't have that many "
+			//	"CPUs! Displaying voltage for CPU 1.");
 		} else {
 			obj->data.cpu_index = atoi(&arg[0]);
 		}
 		obj->a = 1;
-
+*/
 #ifdef HAVE_IWLIB
 	END OBJ(wireless_essid, INFO_NET)
 		if (arg) {
@@ -2603,7 +2613,7 @@ static struct text_object *construct_tex
 			}
 			free(buf);
 		}
-	END OBJ(diskio, INFO_DISKIO)
+/*	END OBJ(diskio, INFO_DISKIO)
 		if (arg) {
 			obj->data.diskio = prepare_diskio_stat(DEV_NAME(arg));
 		} else {
@@ -2651,6 +2661,7 @@ static struct text_object *construct_tex
 		} else {
 			obj->data.diskio = NULL;
 		}
+*/
 	END OBJ(color, 0)
 #ifdef X11
 		obj->data.l = arg ? get_x11_color(arg) : default_fg_color;
@@ -2909,7 +2920,7 @@ static struct text_object *construct_tex
 		obj->data.pair.b = b;
 
 #ifndef __OpenBSD__
-	END OBJ(i2c, INFO_SYSFS)
+/*	END OBJ(i2c, INFO_SYSFS)
 		char buf1[64], buf2[64];
 		int n;
 
@@ -2921,8 +2932,8 @@ static struct text_object *construct_tex
 		}
 
 		if (sscanf(arg, "%63s %63s %d", buf1, buf2, &n) != 3) {
-			/* if scanf couldn't read three values, read type and num and use
-			 * default device */
+			// if scanf couldn't read three values, read type and num and use
+			 // default device 
 			sscanf(arg, "%63s %d", buf2, &n);
 			obj->data.sysfs.fd = open_i2c_sensor(0, buf2, n,
 				&obj->data.sysfs.arg, obj->data.sysfs.devtype);
@@ -2944,8 +2955,8 @@ static struct text_object *construct_tex
 		}
 
 		if (sscanf(arg, "%63s %63s %d", buf1, buf2, &n) != 3) {
-			/* if scanf couldn't read three values, read type and num and use
-			 * default device */
+			// if scanf couldn't read three values, read type and num and use
+			//  default device 
 			sscanf(arg, "%63s %d", buf2, &n);
 			obj->data.sysfs.fd = open_platform_sensor(0, buf2, n,
 				&obj->data.sysfs.arg, obj->data.sysfs.devtype);
@@ -2967,8 +2978,8 @@ static struct text_object *construct_tex
 		}
 
 		if (sscanf(arg, "%63s %63s %d", buf1, buf2, &n) != 3) {
-			/* if scanf couldn't read three values, read type and num and use
-			 * default device */
+			// if scanf couldn't read three values, read type and num and use
+			 // default device 
 			sscanf(arg, "%63s %d", buf2, &n);
 			obj->data.sysfs.fd = open_hwmon_sensor(0, buf2, n,
 				&obj->data.sysfs.arg, obj->data.sysfs.devtype);
@@ -2978,6 +2989,7 @@ static struct text_object *construct_tex
 				&obj->data.sysfs.arg, obj->data.sysfs.devtype);
 			strncpy(obj->data.sysfs.type, buf2, 63);
 		}
+*/		
 #endif /* !__OpenBSD__ */
 
 	END OBJ(top, INFO_TOP)
@@ -3359,7 +3371,7 @@ static struct text_object *construct_tex
 		if (buf) {
 			free(buf);
 		}
-	END OBJ(mixer, INFO_MIXER)
+/*	END OBJ(mixer, INFO_MIXER)
 		obj->data.l = mixer_init(arg);
 	END OBJ(mixerl, INFO_MIXER)
 		obj->data.l = mixer_init(arg);
@@ -3374,6 +3386,7 @@ static struct text_object *construct_tex
 	END OBJ(mixerrbar, INFO_MIXER)
 		scan_mixer_bar(arg, &obj->data.mixerbar.l, &obj->data.mixerbar.w,
 			&obj->data.mixerbar.h);
+*/
 	END OBJ(new_mails, 0)
 		float n1;
 		char box[256], dst[256];
@@ -3424,7 +3437,7 @@ static struct text_object *construct_tex
 		scan_bar(arg, &obj->data.pair.a, &obj->data.pair.b);
 	END OBJ(sysname, 0)
 #ifndef __OpenBSD__
-	END OBJ(temp1, INFO_SYSFS)
+/*	END OBJ(temp1, INFO_SYSFS)
 		obj->type = OBJ_i2c;
 		obj->data.sysfs.fd = open_i2c_sensor(0, "temp", 1,
 			&obj->data.sysfs.arg, obj->data.sysfs.devtype);
@@ -3432,6 +3445,7 @@ static struct text_object *construct_tex
 		obj->type = OBJ_i2c;
 		obj->data.sysfs.fd = open_i2c_sensor(0, "temp", 2,
 			&obj->data.sysfs.arg, obj->data.sysfs.devtype);
+*/
 #endif
 	END OBJ(time, 0)
 		obj->data.s = strdup(arg ? arg : "%F %T");
@@ -3529,9 +3543,9 @@ static struct text_object *construct_tex
 	END OBJ(user_times, INFO_USERS)
 	END OBJ(user_terms, INFO_USERS)
 	END OBJ(user_number, INFO_USERS)
-	END OBJ(gw_iface, INFO_GW)
-	END OBJ(gw_ip, INFO_GW)
-	END OBJ(if_gw, INFO_GW)
+//	END OBJ(gw_iface, INFO_GW)
+//	END OBJ(gw_ip, INFO_GW)
+//	END OBJ(if_gw, INFO_GW)
 #ifndef __OpenBSD__
 	END OBJ(adt746xcpu, 0)
 	END OBJ(adt746xfan, 0)
@@ -4186,19 +4200,20 @@ static void generate_text_internal(char 
 			default:
 				ERR("not implemented obj type %d", obj->type);
 #ifndef __OpenBSD__
-			OBJ(acpitemp) {
-				/* does anyone have decimals in acpi temperature? */
+/*			OBJ(acpitemp) {
+				// does anyone have decimals in acpi temperature? 
 				spaced_print(p, p_max_size, "%d", 5, "acpitemp",
 					round_to_int(get_acpi_temperature(obj->data.i)));
 			}
 			OBJ(acpitempf) {
-				/* does anyone have decimals in acpi temperature? */
+				// does anyone have decimals in acpi temperature? 
 				spaced_print(p, p_max_size, "%d", 5, "acpitemp",
 					round_to_int((get_acpi_temperature(obj->data.i) + 40) *
 					9.0 / 5 - 40));
 			}
+			*/
 #endif /* !__OpenBSD__ */
-			OBJ(freq) {
+/*			OBJ(freq) {
 				if (obj->a) {
 					obj->a = get_freq(p, p_max_size, "%.0f", 1,
 						obj->data.cpu_index);
@@ -4210,12 +4225,13 @@ static void generate_text_internal(char 
 					obj->a = get_freq(p, p_max_size, "%'.2f", 1000,
 						obj->data.cpu_index);
 #else
-					/* OpenBSD has no such flag (SUSv2) */
-					obj->a = get_freq(p, p_max_size, "%.2f", 1000,
+*/					/* OpenBSD has no such flag (SUSv2) */
+/*					obj->a = get_freq(p, p_max_size, "%.2f", 1000,
 						obj->data.cpu_index);
 #endif
 				}
 			}
+*/
 #if defined(__linux__)
 			OBJ(voltage_mv) {
 				if (obj->a) {
@@ -4270,11 +4286,12 @@ static void generate_text_internal(char 
 
 #endif /* __linux__ */
 
-			OBJ(freq_dyn) {
+	/*		OBJ(freq_dyn) {
 				get_freq_dynamic(p, p_max_size, "%.0f", 1);
 				spaced_print(p, p_max_size, "%s", 6, "freq_dyn", p);
 			}
-			OBJ(freq_dyn_g) {
+	*/
+/*			OBJ(freq_dyn_g) {
 #ifndef __OpenBSD__
 				get_freq_dynamic(p, p_max_size, "%'.2f", 1000);
 #else
@@ -4282,9 +4299,9 @@ static void generate_text_internal(char 
 #endif
 				spaced_print(p, p_max_size, "%s", 6, "freq_dyn", p);
 			}
-
+*/
 #ifndef __OpenBSD__
-			OBJ(adt746xcpu) {
+	/*		OBJ(adt746xcpu) {
 				get_adt746x_cpu(p, p_max_size);
 			}
 			OBJ(adt746xfan) {
@@ -4309,6 +4326,7 @@ static void generate_text_internal(char 
 			OBJ(battery_bar) {
 				new_bar(p, obj->a, obj->b, get_battery_perct_bar(obj->data.s));
 			}
+*/
 #endif /* __OpenBSD__ */
 
 			OBJ(buffers) {
@@ -4318,21 +4336,21 @@ static void generate_text_internal(char 
 				human_readable(cur->cached * 1024, p, 255, "buffers");
 			}
 			OBJ(cpu) {
-				if (obj->data.cpu_index > info.cpu_count) {
-					printf("obj->data.cpu_index %i info.cpu_count %i",
-						obj->data.cpu_index, info.cpu_count);
-					CRIT_ERR("attempting to use more CPUs then you have!");
-				}
+//				if (obj->data.cpu_index > info.cpu_count) {
+//					printf("obj->data.cpu_index %i info.cpu_count %i",
+//						obj->data.cpu_index, info.cpu_count);
+//					CRIT_ERR("attempting to use more CPUs then you have!");
+//				}
 				spaced_print(p, p_max_size, "%*d", 4, "cpu", pad_percents,
-					round_to_int(cur->cpu_usage[obj->data.cpu_index] * 100.0));
+					(int)(cpu_usage * 100.0));
 			}
 			OBJ(cpubar) {
 				new_bar(p, obj->a, obj->b,
-					round_to_int(cur->cpu_usage[obj->data.cpu_index] * 255.0));
+					(int)(cpu_usage * 255.0));
 			}
 			OBJ(cpugraph) {
 				new_graph(p, obj->a, obj->b, obj->c, obj->d, (unsigned int)
-					round_to_int(cur->cpu_usage[obj->data.cpu_index] * 100),
+					(int)(cpu_usage * 100),
 					100, 1);
 			}
 			OBJ(color) {
@@ -4473,7 +4491,7 @@ static void generate_text_internal(char 
 					if_jumped = 0;
 				}
 			}
-			OBJ(if_gw) {
+		/*	OBJ(if_gw) {
 				if (!cur->gw_info.count) {
 					i = obj->data.ifblock.pos;
 					if_jumped = 1;
@@ -4481,12 +4499,12 @@ static void generate_text_internal(char 
 					if_jumped = 0;
 				}
 			}
-			OBJ(gw_iface) {
-				snprintf(p, p_max_size, "%s", cur->gw_info.iface);
-			}
-			OBJ(gw_ip) {
-				snprintf(p, p_max_size, "%s", cur->gw_info.ip);
-			}
+		//	OBJ(gw_iface) {
+		//		snprintf(p, p_max_size, "%s", cur->gw_info.iface);
+		//	}
+		//	OBJ(gw_ip) {
+		//		snprintf(p, p_max_size, "%s", cur->gw_info.ip);
+		*/	}
 			OBJ(laptop_mode) {
 				snprintf(p, p_max_size, "%d", get_laptop_mode());
 			}
@@ -4529,7 +4547,7 @@ static void generate_text_internal(char 
 #endif
 			/* TODO: move this correction from kB to kB/s elsewhere
 			 * (or get rid of it??) */
-			OBJ(diskio) {
+/*			OBJ(diskio) {
 				if (obj->data.diskio) {
 					human_readable(
 						(obj->data.diskio->current / update_interval) * 1024LL,
@@ -4584,6 +4602,8 @@ static void generate_text_internal(char 
 						diskio_write_value, obj->e, 1);
 				}
 			}
+			
+*/
 			OBJ(downspeed) {
 				spaced_print(p, p_max_size, "%d", 6, "downspeed",
 					round_to_int(obj->data.net->recv_speed / 1024));
@@ -5120,16 +5140,20 @@ static void generate_text_internal(char 
 					human_readable(obj->data.fs->size, p, 255, "fs_size");
 				}
 			}
-			OBJ(fs_type) {
-				if (obj->data.fs != NULL)
-					snprintf(p, p_max_size, "%s", obj->data.fs->type);
-			}
+//			OBJ(fs_type) {
+//				if (obj->data.fs != NULL)
+//					snprintf(p, p_max_size, "%s", obj->data.fs->type);
+//			}
 			OBJ(fs_used) {
-				if (obj->data.fs != NULL) {
-					human_readable(obj->data.fs->size - (obj->data.fs->free
-						? obj->data.fs->free : obj->data.fs->avail), p, 255,
-						"fs_used");
-				}
+	//			if (obj->data.fs != NULL) {
+	//				human_readable(obj->data.fs->size - (obj->data.fs->free
+	//					? obj->data.fs->free : obj->data.fs->avail), p, 255,
+	//					"fs_used");
+	
+			     if (obj->data.fs != NULL)  {                                                             
+                                             human_readable(obj->data.fs->size - obj->data.fs->avail,                                             
+				                   p, 255, "fs_used");        
+					}
 			}
 			OBJ(fs_bar_free) {
 				if (obj->data.fs != NULL) {
@@ -5154,7 +5178,9 @@ static void generate_text_internal(char 
 				}
 			}
 			OBJ(loadavg) {
-				float *v = info.loadavg;
+	    		snprintf(p, p_max_size, "%3.2f %3.2f %3.2f", get_load_average1(),                        
+	                                              get_load_average5(),get_load_average15());                      
+/*				float *v = info.loadavg;
 
 				if (obj->data.loadavg[2]) {
 					snprintf(p, p_max_size, "%.2f %.2f %.2f",
@@ -5169,7 +5195,7 @@ static void generate_text_internal(char 
 					snprintf(p, p_max_size, "%.2f",
 						v[obj->data.loadavg[0] - 1]);
 				}
-			}
+*/			}
 			OBJ(goto) {
 				new_goto(p, obj->data.i);
 			}
@@ -5276,7 +5302,7 @@ static void generate_text_internal(char 
 				new_voffset(p, obj->data.i);
 			}
 #ifndef __OpenBSD__
-			OBJ(i2c) {
+/*			OBJ(i2c) {
 				double r;
 
 				r = get_sysfs_info(&obj->data.sysfs.fd, obj->data.sysfs.arg,
@@ -5288,6 +5314,7 @@ static void generate_text_internal(char 
 					snprintf(p, p_max_size, "%.1f", r);
 				}
 			}
+
 			OBJ(platform) {
 				double r;
 
@@ -5312,6 +5339,7 @@ static void generate_text_internal(char 
 					snprintf(p, p_max_size, "%.1f", r);
 				}
 			}
+*/
 #endif /* !__OpenBSD__ */
 			OBJ(alignr) {
 				new_alignr(p, obj->data.i);
@@ -5358,7 +5386,7 @@ static void generate_text_internal(char 
 					}
 				}
 			}
-			OBJ(if_mounted) {
+/*			OBJ(if_mounted) {
 				if ((obj->data.ifblock.s)
 						&& (!check_mount(obj->data.ifblock.s))) {
 					i = obj->data.ifblock.pos;
@@ -5375,9 +5403,10 @@ static void generate_text_internal(char 
 					if_jumped = 0;
 				}
 			}
-			OBJ(ioscheduler) {
-				snprintf(p, p_max_size, "%s", get_ioscheduler(obj->data.s));
-			}
+*/
+//			OBJ(ioscheduler) {
+//				snprintf(p, p_max_size, "%s", get_ioscheduler(obj->data.s));
+//			}
 			OBJ(kernel) {
 				snprintf(p, p_max_size, "%s", cur->uname_s.release);
 			}
@@ -5387,29 +5416,29 @@ static void generate_text_internal(char 
 
 			/* memory stuff */
 			OBJ(mem) {
-				human_readable(cur->mem * 1024, p, 255, "mem");
+				human_readable(mem * 1024, p, 255, "mem");
 			}
 			OBJ(memmax) {
-				human_readable(cur->memmax * 1024, p, 255, "memmax");
+				human_readable(memmax * 1024, p, 255, "memmax");
 			}
 			OBJ(memperc) {
-				if (cur->memmax) {
-					spaced_print(p, p_max_size, "%*llu", 4, "memperc",
-						pad_percents, cur->mem * 100 / cur->memmax);
+				if (memmax) {
+					spaced_print(p, p_max_size, "%*u", 4, "memperc",
+						pad_percents, mem * 100 / memmax);
 				}
 			}
 			OBJ(membar) {
 				new_bar(p, obj->data.pair.a, obj->data.pair.b,
-					cur->memmax ? (cur->mem * 255) / (cur->memmax) : 0);
+					memmax ? (mem * 255) / (memmax) : 0);
 			}
 			OBJ(memgraph) {
 				new_graph(p, obj->a, obj->b, obj->c, obj->d,
-					cur->memmax ? (cur->mem * 100.0) / (cur->memmax) : 0.0,
+					memmax ? (mem * 100.0) / (memmax) : 0.0,
 					100, 1);
 			}
 
 			/* mixer stuff */
-			OBJ(mixer) {
+	/*		OBJ(mixer) {
 				snprintf(p, p_max_size, "%d", mixer_get_avg(obj->data.l));
 			}
 			OBJ(mixerl) {
@@ -5430,7 +5459,7 @@ static void generate_text_internal(char 
 				new_bar(p, obj->data.mixerbar.w, obj->data.mixerbar.h,
 					mixer_get_right(obj->data.mixerbar.l) * 255 / 100);
 			}
-
+*/
 			/* mail stuff */
 			OBJ(mails) {
 				update_mail_count(&obj->data.local_mail);
@@ -5453,10 +5482,10 @@ static void generate_text_internal(char 
 				new_outline(p, obj->data.l);
 			}
 			OBJ(processes) {
-				spaced_print(p, p_max_size, "%hu", 5, "processes", cur->procs);
+				spaced_print(p, p_max_size, "%hu", 5, "processes", get_total_processes());
 			}
 			OBJ(running_processes) {
-				spaced_print(p, p_max_size, "%hu", 3, "running_processes", cur->run_procs);
+				spaced_print(p, p_max_size, "%hu", 3, "running_processes", get_running_processes());
 			}
 			OBJ(text) {
 				snprintf(p, p_max_size, "%s", obj->data.s);
@@ -5468,22 +5497,22 @@ static void generate_text_internal(char 
 				new_stippled_hr(p, obj->data.pair.a, obj->data.pair.b);
 			}
 			OBJ(swap) {
-				human_readable(cur->swap * 1024, p, 255, "swap");
+				human_readable(swap * 1024, p, 255, "swap");
 			}
 			OBJ(swapmax) {
-				human_readable(cur->swapmax * 1024, p, 255, "swapmax");
+				human_readable(swapmax * 1024, p, 255, "swapmax");
 			}
 			OBJ(swapperc) {
-				if (cur->swapmax == 0) {
+				if (swapmax == 0) {
 					strncpy(p, "No swap", p_max_size);
 				} else {
-					spaced_print(p, p_max_size, "%*llu", 4, "swapperc",
-						pad_percents, cur->swap * 100 / cur->swapmax);
+					spaced_print(p, p_max_size, "%*u", 4, "swapperc",
+						pad_percents, swap * 100 / swapmax);
 				}
 			}
 			OBJ(swapbar) {
 				new_bar(p, obj->data.pair.a, obj->data.pair.b,
-					cur->swapmax ? (cur->swap * 255) / (cur->swapmax) : 0);
+					swapmax ? (swap * 255) / (swapmax) : 0);
 			}
 			OBJ(sysname) {
 				snprintf(p, p_max_size, "%s", cur->uname_s.sysname);
@@ -5546,10 +5575,10 @@ static void generate_text_internal(char 
 					obj->data.net->trans_speed / 1024.0, obj->e, 1);
 			}
 			OBJ(uptime_short) {
-				format_seconds_short(p, p_max_size, (int) cur->uptime);
+				format_seconds_short(p, p_max_size, (int) get_uptime());
 			}
 			OBJ(uptime) {
-				format_seconds(p, p_max_size, (int) cur->uptime);
+				format_seconds(p, p_max_size, (int) get_uptime());
 			}
 			OBJ(user_names) {
 				snprintf(p, p_max_size, "%s", cur->users.names);
@@ -7627,7 +7656,7 @@ void clean_up(void)
 		specials = NULL;
 	}
 
-	clear_diskio_stats();
+	//clear_diskio_stats();
 }
 
 static int string_to_bool(const char *s)
diff -rupN conky-1.5.1/src/conky.h conky-1.5.1.new/src/conky.h
--- conky-1.5.1/src/conky.h	2008-03-31 04:56:42.000000000 +0000
+++ conky-1.5.1.new/src/conky.h	2009-08-05 13:44:25.080568000 +0000
@@ -83,6 +83,11 @@
 #include "mboxscan.h"
 #include "timed_thread.h"
 
+#ifndef MIN                                                                                                             
+#define MIN(a,b) (a>b ? b : a)                                                                                          
+#endif    
+
+
 enum {
 	TOP_CPU,
 	TOP_NAME,
@@ -156,16 +161,14 @@ unsigned int diskio_value;
 unsigned int diskio_read_value;
 unsigned int diskio_write_value;
 
-struct fs_stat {
-	char path[DEFAULT_TEXT_BUFFER_SIZE];
-	char type[DEFAULT_TEXT_BUFFER_SIZE];
-	long long size;
-	long long avail;
-	long long free;
-	char set;
-};
+struct fs_stat {                                                                                                        
+	int fd;                                                                                                         
+	char *path;                                                                                                     
+	long long size;                                                                                                 
+	long long avail;                                                                                                
+};     
+
 
-#include "diskio.h"
 
 struct mail_s {			// for imap and pop3
 	unsigned long unseen;
@@ -569,15 +572,17 @@ char *get_ioscheduler(char *);
 int get_laptop_mode(void);
 void update_gateway_info(void);
 
-int open_sysfs_sensor(const char *dir, const char *dev, const char *type, int n,
-	int *div, char *devtype);
+//int open_sysfs_sensor(const char *dir, const char *dev, const char *type, int n,
+//	int *div, char *devtype);
 
+/*
 #define open_i2c_sensor(dev, type, n, div, devtype) \
 	open_sysfs_sensor("/sys/bus/i2c/devices/", dev, type, n, div, devtype)
 #define open_platform_sensor(dev, type, n, div, devtype) \
 	open_sysfs_sensor("/sys/bus/platform/devices/", dev, type, n, div, devtype)
 #define open_hwmon_sensor(dev, type, n, div, devtype) \
 	open_sysfs_sensor("/sys/class/hwmon/", dev, type, n, div, devtype)
+*/
 
 double get_sysfs_info(int *fd, int arg, char *devtype, char *type);
 
@@ -721,3 +726,18 @@ void free_rss_info(void);
 /* in linux.c */
 
 #endif
+
+extern unsigned int mem, memmax, swap, swapmax, bufmem, buffers, cached;                                                
+                                                                                                                        
+double get_uptime(void);                                                                                                
+void update_meminfo(void);                                                                                              
+void update_net_stats(void);                                                                                            
+void update_cpu_usage(void);                                                                                            
+int get_total_processes(void);                                                                                          
+int get_running_processes(void);                                                                                        
+int get_recv_speed(void);                                                                                               
+int get_trans_speed(void);                                                                                              
+double get_load_average1();                                                                                             
+double get_load_average5();                                                                                             
+double get_load_average15();                   
+double cpu_usage;
diff -rupN conky-1.5.1/src/fs.c conky-1.5.1.new/src/fs.c
--- conky-1.5.1/src/fs.c	2008-03-31 04:56:42.000000000 +0000
+++ conky-1.5.1.new/src/fs.c	2009-08-05 13:44:25.083815000 +0000
@@ -1,185 +1,85 @@
-/* Conky, a system monitor, based on torsmo
- *
- * Any original torsmo code is licensed under the BSD license
- *
- * All code written since the fork of torsmo is licensed under the GPL
- *
- * Please see COPYING for details
- *
- * Copyright (c) 2004, Hannu Saransaari and Lauri Hakkarainen
- * Copyright (c) 2005-2008 Brenden Matthews, Philip Kovacs, et. al.
- *	(see AUTHORS)
- * All rights reserved.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * $Id: fs.c 1090 2008-03-31 04:56:39Z brenden1 $ */
-
 #include "conky.h"
 #include <unistd.h>
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
+#include <sys/statvfs.h>
 #include <sys/types.h>
 #include <fcntl.h>
 
-/* linux */
-#ifdef HAVE_SYS_STATFS_H
-#include <sys/statfs.h>
-#endif
-
-/* freebsd && netbsd */
-#ifdef HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-#ifdef HAVE_SYS_MOUNT_H
-#include <sys/mount.h>
-#endif
-
-#ifndef HAVE_STRUCT_STATFS_F_FSTYPENAME
-#include <mntent.h>
-#endif
+/* TODO: benchmark which is faster, fstatvfs() or pre-opened fd and
+ * statvfs() (fstatvfs() would handle mounts I think...) */
 
-#define MAX_FS_STATS 64
-
-static struct fs_stat fs_stats_[MAX_FS_STATS];
+static struct fs_stat fs_stats_[64];
 struct fs_stat *fs_stats = fs_stats_;
 
-static void update_fs_stat(struct fs_stat *fs);
-
-void get_fs_type(const char *path, char *result);
-
-void update_fs_stats(void)
-{
-	unsigned i;
-
-	for (i = 0; i < MAX_FS_STATS; ++i) {
-		if (fs_stats[i].set) {
-			update_fs_stat(&fs_stats[i]);
-		}
-	}
+void update_fs_stats() {
+  unsigned int i;
+  struct statvfs s;
+  for (i=0; i<16; i++) {
+    if (fs_stats[i].fd <= 0)
+      break;
+
+    fstatvfs(fs_stats[i].fd, &s);
+
+    fs_stats[i].size = (long long) s.f_blocks * s.f_frsize;
+    /* bfree (root) or bavail (non-roots) ? */
+    fs_stats[i].avail = (long long) s.f_bavail * s.f_frsize;
+  }
 }
 
-void clear_fs_stats(void)
-{
-	unsigned i;
-	for (i = 0; i < MAX_FS_STATS; ++i) {
-		memset(&fs_stats[i], 0, sizeof(struct fs_stat));
-	}
+void clear_fs_stats() {
+  unsigned int i;
+  for (i=0; i<16; i++) {
+    if (fs_stats[i].fd) {
+      close(fs_stats[i].fd);
+      fs_stats[i].fd = -1;
+    }
+
+    if (fs_stats[i].path != NULL) {
+      free(fs_stats[i].path);
+      fs_stats[i].path = NULL;
+    }
+  }
 }
 
-struct fs_stat *prepare_fs_stat(const char *s)
-{
-	struct fs_stat *new = 0;
-	unsigned i;
-
-	/* lookup existing or get new */
-	for (i = 0; i < MAX_FS_STATS; ++i) {
-		if (fs_stats[i].set) {
-			if (strncmp(fs_stats[i].path, s, DEFAULT_TEXT_BUFFER_SIZE) == 0) {
-				return &fs_stats[i];
-			}
-		} else {
-			new = &fs_stats[i];
-		}
-	}
-	/* new path */
-	if (!new) {
-		ERR("too many fs stats");
-		return 0;
-	}
-	strncpy(new->path, s, DEFAULT_TEXT_BUFFER_SIZE);
-	new->set = 1;
-	update_fs_stat(new);
-	return new;
-}
+struct fs_stat *prepare_fs_stat(const char *s) {
+  unsigned int i;
 
-static void update_fs_stat(struct fs_stat *fs)
-{
-	struct statfs s;
-
-	if (statfs(fs->path, &s) == 0) {
-		fs->size = (long long)s.f_blocks * s.f_bsize;
-		/* bfree (root) or bavail (non-roots) ? */
-		fs->avail = (long long)s.f_bavail * s.f_bsize;
-		fs->free = (long long)s.f_bfree * s.f_bsize;
-		get_fs_type(fs->path, fs->type);
-	} else {
-		fs->size = 0;
-		fs->avail = 0;
-		fs->free = 0;
-		strncpy(fs->type, "unknown", DEFAULT_TEXT_BUFFER_SIZE);
-		ERR("statfs '%s': %s", fs->path, strerror(errno));
-	}
-}
+  for (i=0; i<16; i++) {
+    struct fs_stat *fs = &fs_stats[i];
 
-void get_fs_type(const char *path, char *result)
-{
+    if (fs->path && strcmp(fs->path, s) == 0)
+      return fs;
 
-#ifdef HAVE_STRUCT_STATFS_F_FSTYPENAME
+    if (fs->fd <= 0) {
+      /* when compiled with icc, it crashes when leaving function and open()
+       * is used, I don't know why */
+
+      /* this icc workaround didn't seem to work */
+#if 0
+      {
+        FILE *fp = fopen(s, "r");
+        if(fp)
+          fs->fd = fileno(fp);
+        else
+          fs->fd = -1;
+      }
+#endif
 
-	struct statfs s;
-	if (statfs(path, &s) == 0) {
-		strncpy(result, s.f_fstypename, DEFAULT_TEXT_BUFFER_SIZE);
-	} else {
-		ERR("statfs '%s': %s", path, strerror(errno));
-	}
-	return;
-
-#else				/* HAVE_STRUCT_STATFS_F_FSTYPENAME */
-
-	struct mntent *me;
-	FILE *mtab = setmntent("/etc/mtab", "r");
-	char *search_path;
-	int match;
-	char *slash;
-
-	if (mtab == NULL) {
-		ERR("setmntent /etc/mtab: %s", strerror(errno));
-		strncpy(result, "unknown", DEFAULT_TEXT_BUFFER_SIZE);
-		return;
-	}
-
-	me = getmntent(mtab);
-
-	// find our path in the mtab
-	search_path = strdup(path);
-	do {
-		while ((match = strcmp(search_path, me->mnt_dir))
-				&& getmntent(mtab));
-		if (!match)
-			break;
-		fseek(mtab, 0, SEEK_SET);
-		slash = strrchr(search_path, '/');
-		if (slash == NULL)
-			CRIT_ERR("invalid path '%s'", path);
-		if (strlen(slash) == 1)		/* trailing slash */
-			*(slash) = '\0';
-		else if (strlen(slash) > 1)
-			*(slash + 1) = '\0';
-		else
-			CRIT_ERR("found a crack in the matrix!");
-	} while (strlen(search_path) > 0);
-	free(search_path);
-
-	endmntent(mtab);
-
-	if (me && !match) {
-		strncpy(result, me->mnt_type, DEFAULT_TEXT_BUFFER_SIZE);
-		return;
-	}
-#endif				/* HAVE_STRUCT_STATFS_F_FSTYPENAME */
+      fs->fd = open(s, O_RDONLY);
 
-	strncpy(result, "unknown", DEFAULT_TEXT_BUFFER_SIZE);
+      if (fs->fd <= 0) { /* 0 isn't error but actually it is :) */
+        ERR("open '%s': %s", s, strerror(errno));
+        return 0;
+      }
+
+      fs->path = strdup(s);
+      update_fs_stats();
+      return fs;
+    }
+  }
 
+  ERR("too many fs stats");
+  return 0;
 }
diff -rupN conky-1.5.1/src/solaris.c conky-1.5.1.new/src/solaris.c
--- conky-1.5.1/src/solaris.c	2008-03-31 04:56:42.000000000 +0000
+++ conky-1.5.1.new/src/solaris.c	2009-08-05 13:39:16.000000000 +0000
@@ -1,82 +1,314 @@
-/* Conky, a system monitor, based on torsmo
- *
- * Any original torsmo code is licensed under the BSD license
- *
- * All code written since the fork of torsmo is licensed under the GPL
- *
- * Please see COPYING for details
- *
- * Copyright (c) 2005-2008 Brenden Matthews, Philip Kovacs, et. al.
- *	(see AUTHORS)
- * All rights reserved.
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * $Id: solaris.c 1090 2008-03-31 04:56:39Z brenden1 $ */
+//  Added initial Solaris support -  Alexander R. Eremin http://www.milax.org 16 May 2008 */
+//  Updated update_net_stats - Alexander R. Eremin http://www.milax.org 05 August 2009 */
 
-/* doesn't work, feel free to finish this */
 #include "conky.h"
 #include <kstat.h>
-
-static kstat_ctl_t *kstat;
+#include <errno.h>
+#include <utmp.h>   
+#include <net/if.h>
+#include <sys/sockio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/swap.h>
+#include <stdio.h>
+#include <sys/sysinfo.h>
+#include <string.h>
+#include <sys/loadavg.h>
+#include <sys/types.h>                                                                                        
+#include <sys/socket.h>                                                                                       
+#include <sys/ioctl.h>                                                                                        
+#include <sys/dlpi.h>                                                                                         
+#include <net/if.h>                                                                                           
+#include <sys/sockio.h>                                                                                       
+#include <strings.h>   
+#include <netinet/in.h>                                                                                       
+                                                                                                              
+
+#define ONE_KB (1024)     
+
+static int show_nice_processes; 
+
+
+static kstat_ctl_t *kc;
+static kstat_named_t *data_lookup;                                                                                                                                  
+static kstat_t *ksp;
 static int kstat_updated;
+static int stat_updated;                                                                                                                                     
+static int net_updated;    
+unsigned int mem, memmax, swap, swapmax, bufmem, buffers, cached;                                                
+double cpu_usage;        
+
+static void update_kstat() {
+  if (kc == NULL) {
+    kc = kstat_open();
+    if (kc == NULL) {
+      printf("can't open kstat");
+    }
+  }
+
+  if (kstat_chain_update(kc) == -1) {
+    perror("kstat_chain_update");
+    return;
+  }
+}
 
-static void update_kstat()
-{
-	if (kstat == NULL) {
-		kstat = kstat_open();
-		if (kstat == NULL) {
-			ERR("can't open kstat: %s", strerror(errno));
-		}
-	}
+void prepare_update() {
+  kstat_updated = 0;
+  stat_updated = 0;                                                                                                                                     
+  net_updated = 0;  
+}
 
-	if (kstat_chain_update(kstat) == -1) {
-		perror("kstat_chain_update");
-		return;
+double get_uptime() {
+  double t = 0;
+  update_kstat();
+
+  ksp = kstat_lookup(kc, "unix", -1, "system_misc");
+  if (ksp != NULL) {
+    if (kstat_read(kc, ksp, NULL) >= 0) {
+      data_lookup = (kstat_named_t *) kstat_data_lookup(ksp, "boot_time");
+      if (data_lookup != NULL) 
+        t = get_time() - (double) data_lookup->value.ui32;
+     }
+  }
+  return t;
+}
+
+                                                                                                                                                             
+void update_meminfo() {
+
+    static int meminfo_updated;                                                                                                                                  
+    if (meminfo_updated) return;                                                                                                                               
+	meminfo_updated = 1;                                                                                                                                       
+    
+    struct anoninfo ai;
+    
+    long swapalloc, swapresv, swapavail, swaptotal;
+    long page_size;                                                                                                                                      
+    long num_pages;                                                                                                                                      
+    long free_pages;                                                                                                                                     
+    longlong_t fmem;                                                                                                                                      
+    longlong_t free_mem;                                                                                                                                 
+    page_size = sysconf (_SC_PAGESIZE);                                                                                                                  
+    num_pages = sysconf (_SC_PHYS_PAGES);                                                                                                                
+    free_pages = sysconf (_SC_AVPHYS_PAGES);                                                                                                             
+    fmem = (longlong_t) ((longlong_t) num_pages * (longlong_t) page_size);                                                                                
+    free_mem = (longlong_t) free_pages * (longlong_t) page_size;                                                                                         
+
+    fmem /= ONE_KB; 
+    free_mem /= ONE_KB;
+    memmax = fmem;
+    mem = memmax - free_mem;
+
+    swapctl( SC_AINFO, &ai);
+    swapalloc  = ai.ani_max - ai.ani_free;
+    swapalloc *= page_size;
+    swapresv   = ai.ani_resv + ai.ani_free - ai.ani_max;
+    swapresv  *= page_size;
+    swapavail  = ai.ani_max - ai.ani_resv;
+    swapavail *= page_size;
+    swaptotal = ai.ani_max;
+    swaptotal *= page_size;
+
+    swap = swapalloc + swapresv;
+    swapmax = swaptotal;									
+    swap /= ONE_KB;
+    swapmax /= ONE_KB;
+    
+}
+
+static unsigned int cpu_user, cpu_system, cpu_nice;  
+
+static void update_stat() {                                                                                                                                  
+
+cpu_stat_t *cpu_stat;
+
+update_kstat();
+if (kc != NULL) {
+
+
+    ksp = kstat_lookup(kc, "cpu_stat", 0, "cpu_stat0");
+
+    if (ksp != NULL && ksp->ks_type == KSTAT_TYPE_RAW)
+    {
+	if (kstat_read(kc, ksp, NULL) != -1 &&  ksp->ks_data_size == sizeof(cpu_stat_t))
+	{
+	    cpu_stat = (cpu_stat_t *)ksp->ks_data;
+	//    cpu_stat->cpu_sysinfo.cpu[CPU_IDLE]);
+	    cpu_user=cpu_stat->cpu_sysinfo.cpu[CPU_USER];
+	    cpu_nice=cpu_stat->cpu_sysinfo.cpu[CPU_WAIT]; 
+	    cpu_system = cpu_stat->cpu_sysinfo.cpu[CPU_KERNEL] ;
+	    
 	}
+    }
+}
 }
 
-void prepare_update()
-{
-	kstat_updated = 0;
+static double last_cpu_sum;                                                                                                                                  
+static double last_cpu_calc_time;                                                                                                                            
+                                                                                                                                                             
+void update_cpu_usage() {                                                                                                                                    
+    double t, delta;                                                                                                                                           
+    cpu_usage =0;                    
+    if (stat_updated) return;                                                                                                                                  
+      stat_updated = 1;                                                                                                                                                  
+    t = get_time();                                                                                                                                            
+    delta = t - last_cpu_calc_time;                                                                                                                            
+                                                                                                                                                   
+    if(delta <= 0.05) return;                                                                                                                                  
+                                                                                                                                                             
+    last_cpu_calc_time = t;                                                                                                                                    
+    update_stat();                                                                                                                                             
+
+    cpu_usage = (cpu_user+cpu_nice+cpu_system - last_cpu_sum) / delta / 100.0;                                                                                 
+    last_cpu_sum = cpu_user+cpu_nice+cpu_system;                                                                                                               
+}      
+		
+		
+int get_total_processes() {                                                                                                                                  
+    int nproc=0;                                                                                                                                                   
+                                                                                                                                   
+    update_kstat();
+if (kc != NULL) {
+                                                                                                                                                         
+        ksp = kstat_lookup(kc, "unix", 0, "system_misc");                                                                                                      
+	if (kstat_read(kc, ksp, 0) == -1)                                                                                                                      
+	    fprintf(stderr,"kstat read");                                                                                                                                
+                                                                                                                                                             
+	data_lookup = kstat_data_lookup(ksp, "nproc");                                                                                                            
+	if (data_lookup) 
+	    nproc = data_lookup->value.ui32;                                                                                                            
+}
+	return nproc;                                                                                                                                       
 }
 
-double get_uptime()
+int get_running_processes() {
+    static struct utmp *utmpp;        
+    int  uproc = 0;                                                                                                                                               
+    setutent();                                                                                                                                              
+    while ((utmpp = getutent()) != NULL) {                                                                                                                   
+       if (utmpp->ut_type == USER_PROCESS && utmpp->ut_name[0] != '\0')                                                                                     
+           uproc++;                                                                                                                                         
+       }                                                                                                                                                        
+   return uproc;                             
+}    
+						
+
+
+void update_net_stats()
 {
-	kstat_t *ksp;
+	struct net_stat *ns;
 
-	update_kstat();
+	double delta;
+	long long r, t, last_recv, last_trans;
 
-	ksp = kstat_lookup(kstat, "unix", -1, "system_misc");
-	if (ksp != NULL) {
-		if (kstat_read(kstat, ksp, NULL) >= 0) {
-			kstat_named_t *knp;
-
-			knp = (kstat_named_t *) kstat_data_lookup(ksp, "boot_time");
-			if (knp != NULL) {
-				return get_time() - (double) knp->value.ui32;
-			}
-		}
+	/* get delta */
+	delta = current_update_time - last_update_time;
+	if (delta <= 0.0001) {
+		return;
 	}
+
+
+	char          buf[1024];
+ 	struct ifconf ifc;
+ 	struct ifreq *ifr;
+	int           sock;
+ 	int           nInterfaces;
+ 	int           i;
+ 
+ 
+ 	sock = socket(AF_INET, SOCK_DGRAM, 0);
+ 	if(sock < 0)
+ 	{
+ 		fprintf(stderr,"socket");
+ 		return;
+ 	}
+
+ 	/* Query available interfaces. */
+	ifc.ifc_len = sizeof(buf);
+ 	ifc.ifc_buf = buf;
+ 	if(ioctl(sock, SIOCGIFCONF, &ifc) < 0)
+ 	{
+		fprintf(stderr,"ioctl(SIOCGIFCONF)");
+ 		close(sock);
+ 		return;
+ 	}
+
+	/* Iterate through the list of interfaces. */
+	ifr         = ifc.ifc_req;
+ 	nInterfaces = ifc.ifc_len / sizeof(struct ifreq);
+ 	for(i = 0; i < nInterfaces; i++) {
+	
+ 		struct ifreq *item = &ifr[i];
+ 		if (strcmp(item->ifr_name,"lo0") == 0)
+			continue;
+
+		ns = get_net_stat((const char *) item->ifr_name);
+  
+			                                                                                                                
+		ns->up = 1;                                                                           
+		last_recv = ns->recv;                                                                 
+		last_trans = ns->trans;                                                               
+ 		
+		if (item->ifr_flags & IFF_LOOPBACK)
+			continue;
+
+		memcpy(&(ns->addr), &item->ifr_addr, sizeof(item->ifr_addr));               
+	        
+
+		ksp = kstat_lookup(kc, NULL, -1, item->ifr_name);                                                                                                      
+		if (kstat_read(kc, ksp, 0) == -1)                                                                                                                      
+			fprintf(stderr,"kstat read");                                                                                                                                
+		data_lookup = kstat_data_lookup(ksp, "rbytes");              
+		if (data_lookup)
+			r = (long long) data_lookup->value.ui32;
+		data_lookup = kstat_data_lookup(ksp, "obytes");              
+		if (data_lookup)
+			t =(long long) data_lookup->value.ui32;
+
+
+		if (r < ns->last_read_recv) {
+			ns->recv += ((long long) 4294967295U - ns->last_read_recv) + r;
+		} else {
+			ns->recv += (r - ns->last_read_recv);
+		}
+
+		ns->last_read_recv = r;
+		if (t < ns->last_read_trans) {
+			ns->trans += ((long long) 4294967295U - ns->last_read_trans) + t;
+		} else {
+			ns->trans += (t - ns->last_read_trans);
+		}
+
+		ns->last_read_trans = t;
+
+		ns->recv_speed = (ns->recv - last_recv) / delta;
+		ns->trans_speed = (ns->trans - last_trans) / delta;
+
+ 	}
+	
+	close(sock);
+																				    
 }
 
-void update_meminfo()
+double get_load_average1()
 {
-	/* TODO */
+    double avenrun[LOADAVG_NSTATS], fload = 0;
+    if (getloadavg(avenrun, LOADAVG_NSTATS) > 0)
+        fload = avenrun[LOADAVG_1MIN];
+    return fload;
 }
-
-int check_mount(char *s)
+double get_load_average5()
+{
+    double avenrun[LOADAVG_NSTATS], fload = 0;
+    if (getloadavg(avenrun, LOADAVG_NSTATS) > 0)
+        fload = avenrun[LOADAVG_5MIN];
+    return fload;
+}
+double get_load_average15()
 {
-	/* stub */
-	return 0;
+    double avenrun[LOADAVG_NSTATS], fload = 0;
+    if (getloadavg(avenrun, LOADAVG_NSTATS) > 0)
+        fload = avenrun[LOADAVG_15MIN];
+    return fload;
 }
